<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"lang=th><meta charset=UTF-8><meta content=width=device-width,initial-scale=1 name=viewport><link href=https://www.unto.re/th/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link title=" เว็บไซต์ของ notreh"href=https://www.unto.re/feed.xml rel=alternate type=application/rss+xml><link href=https://www.unto.re/amp/th/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2022,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><link href=/libs/highlight/github.min.css rel=stylesheet><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><link href=/css/bundle.css media=print onload=this.onload=null;this.removeAttribute('media'); rel=stylesheet><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> สร้างผู้รวบรวมเนื้อหาเพื่อความสนุกสนานและผลกำไร?</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/th/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/th/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2022-12-15T18:50:41.896","inLanguage":"th","name":"","mainEntityOfPage":{"@id":"/th/posts/Content-Aggregator/","@type":"Article"}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/th/></a><div class=author__wrap><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><ul><li class=author__avatar onclick=toggleTheme()><img alt=" notreh-light"class=flip-front src=/assets/appa.webp><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button class=search-button formaction=/search/index.html title=ค้นหาเว็บไซต์ value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/th/posts/><i class="fas fa-pen menu-icons"></i> โพสต์</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/th/media/><i class="fas fa-tv menu-icons"></i> สื่อ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div><button name="Website Menu"class=ham type=button><i class="fas fa-bars ham-icon"></i></button><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button class=search-button formaction=/search/index.html title=ค้นหาเว็บไซต์ value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/th/posts/><i class="fas fa-pen menu-icons"></i> โพสต์</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/th/media/><i class="fas fa-tv menu-icons"></i> สื่อ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div></nav></div></div></div><div><h1 id=title><a href=/th/posts/Content-Aggregator> สร้างผู้รวบรวมเนื้อหาเพื่อความสนุกสนานและผลกำไร?</a></h1><blockquote id=page-description style=font-style:italic>แอปเต็มรูปแบบที่รวบรวม ประมวลผล และนำเสนอเนื้อหาจากเว็บ...บนเว็บ</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> ทำไม</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> ข้อมูลเกินพิกัด</a> ? ทุกวันนี้ค่อนข้างแย่ แหล่งข้อมูลที่มีสัญญาณและสัญญาณรบกวนต่ำมาก การจำกัด "ฟีด" ของคุณให้แคบลงจนคุณไม่ถูกครอบงำนั้นค่อนข้างยาก เครื่องมือที่กรองข้อมูลและนำเสนอในรูปแบบที่ย่อยง่ายและรวดเร็วจะเป็นประโยชน์อย่างมาก นี่คือเหตุผลที่ฉันพิจารณา<em> การรวมเนื้อหา</em> เขตป่าดิบสำหรับการหยุดชะงัก มันเป็นและจะเป็นตลอดไป (ตราบใดที่อินเทอร์เน็ตฟรีและมีการแสดงความคิดเห็นฟรี) เป็นโอกาสทางธุรกิจที่ดี เป็นหนึ่งในตัวอย่างทั้งหมดที่เกี่ยวข้องกับการดำเนินการ (และไม่เกี่ยวกับแนวคิดเลย)<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> การจัดการความคาดหวัง</a></h1><p>ต้องบอกว่าท้ายที่สุดแล้วแอปของฉันไม่ได้ทำการกรองจริง ๆ ในความเป็นจริงมันเป็นเพียง<em> มวลรวม</em> เนื้อหาจากเว็บ นี่เป็นเพราะฉันไม่ได้สร้างผู้ใช้เข้ามา และไม่มีแรงจูงใจในการกรองหากไม่สามารถปรับแต่งตามผู้ใช้แต่ละรายได้<h1 id=the_architecture><a class=header-anchor href=#the_architecture> สถาปัตยกรรม</a></h1><p>แผนผังของสถาปัตยกรรม:<img alt=" เนื้อหารวบรวมไดอะแกรม"src=/assets/posts/img/content-aggregator-diagram.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block>มีวงกลมมากมายในนั้น!...คุณรู้หรือไม่ว่า...ไมโคร...บริการ? แอพที่ฉันสร้างขึ้นคือ "scraper" และ "เซิร์ฟเวอร์" ในขณะที่ "ผู้เผยแพร่" เป็นเพียงรูทีนที่ฝังอยู่ในเซิร์ฟเวอร์ "การค้นหา" และ "พร็อกซี" เป็นเครื่องมือภายนอกที่ทำงาน "ส่วนหน้า" ไม่มีอะไรพิเศษ การผสมผสานระหว่าง js และ css ที่มาพร้อมกับ webpack<p>เนื่องจากมีส่วนที่เคลื่อนไหวต่างกัน ฉันจะไปตามกระแสของเนื้อหา เริ่มตั้งแต่ตอนที่เนื้อหาถูกดูเป็นครั้งแรก<h1 id=the_scraper><a class=header-anchor href=#the_scraper> มีดโกน</a></h1><p>การขูดเสร็จสิ้นใน...คุณเดาได้ หลาม อย่างไรก็ตาม ไม่มีการใช้โมดูล "scraping" แบบเฉพาะกิจ<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> คุณขูดอะไร</a></h2><p>การตัดสินใจว่าจะขูดอะไรขึ้นอยู่กับหมวดหมู่ของเนื้อหา เราเรียกหมวดหมู่ว่า "หัวข้อ"<ul><li><p>ทุกหัวข้อมีรายการคำหลัก<li><p>รายการคำหลักหากดึงมาจาก Google AdWords โดยใช้คำหลักเหล่านั้น<a href=https://github.com/googleads/google-ads-python> หลาม api</a><li><p>คำหลักถูกค้นหาในเครื่องมือค้นหาหลายรายการตามลำดับแบบวนรอบเป็นระยะ หากอินสแตนซ์มีหลายหัวข้อ หัวข้อที่มีเนื้อหาน้อยจะถูกค้นหาก่อน สำหรับการค้นหาที่เราพึ่งพา<a href=https://github.com/searxng/searxng> เซียร์</a> พร้อมผู้รับมอบฉันทะ Searx นั้นไม่เป็นมิตรกับห้องสมุดอย่างแน่นอน เนื่องจากการใช้งานหลักคือสำหรับส่วนหน้า ดังนั้นจึงจำเป็นต้องขุดผ่านกระบวนการที่ถูกต้องเพื่อเริ่มต้นโมดูลเพื่อทำการค้นหา เพื่อเพิ่มความเร็วด้วยการใช้ threadpool เพื่อดำเนินการหลาย ๆ คำสั่งพร้อมกัน เราจะใช้ threadpool บ่อย ๆ ตลอดทั้งโครงการ<li><p>การค้นหาคำหลักทุกครั้งจะสร้างรายการแหล่งที่มาของเนื้อหาที่เป็นไปได้ (ผลลัพธ์ของเครื่องมือค้นหา) ซึ่งบันทึกไว้ในที่เก็บข้อมูลสำหรับการประมวลผลในภายหลัง<li><p>เมื่อเราต้องการค้นหาเนื้อหาใหม่สำหรับหัวข้อใดหัวข้อหนึ่ง เราจะตรวจสอบก่อนว่ามีแหล่งที่มาหรือไม่ มิฉะนั้น เราจะสร้างแหล่งข้อมูลใหม่จากรายการคำหลัก<img alt=" ท่อเนื้อหา"src=/assets/posts/img/content-pipeline.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block><li><p>แหล่งที่มาถูกประมวลผลผ่านสองไลบรารี<a href=https://github.com/adbar/trafilatura> ทราฟิลาทูร่า</a> เป็นตัวหลักหากล้มเหลวเราจะสำรองข้อมูลไว้<a href=https://github.com/goose3/goose3> ห่าน</a> . นอกจากนี้ เรายังพยายามหาฟีดสำหรับลิงก์เพิ่มเติม (ซึ่งถือว่าเป็นแหล่งที่มาใหม่) สำหรับฟีดที่เราใช้<a href=https://github.com/dfm/feedfinder2> ฟีดเดอร์</a> แต่การแยกวิเคราะห์ html อย่างง่ายสำหรับ rss<code>link</code> แท็กก็เพียงพอแล้ว<li><p>ประเภทเนื้อหาหลักของเราคือ<code>Article</code> ซึ่งจากด้านไพ ธ อนเป็นเพียง dict จากด้าน nim โดยแยกวิเคราะห์เป็นวัตถุ คีย์:<ul><li><p><code>title</code> : ส่วนหัวของบทความ<li><p><code>content</code> : บทความนั้นเอง. เพื่อพิจารณาว่าบทความใดเป็นบทความที่ดี เราจะผ่านขั้นตอนการกรองที่แตกต่างกัน:<ul><li><p>ขั้นแรก เราตรวจสอบว่า trafilatura หรือห่านมีข้อความหรือไม่ และมีความยาวเพียงพอหรือไม่ ขนาดขั้นต่ำของเราคือ 300 คำ หากขนาดไม่ตรงกัน เราจะละทิ้งแหล่งที่มา (ไม่คืนค่าใดๆ)<li><p>จากนั้นเราจะเรียกชื่อเรื่องและฆ่าเชื้อโดยการลบ URL และช่องว่างออก<li><p>ถ้าภาษาต่างประเทศเป็นภาษาต่างประเทศ เราจะแปลกลับเป็นภาษาอังกฤษ (เราทำให้เป็นมาตรฐานมากกว่าภาษาอังกฤษ) ทั้งเนื้อหาและชื่อเรื่อง<li><p>ณ จุดนี้ เราตรวจสอบการใช้คำหยาบคาย<a href=https://github.com/dimitrismistriotis/alt-profanity-check> profanity_check</a> . ไม่ใช่ว่าการตรวจสอบคำหยาบคายเป็นภาษาอังกฤษตามการแปลก่อนหน้าเป็นสิ่งที่จำเป็น มิฉะนั้น เราจำเป็นต้องมีรูปแบบคำหยาบคายสำหรับทุกภาษา<li><p>หลังจากที่เราแทนที่คำหยาบโดยใช้ตัวกรองคำหยาบคายแล้ว เราจะดำเนินการต่อโดยทำความสะอาดเนื้อหา เราตรวจสอบว่าบทความมีความเกี่ยวข้องหรือไม่ มีกฎที่เราใช้คือ:<ul><li><p>เนื้อหาต้องขึ้นต้นด้วยตัวอักษรและตัวเลข มิฉะนั้นจะมีการเปลี่ยนแปลงสูงว่าเป็นขยะ<li><p>ทั้งชื่อเรื่องและเนื้อหาต้องไม่มี "เสียงรบกวน" สัญญาณรบกวนถูกกำหนดโดย regex ที่จับคำหลักเช่น "เข้าสู่ระบบ", "สมัคร", "การเข้าถึงถูกปฏิเสธ" ... ฯลฯ<li><p>อย่างน้อยหนึ่งคำในชื่อเรื่องต้องมีอยู่ในเนื้อความ มิฉะนั้น อาจเป็นไปได้ว่าการแยกวิเคราะห์เลือกส่วนผิดของหน้าต้นฉบับสำหรับเนื้อหา</ul><li><p>หากผ่านการทดสอบความเกี่ยวข้อง ในขั้นตอนสุดท้าย เราจะทำความสะอาดเนื้อหาไม่ให้มีวงเล็บเหลี่ยม ช่องว่างมากเกินไป อักขระซ้ำ และอักขระพิเศษ<li><p>หากการทำความสะอาดไม่ได้ลบทุกอย่าง เราจะดำเนินการกับบทความต่อไป</ul><li><p><code>source</code> : ลิงก์ที่ชี้ไปยังแหล่งที่มาดั้งเดิมที่เราแยกวิเคราะห์<li><p><code>lang</code> : ภาษาของบทความที่เราใช้<a href=https://github.com/pemistahl/lingua-py> ภาษา</a> เพื่อตรวจหาภาษา<li><p><code>desc</code> : สรุป มิฉะนั้น ตัดตอนมาจากเนื้อหา<li><p><code>author</code> : ผู้เขียน มิฉะนั้นจะเป็นชื่อของหน้าแรกของซอร์สลิงก์<li><p><code>pubDate</code> : วันที่เผยแพร่บทความหรือตอนนี้<li><p><code>topic</code> : หัวข้อที่เป็นของบทความนี้<li><p><code>tags</code> : คำหลักที่เกี่ยวข้องสำหรับบทความ เราใช้ lib การแยก kw ที่เร็วที่สุด ซึ่งก็คือ<a href=https://github.com/csurfer/rake-nltk> คราด</a> , ทางเลือกที่พิจารณาได้แก่<a href=https://github.com/kevinlu1248/pyate> ปิเอเต</a> (คอมโบเบสิค),<a href=https://github.com/DerwenAI/pytextrank> อันดับข้อความ</a> และ<a href=https://github.com/slanglab/phrasemachine> เครื่องวลี</a><li><p><code>imageTitle</code> : ข้อความทางเลือกสำหรับรูปภาพ<li><p><code>imageOrigin</code> : ถ้าแยกวิเคราะห์แหล่งที่มา (สำหรับรูปภาพที่เราใช้<a href=https://github.com/michaelhelmick/lassie> สาว</a> ) ไม่พบรูปภาพ เราค้นหารูปภาพที่เกี่ยวข้องในเครื่องมือค้นหา ดังนั้น imageOrigin จึงชี้ไปที่หน้าเดิมซึ่งโฮสต์รูปภาพนั้น มิฉะนั้นจะเท่ากับ URL ต้นทาง<li><p><code>imageUrl</code> : ลิงก์ไปยังรูปภาพจริง เราใช้ตัวกรองบานตรวจสอบภาพที่ซ้ำกัน เพราะเราไม่ชอบภาพที่ซ้ำกัน<li><p><code>icon</code> : favicon ของลิงค์ต้นทาง</ul><li><p>หลังจากที่เราประมวลผลคำหลักแล้ว เราจะบันทึกบทความและฟีดที่พบบนพื้นที่เก็บข้อมูล จะใช้โดยผู้เผยแพร่โฆษณา</ul><p>การขูดเกิดขึ้นอย่างต่อเนื่อง มันคือปีศาจ รหัสจำลองลูปหลักมีลักษณะดังนี้ และได้รับการกำหนดค่า<em> ต่อไซต์</em>:<ul><li><p>ซิงค์พร็อกซีตลอดไป<li><p>สำหรับแต่ละหัวข้อเรียงตามจำนวนบทความที่ไม่ได้เผยแพร่ (จากน้อยไปมาก) ให้ทำดังต่อไปนี้<ul><li><p>หากช่วงเวลาขั้นต่ำจากงานล่าสุดผ่านไป ให้รันงานแยกวิเคราะห์สำหรับหัวข้อ ช่วงเวลาจะเพิ่มบทความที่ไม่ได้เผยแพร่มากขึ้นที่เรามีสำหรับหัวข้อหนึ่งๆ และจะเป็น 0 เสมอหากเราไม่มีบทความที่ไม่ได้เผยแพร่เลย<li><p>ทำเช่นเดียวกัน แต่สำหรับฟีด (ที่เรารวบรวมจากแหล่งที่มา หากมี)<li><p>หากไซต์มีจุดประสงค์เพื่อสร้างหัวข้อใหม่ ให้สร้างขึ้นใหม่ (สิ่งนี้สมเหตุสมผลถ้าคุณไม่ได้ตัดสินใจเลือกรายการหัวข้อเมื่อสร้างไซต์)<li><p>เลือกบทความจากบทความที่เผยแพร่แล้วส่งทวีต (เราส่ง 3 ทวีตต่อวันโดยใช้<a href=https://github.com/bear/python-twitter> หลาม-twitter</a>)<li><p>เลือกบทความจากบทความที่เผยแพร่และอัปเดตหน้า Facebook (เราอัปเดต 1 ครั้งต่อวันโดยใช้<a href=https://github.com/jgorset/facepy> หน้าบาน</a>)</ul><p>(เราเชื่อมต่อกับ reddit ด้วย แต่ reddit ไม่อนุญาตให้โพสต์ข้าม ดังนั้นจึงเป็นความพยายามที่สูญเปล่า)</ul><h1 id=publishing><a class=header-anchor href=#publishing> สำนักพิมพ์</a></h1><p>เมื่อเรามีเนื้อหาที่จะเผยแพร่แล้ว เราต้องตัดสินใจว่าจะเผยแพร่อะไรและบ่อยเพียงใด ฉันไม่ได้คิดกลอุบายใดๆ ขึ้นมาที่นี่ เพราะอย่างที่ฉันได้กล่าวไปก่อนหน้านี้ การเลือกสิ่งที่จะแสดงนั้นขึ้นอยู่กับผู้ใช้ ดังนั้นเราจึงเผยแพร่จาก<em> ใหม่ที่สุดไปเก่าที่สุด</em> ด้วยเหตุผลที่ว่าบางสิ่งที่เราคัดมาเมื่อเร็วๆ นี้มีความเกี่ยวข้องมากกว่า มันคือ<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> LIFO</a> คิว. การเผยแพร่แม้ว่าจะค่อนข้างพึ่งพาเครื่องมือไพธอน แต่ก็เกิดขึ้นใน nim เพราะมันทำงานติดกับเซิร์ฟเวอร์ซึ่งอยู่ใน nim เช่นกัน<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> ตรรกะการเผยแพร่</a></h2><p>การเผยแพร่เกิดขึ้นอย่างต่อเนื่อง และเช่นเดียวกับการคัดลอกที่มีช่วงว่าง การเผยแพร่จะตรงกันข้ามกับการคัดลอก เวลาขูดก็ช้าลงเมื่อเรามี<em> นานพอ</em> แคชของบทความที่ไม่ได้เผยแพร่ การเผยแพร่ทำให้เราช้าลงเมื่อแคชของเราเริ่มลดขนาดลงมากเกินไป ด้วยวิธีนี้ควรมีควบคู่กับการขูดเสมอ<em> เนื้อหาบางส่วน</em> ที่จะเผยแพร่<em> บางเวลา</em> ในอนาคต. ตรรกะการเผยแพร่จริง:<ul><li><p>ดึงชุดบทความที่ไม่ได้เผยแพร่จากแคช (เราเลือกที่จะเผยแพร่บทความใหม่ 3 บทความต่อรอบ)<li><p>ตรวจสอบว่าซ้ำกันหรือไม่ การตรวจสอบซ้ำจะทำผ่านการแฮชที่ไวต่อโลคัล โดยใช้ประโยชน์จาก nim lib<a href=https://github.com/Nim-NLP/minhash/> มินแฮช</a> . LSH ค่อนข้างใช้ CPU มาก (คุณรู้ไหมว่า...การแฮช) และต้องใช้เธรดของตัวเอง (มีงานอีกสองสามอย่างที่เราจัดการซึ่งต้องใช้เธรดของตัวเอง)<li><p>การเรนเดอร์หน้า: ไม่จำเป็น เนื่องจากเซิร์ฟเวอร์จัดการการสืบค้นได้ทันที แต่การแสดงผลที่นี่เป็นรูปแบบหนึ่งของการแคชล่วงหน้า<li><p>การจัดการหน้า เนื่องจากเรากำลังจัดการกับไซต์หนึ่งๆ เราต้องเลือกจำนวนบทความที่จะแสดงต่อหน้า และเพิ่มหน้าเมื่อเราเผยแพร่บทความมากขึ้น เราเลือกที่จะจัดกลุ่มบทความในหน้าประมาณ 10 หน้า หน้าล่าสุดมีน้อยกว่า 10 บทความเสมอ<li><p>บันทึกสถานะของบทความที่เผยแพร่ ซึ่งหมายถึงการย้ายบทความจากสถานะ "ไม่ได้เผยแพร่" เป็นสถานะ "เผยแพร่แล้ว" และฐานข้อมูล LSH<li><p>หลังจากเผยแพร่บทความใหม่ เราต้องล้างแคชเก่า เราต้องล้างหน้าแรก หน้าหัวข้อ และแผนผังไซต์และฟีด rss</ul><h1 id=serving><a class=header-anchor href=#serving> ให้บริการ</a></h1><p>เราตั้งค่างานเพื่อขูดเนื้อหาเผยแพร่ ที่เหลือคือให้บริการ<h2 id=the_web_server><a class=header-anchor href=#the_web_server> เว็บเซิร์ฟเวอร์</a></h2><p>หลังจากมี<a href=https://github.com/dom96/jester> พยายาม</a><a href=https://github.com/dom96/httpbeast> แตกต่าง</a><a href=https://github.com/olliNiinivaara/GuildenStern/> เว็บ</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> เซิร์ฟเวอร์</a>เนื่องจากข้อบกพร่องต่าง ๆ ที่ฉันตัดสินด้วย<a href=https://github.com/bung87/scorper> แมงป่อง</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> การจัดการคำขอ</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> เราเตอร์</a></h3><p>เราใช้นิม<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> การดำเนินการจับคู่รูปแบบ</a> เพื่อให้ตรงกับการจับ regex ทูเพิล นี่คือ regex ที่ไม่สงบเลย:<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> แสดงโหนดที่เป็นไปได้ทั้งหมดที่เส้นทางสามารถมีได้ จากนั้นการกำหนดเส้นทางของเราจะมีลักษณะดังนี้:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>มันไม่สวยงาม แต่การไม่พึ่งพาเราเตอร์ตัวใดตัวหนึ่งทำให้ฉันสามารถสลับเว็บเซิร์ฟเวอร์ที่อยู่ใต้บังคับบัญชาได้โดยไม่ต้องยุ่งยากมากเมื่อทำการทดสอบ มันมีประสิทธิภาพ? ไม่ชัดเจน! ยังไม่ได้ทำเกณฑ์มาตรฐานใด ๆ เปรียบเทียบกับสิ่งอื่น อย่างไรก็ตามสิ่งที่มีกลิ่นมาจาก regex ที่อาจมีข้อบกพร่องได้ และข้อเท็จจริงที่ว่าการเรียงลำดับกรณีมีความสำคัญ<blockquote><p>รอสักครู่...</blockquote><p>มีหลายสิ่งหลายอย่างที่เราทำในแต่ละคำขอก่อนกำหนดเส้นทางหน้าจริง:<p>เริ่มแรกเราตั้งค่ารหัสการล้างข้อมูล (ด้วย<code>defer:</code> ) ที่<em> ควร</em> ให้แน่ใจว่าไม่มีการรั่วไหลเกิดขึ้น<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>เราตรวจสอบว่าเธรดเริ่มต้นหรือไม่:<pre><code class="nim hljs">initThread()</code></pre><p>สิ่งนี้ควรทำงานเพียงครั้งเดียว (ตั้งค่าโกลบอลบูลหลังจากเริ่มต้นเพื่อตรวจสอบ) และสามารถทำได้นอกตัวจัดการคำขอ แต่สิ่งที่เริ่มต้นจริง? ก็...ของเยอะพอสมควร! โดยพื้นฐานแล้วเรา (ab) ใช้ค่าคงที่ส่วนกลางซึ่งต้องมีการเตรียมใช้งาน และบางส่วนก็ไม่เกี่ยวข้องกับเธรด เนื่องจากค่าเหล่านี้เริ่มต้นหน่วยความจำบนฮีปและแชร์ข้ามเธรด<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>จากนั้นเราจะแยกวิเคราะห์พารามิเตอร์<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>เราใช้พารามิเตอร์เพื่ออะไร เดอะ<code>ParamKey</code> ประเภท enum อธิบายว่า:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>พวกเราทำ<em> ไมโครแคช</em> สำหรับคำขอ ดังนั้นทุกคำขอจะถูกแคชตามทูเพิล<code>(path, query, accetEncoding)</code> จำเป็นต้องมีการเข้ารหัสเนื่องจากเราสามารถให้บริการทั้ง (ไม่) เนื้อหาที่ถูกบีบอัด บริบทคำขอมีลักษณะดังนี้:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>NS<code>key</code> ฟิลด์นี้ใช้เพื่อดึงหน้าแคช (เนื้อหา) ที่ถูกต้องจาก<code>pageCache</code>. จำเป็นต้องล็อกเพื่อให้แน่ใจว่าคำขอหลายรายการที่เกิดขึ้นพร้อมกันจะไม่สร้างงานการแสดงผลที่ซ้ำกัน (หากคำขออื่นกำลังสร้างหน้าอยู่แล้ว ให้รอให้เสร็จสิ้น) ทุกฐาน<code>HttpRequestRef</code> จาก chronos httpsserver ถูกเก็บไว้ในไฟล์<code>rq</code> สนาม. เดอะ<code>params</code> แยกวิเคราะห์จากก่อนหน้านี้แล้ว<code>handleParams</code>.<li><p>เราสนับสนุนการลบเนื้อหาผ่าน<code>d</code> param ซึ่งทำให้เราสามารถ nuke บทความ (ในกรณีที่การกรองล้มเหลว แต่ไม่ควรใช้ในทางปฏิบัติ สำหรับการดีบักเท่านั้น) ด้วยคำขอรับ http ง่ายๆ ใครต้องการวิธี http อื่น ๆ ไม่ใช่ฉัน.<li><p>เรารองรับการล้างแคชด้วย เราสามารถลบหน้า<code>c=0</code> หรือทุกหน้า<code>c=1</code> . บิตที่น่ารำคาญคือเราต้องตรวจสอบว่าเส้นทางนั้นเป็นบทความ หน้า รูปภาพหรือสินทรัพย์หรือไม่ และกำจัดโครงสร้างแคชที่เหมาะสม มีความซ้ำซ้อนของลอจิกที่ชัดเจนที่นี่กับเราเตอร์ แต่เนื่องจากการดำเนินการนี้เสร็จสิ้นก่อนการกำหนดเส้นทาง จึงต้องเป็นแบบเฉพาะกิจ โดยจัดการเฉพาะกรณีที่เกี่ยวข้องกับการล้างแคชเท่านั้น มีการกำหนดเส้นทางล่วงหน้าเนื่องจากแคชยังให้บริการโดยไม่มีการกำหนดเส้นทาง เนื่องจากหากมีการสร้างคำขอแล้ว เราก็สามารถตอบกลับด้วยเนื้อหาที่จัดเก็บไว้ใน<code>respBody</code> สนาม (และ<code>respHeaders</code>, <code>respCode</code>).<li><p>หลังจากจัดการกับการดำเนินการแคช เราจะแยกวิเคราะห์เส้นทาง<li><p>หลังจากนี้จะมีการหักหลังเกิดขึ้นอีก:</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>เหตุใดจึงทำสิ่งนี้ก่อนกำหนดเส้นทางด้วย ตามค่าเริ่มต้น เราให้บริการหน้าที่แปลบางส่วน เราแย่ :( และการแปลขึ้นอยู่กับบริการฟรี แต่เราไม่สามารถจ่ายให้กับเวลาในการโหลดสุดซึ้งได้ ดังนั้นเราจึงเรียกใช้การแปลที่เลื่อนออกไป ในขณะที่เราให้บริการหน้าที่แปลโดยมีเพียงตัวอย่างข้อมูลที่แคชไว้ในฐานข้อมูลการแปลของเราเท่านั้น<p>ณ จุดนี้ มีการกำหนดเส้นทาง ซึ่งรวมอยู่ในข้อยกเว้น เช่น หากการแสดงหน้าที่ถูกต้องล้มเหลว เราจะออก a<code>503</code> . ออก ก<code>503</code> หมายความว่าเราพยายามกำหนดเส้นทาง URL ที่ถูกต้อง แต่ไม่สามารถสร้างเพจได้ สำหรับ URL ที่ไม่ถูกต้อง เราจะออก a<code>301</code> เปลี่ยนเส้นทางซึ่งแสดงว่า url ไม่ถูกต้อง เราให้บริการ URL ที่แตกต่างกัน 11 ประเภท:<ul><li><p>หน้าแรก: ดึงบทความจากหัวข้อล่าสุด หลอกแบบสุ่ม เราไม่ได้จัดเรียงตามความนิยม<li><p>สินทรัพย์ทั่วไป (ภายใต้<code>/assets/</code> เส้นทาง): ถูกแมปโดยตรงกับไดเร็กทอรีเฉพาะ<li><p>ภาพทั่วไป (ภายใต้<code>/i/</code> pah): เราพร็อกซีรูปภาพภายนอกเพื่อสร้างขนาดที่พอดีกับเว็บไซต์ที่ตอบสนองของเรา เมื่อรูปภาพไม่พร้อมใช้งาน พิกเซลโปร่งใสหรือไอคอนรูปภาพจะทำหน้าที่เป็นค่าเริ่มต้น<li><p>ไฟล์ robots.txt<li><p>แผนผังไซต์ (สำหรับหน้าแรกและหัวข้อและหน้าต่างๆ): หน้าแรกโฮสต์แผนผังไซต์ที่ชี้ไปยังหัวข้อทั้งหมด แผนผังไซต์ชี้ไปที่หัวข้อทั้งหมด แผนผังไซต์ชี้ไปที่หน้าทั้งหมดของหัวข้อ แผนผังไซต์ของหน้าชี้ไปที่บทความทั้งหมดของหน้านั้น<li><p>รายการ pwa: รายการ pwa ควรอนุญาตให้ติดตั้งเว็บไซต์เป็น pwa (แต่จริง ๆ แล้วยังไม่ได้ทดสอบสิ่งนี้)<li><p>การค้นหา: ใช้ประโยชน์จากการค้นหา<a href=https://github.com/valeriansaliou/sonic> โซนิค</a> กับ<a href=https://github.com/alongwy/pysonic> พีโซนิก</a> การผูก<li><p>ข้อเสนอแนะ: ข้อเสนอแนะจะได้รับการจัดการผ่านห้องสมุดเสียง แต่พวกเขาต้องการ<li><p>ฟีด: เช่นเดียวกับแผนผังไซต์ เรามีฟีดที่แตกต่างกันสำหรับหน้าแรกและสำหรับหัวข้อต่างๆ แม้ว่าจะไม่มีฟีดสำหรับหน้าเดียวด้วยเหตุผลที่ชัดเจน<li><p>หน้าหัวข้อ: หน้าที่อุทิศให้กับแต่ละหัวข้อ (เช่น มีเส้นทาง<code>domain.com/my-topic/</code> ) ดึงบทความล่าสุดที่เผยแพร่สำหรับหัวข้อซึ่งเป็นของ<em> ยังไม่เสร็จ</em> หน้าหนังสือ.<li><p>หน้าบทความ: หน้าบทความแสดงชื่อบทความ คำอธิบาย ลิงก์แหล่งที่มา แท็ก เวลาที่เผยแพร่ (ในส่วนท้าย) และที่ด้านล่าง เราจะดึงบทความที่เกี่ยวข้อง 3 รายการ บทความที่เกี่ยวข้องจะถูกเรียกโดยใช้คำค้นหาที่ชื่อบทความหรือแท็ก</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> เกี่ยวกับการเรนเดอร์</a></h2><p>การเรนเดอร์เพจถูกประมวลผลจากด้าน nim โดยใช้<a href=https://github.com/karaxnim/karax> คาแรกซ์</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> เค้าโครงหน้าทั่วไป</a></h3><p>เว็บไซต์ประกอบด้วยแถบคงที่ด้านบนซึ่งแสดง:<ul><li><p>URL หน้าแรกผ่านภาพโลโก้ svg<li><p>ปุ่มธีมสว่าง/มืด<li><p>URL ปัจจุบันโดยใช้เส้นทางปัจจุบัน<em> เศษ</em> เป็นข้อความลิงค์<li><p>URL หัวข้อประมาณ 10 รายการล่าสุด<li><p>แถบค้นหา (พร้อมปุ่มค้นหา) ซึ่งเมื่อพิมพ์คำแนะนำจะปรากฏขึ้น<li><p>ปุ่มภาษา ซึ่งเมื่อคลิก รายการภาษาจะลอยขึ้น</ul><p>เนื่องจากเป็นการออกแบบที่ปรับเปลี่ยนตามอุปกรณ์ เมื่อวิวพอร์ตมีขนาดเล็กลง แถบด้านบนจะเก็บเฉพาะช่องค้นหา ส่วนส่วนที่เหลือจะปรากฏในแถบด้านข้างที่สลับได้<ul><li><p>ส่วนท้ายถือลิงก์สำหรับแผนผังเว็บไซต์ rss โซเชียล กฎหมาย<li><p>รองรับโฆษณาในสถานที่ต่างๆ</ul><h2 id=rss><a class=header-anchor href=#rss> RSS</a></h2><p>นี่คือฟังก์ชันตัวอย่างที่แสดงสิ่งที่เราทำเมื่อมีการเผยแพร่โพสต์ใหม่เพื่ออัปเดตฟีด:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> แผนผังเว็บไซต์</a></h2><p>นี่คือแกนหลักของการเพิ่ม URL ในแผนผังไซต์:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> เทมเพลต</a></h2><p>เราไม่ใช้เครื่องมือเทมเพลตเนื่องจากการเรนเดอร์ส่วนใหญ่ทำด้วย karax แต่สำหรับหน้าอย่าง ToS เราใช้เทมเพลตไฟล์ ซึ่งเราเพียงแค่แทนที่ตัวแปรจำนวนมาก เช่น<code>envsubst</code> สั่งการ.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> หน้าบทความ</a></h2><p>เมื่อเราแสดงหน้าเช่น หน้าแรก/หัวข้อ และหน้าที่มีหมายเลข เราต้องแสดงรายการบทความ ฟังก์ชันนี้เรียกว่าวนซ้ำสำหรับจำนวนบทความที่เราต้องการแสดง:<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>โปรดทราบว่า "โฆษณา" บางบรรทัดคืบคลานใน X)<h2 id=topics_list><a class=header-anchor href=#topics_list> รายการหัวข้อ</a></h2><p>ในแถบด้านบน เราแสดงรายการหัวข้อ นี่คือสิ่งที่พิมพ์ออกมา:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>ที่นี่มีคลาสดีไซน์ Material แบบฮาร์ดโค้ดที่ส่งกลิ่นเหม็น ส่วนประกอบการออกแบบวัสดุของ Google ตรงไปตรงมา<h2 id=post_footer><a class=header-anchor href=#post_footer> ส่วนท้ายของโพสต์</a></h2><p>ส่วนท้ายของโพสต์ปรากฏที่ด้านล่างขวาของหน้าบทความ (เป็น ltr) และจะพิมพ์เฉพาะวันที่เผยแพร่เท่านั้น<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> ข้อความที่ตัดตอนมา</a></h2><p>เมื่อสร้างรายการบทความ เราอาจต้องการข้อความที่ตัดตอนมาหากไม่มีข้อมูลสรุป<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>Wtf คือ<code>parseHtml</code> ทำที่นี่? เป็นกรณีที่เราอนุญาตให้ใช้ html ภายในเนื้อหาบทความ (แต่มีเฉพาะบางแท็กเท่านั้น) นี่เป็นตัวเลือกจากโมดูล python trafilatura ที่เราเปิดใช้งานไว้เนื่องจากอาจส่งผลต่อรูปแบบบทความ นอกจากนี้เรายังต้องระวังเกี่ยวกับการตัดสตริง utf-8...<h2 id=minification><a class=header-anchor href=#minification> ลดขนาด</a></h2><p>ภารกิจสุดท้ายหลังจากสร้าง Karax<code>VNode</code> ต้นไม้คือการทิ้งไบต์ ต้นไม้ถ้านำหน้าด้วยส่วนหัว html และเลือกที่จะลดขนาด<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>การลดขนาดได้รับการจัดการโดย<a href=https://github.com/wilsonzlin/minify-html> ลดขนาด-html</a> ที่เราผูกไว้ใช้<a href=https://github.com/nim-lang/c2nim> ซีทูนิม</a> ไฟล์รวมประกอบด้วย:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>แต่สำหรับการสร้างเราต้องจัดเตรียมไลบรารีแบบสแตติก โดยเพิ่มบรรทัดนี้ในของเรา<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>ฉันหมายถึง ... นั่นคือเส้นทางของฉันที่ฉันสร้างไลบรารีย่อขนาดซึ่ง<em> เปล่า</em> ไม่มีฟังก์ชัน extern c ที่ nim สามารถใช้ได้จริง ดังนั้นเราต้องเขียนมันเอง<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> Nimpy และภารกิจในการลบขยะที่ไม่มีข้อขัดข้อง</a></h1><p><a href=https://github.com/yglukhov/nimpy/> การผูก Python สำหรับ nim</a> ต้องทิ้งวัตถุหลามฟรี ปัญหาคือเราต้องควบคุมเมื่อ nim ทำ GC ไลบรารี่ nimpy ถือว่า GIL นั้นล็อคอยู่เสมอ (มันล็อคไว้ที่จุดเริ่มต้น) เพื่อให้เรียก python ได้ฟรีทุกเมื่อ แต่เราปลดล็อกกิลเพื่อให้ python threadpool รันโค้ดในขณะที่ nim รันสิ่งอื่นๆ หาก python GIL ถูกล็อคโดย nim เธรดพูลจะไม่ได้ใช้งานเป็นส่วนใหญ่<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>สิ่งนี้ทำให้สามารถเรียกใช้รหัสไพ ธ อนที่ถือ GIL ได้ แต่เฉพาะในเธรดปัจจุบันเท่านั้น การนำไปใช้เพื่อรับ/ปล่อย GIL บนเธรด nim ที่แตกต่างกันนั้นจำเป็นต้องเรียกใช้ฟังก์ชัน python C abi ที่แตกต่างกัน เนื่องจาก GIL เป็น mutex จากนั้นเราเรียก python โดยใช้เทมเพลตนี้:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>เราใช้ฟีเจอร์ nim locks และ guards เพื่อให้แน่ใจว่ามีการเข้าถึงประเภท python เมื่อ GIL ถูกถือเท่านั้น อย่างไรก็ตามสิ่งนี้จำเป็นต้องกำหนด pyobjects ด้วยตัวป้องกัน:<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>ดังนั้นฉันสามารถทำได้:<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>และทุกครั้งที่ฉันโทร<code>myVar</code> ซึ่งเก็บวัตถุ datetime ฉันต้องล้อมมันดังนี้:<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>ตอนนี้เราสามารถล็อกกิลได้เมื่อเราต้องเรียกใช้ GC โดยเอาชนะนิมปี<code>PyObject</code> ตัวทำลายด้วยสิ่งนี้:<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>ล็อคที่เราใช้ภายใน destructor ไม่ใช่<code>AsyncLock</code> เพราะมันจะแพงเกินไปและเรา<em> อย่า</em> ล็อคเสมอเพราะจะทำให้แผงลอย! หากเราไม่สามารถล็อคกิลได้ เราจะชะลอการรวบรวมและเก็บตัวชี้ไพ ธ อนดิบไว้เพื่อที่เราจะสามารถล้างมันได้ จริง ๆ แล้วฉันไม่รู้ว่าสิ่งนี้ทำให้เกิดปัญหาในรูปแบบอื่นหรือไม่ แต่ดูเหมือนว่าจะได้ผล<em> ดีพอ</em>.<p>เรามีโมดูล nim ที่เรียกว่า<code>pyutils.nim</code> นั่นทำสิ่งต่าง ๆ มากมายเช่น nim<>python:<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>อันนี้ใช้ค่อนข้างมาก:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>อันนี้ใช้เมื่อเรากำหนดงาน python และเราต้องการรอให้เสร็จแบบอะซิงโครนัส:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>การรวม python async ที่เหมาะสมจะต้องทำ nim async ในอนาคตให้เสร็จจาก python เมื่อสิ้นสุดงานที่กำหนดเวลาไว้ของ python ซึ่งเราไม่ได้ทำเพราะเรายังไม่ได้มองลึกพอที่จะจัดการกับวัตถุ nim จาก python<h2 id=ampification><a class=header-anchor href=#ampification> การขยาย</a></h2><p>เราสนับสนุน google amp ดังนั้นเราจึงสร้างหน้า amp ที่ค่อนข้างสอดคล้องกับ amp เราไม่ได้มุ่งหวังการสนับสนุนแบบ 1:1 อันที่จริง เราล้างจาวาสคริปต์ทั้งหมดที่เรามีและให้บริการเฉพาะ html/css เท่านั้น ถึงกระนั้น เราก็ต้องระวังที่จะไม่เพิ่มแอตทริบิวต์ที่กำหนดเองในแท็ก html หรือเพียงแค่แท็ก html ที่กำหนดเอง amp ก็แย่เหมือนกัน... สำหรับการแปลงหน้า amp อัตโนมัติ เราจัดการกับ<code>head</code> และ<code>body</code> แท็กแตกต่างกัน<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>สไตล์ทั้งหมดจะรวมเป็นอินไลน์สคริปต์เดียว สิ่งที่เก็บไว้คือ<code>link</code> แท็กที่ไม่ใช่ style/jscript เช่น lang แท็กสคริปต์สำหรับ<code>ldljson</code>, <code>meta</code> แท็ก คำต่อคำจัดการโหนดที่เป็น<em> ตัวอักษร</em> เราต้องแปลงให้เป็น<code>XmlNode</code> (ซึ่งหมายถึงการแยกวิเคราะห์) และจัดการให้ถูกต้อง เนื้อหาของกระบวนการก็คล้ายกัน เราเก็บแท็กบางส่วน ลบแท็กอื่นๆ เปลี่ยนชื่อแท็กอื่นๆ:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>NS<code>form</code> แท็กถูกแทนที่ด้วย<code>amp-form</code> , amp มีแท็กพวกนี้เยอะ...<p>เราต้องแน่ใจว่าสไตล์อินไลน์มีความยาวที่ถูกต้อง:<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>การสร้างแอมป์ของเราไม่ครอบคลุมสเป็คแอมป์ทั้งหมด แต่ใช้ได้กับเนื้อหาของเรา (ผ่านการลองผิดลองถูก :S)<h2 id=search><a class=header-anchor href=#search> ค้นหา</a></h2><p>เมื่อใดก็ตามที่บทความถูกเผยแพร่ บทความนั้นจะถูกนำเข้าไปยังฐานข้อมูลเกี่ยวกับเสียง ฐานข้อมูลเกี่ยวกับเสียงจะจัดการกับ "คอลเลกชัน" "ที่เก็บข้อมูล" และ "วัตถุ"; เรากำหนดคอลเล็กชันเป็นเว็บไซต์ ดังนั้นทุกเว็บไซต์ที่ต้องการปรับใช้ตัวรวมเนื้อหาจะมีคอลเล็กชันของตนเอง เราไม่ใช้<code>buckets</code> แม้ว่าเราจะถือว่าแต่ละหัวข้อเป็นบัคเก็ตที่จะจำกัดการค้นหามากเกินไป ดังนั้นทุกไซต์จึงมีบัคเก็ต "เริ่มต้น" เพียงหนึ่งบัคเก็ต และแต่ละอ็อบเจกต์ของบัคเก็ตคือบทความ (ซึ่งอาจเป็นหัวข้อที่แตกต่างกัน)<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>เมื่อพุชเนื้อหาเป็นโซนิค เราต้องแบ่งข้อมูลออกเป็นชิ้นๆ ซึ่งทราบความยาวสูงสุดเมื่อเชื่อมต่อ การรับข้อมูลดูเหมือนจะติดขัดในบางครั้ง เนื่องจากดูเหมือนว่าจะไม่สามารถจัดการกับอักขระบางตัวได้ ในกรณีที่เซิฟเวอร์โซนิคล่ม เรายังมีฟังก์ชันสำหรับการนำเนื้อหาทั้งหมดกลับมาใช้ใหม่:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> แปล</a></h2><p>การแปลเป็นเรื่องที่ค่อนข้างยุ่งเหยิง ฉันกำลังใช้ wrapper การแปลครั้งที่ 4 (!) หลังจากเขียนเป็น php แล้ว go และ<a href=https://github.com/untoreh/Translator.jl> จูเลีย</a> นี่ก็เขียนด้วย nim ตัวแปร php/go นั้นเน่าเสียเล็กน้อยในปัจจุบัน ในขณะที่ตัวแปรจูเลียถูกใช้อย่างแข็งขันสำหรับบล็อกนี้ อย่างไรก็ตาม เพื่อให้เกิดความล่าช้าต่ำสำหรับเว็บเซิร์ฟเวอร์ วิธีการแปลที่ใช้ใน julia นั้นไม่เหมาะสำหรับการให้บริการตามเวลาจริง (มันแปลไฟล์แบบสแตติก) และอย่างไรก็ตาม การเพิ่ม julia เป็นการอ้างอิงเมื่อเรามี python แล้วจะมีขนาดใหญ่มาก ความต้องการ.<p>ดังนั้นฉันจึงต้องใช้โมดูลการแปลใหม่ใน nim ในความเป็นจริง โมดูลการแปล nim เริ่มต้นนั้นดูคล้ายกับการนำจูเลียไปใช้มาก ซึ่งเรากำลังแปลไฟล์สแตติก<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . หลังจากนั้น เมื่อเว็บเซิร์ฟเวอร์เริ่มเป็นรูปเป็นร่าง ฉันเปลี่ยนมันเพื่อแปลโหนด karax ตามความต้องการ สิ่งนี้ทำให้สามารถแปลหน้าเว็บแต่ละหน้าได้ทันเวลาสำหรับคำขอ<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>ด้านบนคือลูปการวนซ้ำหลัก<code>translateIter</code>:<ul><li><p><code>getTforms</code> แมปฟังก์ชันกับแท็ก html ทำให้สามารถกลายพันธุ์เป็นกรณีไป<li><p><code>rewriteUrl</code> แทรกเส้นทาง lang (เช่น<code>/en/</code> ) ในเส้นทาง URL<li><p><code>translateVbtm</code> จัดการโหนดคำต่อคำซึ่งต้องมีการแยกวิเคราะห์</ul><p>การแปลถูกนำไปใช้กับโหนดข้อความทั้งหมดและกับ<code>alt</code> และ<code>title</code> คุณลักษณะ.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>เนื่องจากเราต้องแปลแต่ละโหนดข้อความแยกกัน (มิฉะนั้น เราจะไม่สามารถเรนเดอร์กลับเป็น html ได้) ทุกการแปลโหนดเป็นงานที่แยกจากกัน เนื่องจากงานสามารถค้นหาบริการแปลของเน็ตได้ จึงต้องทำแบบอะซิงโครนัส เราแยกและรวมคำค้นหาการแปลเพื่อสำรองการเรียก API แต่ภายในของเครื่องมือแปลนั้นไม่สำคัญที่ต้องรู้ สิ่งเดียวที่ควรทราบคือตอนแรกฉันใช้ a<a href=https://github.com/nidhaloff/deep-translator> ห่อหลาม</a> (ซึ่งฉันยังคงใช้สำหรับแปลเนื้อหาที่คัดลอกมา) เนื่องจากการจัดการ wrapper ด้วยตนเองสำหรับ apis ภายนอกนั้นเป็นเรื่องที่เจ็บปวด แต่จากนั้นเปลี่ยนไปใช้บริการแปลภาษา google และ yandex ที่ห่อด้วยตนเองใน nim เนื่องจาก python กลายเป็นคอขวดอย่างมากเมื่อจัดการการแปลพร้อมกันจำนวนมาก<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>ในความเป็นจริงเดิมทีผู้รวบรวมเนื้อหาควรจะสร้างไฟล์คงที่สำหรับ<code>caddy</code> เพื่อแสดง แต่เนื่องจากจำนวนหน้าที่จะสร้าง (ซึ่งเป็นเมทริกซ์ของ n_lang(20) x amp(2) x หน้า) การเรนเดอร์แบบขี้เกียจจึงเป็นตัวเลือกที่ดีกว่า</table><h2 id=stats><a class=header-anchor href=#stats> สถิติ</a></h2><p>มีการติดตามหน้าหัวข้อและบทความสำหรับจำนวนการเข้าชม<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>เราใช้จำนวนการเข้าชมเพื่อล้างหน้าเว็บที่มีจำนวนน้อยเป็นระยะๆ<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> ฐานข้อมูล</a></h2><p>เราใช้<code>libmdbx</code> ผ่าน<a href=https://github.com/snej/nimdbx> lib นี้</a> . อาจมากเกินไปและการใช้ leveldb ก็เพียงพอแล้ว เรามีประเภท<code>LRUTrans</code> โดยที่แนวคิดเริ่มต้นคือการตั้งค่าฐานข้อมูลเป็นแคช LRU แต่ช้ากว่ามาก สามารถพบการนำไปใช้งานได้<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> ที่นี่</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>ประเภทนี้ใช้สำหรับสี่ฐานข้อมูลแยกกัน:<ul><li><p>คำแปล<li><p>แคชหน้า<li><p>แคชรูปภาพ<li><p>สถิติ</ul><p>ประเภทฐานข้อมูลถูกนำไปใช้กับ getters และ setters จากนั้นทำการ de/compression โดยอัตโนมัติเมื่ออ่าน/เขียน ด้วยเหตุนี้จึงไม่ควรใช้สำหรับรูปภาพ...แต่อนิจจา... ยังมีแคชขนาดเล็กจำนวนมาก:<ul><li><p>vbtm: สำหรับเนื้อหาที่แยกวิเคราะห์ (คำต่อคำ)<li><p>ค้นหา: สำหรับคำค้นหา<li><p>ฟีด: สำหรับหัวข้อฟีด VNodes<li><p>rxcache: สำหรับ regex เนื่องจาก regexes แบบคงที่เวลาคอมไพล์ยังไม่ได้มาตรฐาน (เนื่องจากมีไลบรารี regex หลายแห่งใน nim)</ul><p>สิ่งเหล่านี้ถูกนำมาใช้เป็น<a href=https://github.com/jackhftang/lrucache.nim> แคช lru</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> แม่นยำยิ่งขึ้นในฐานะแคช "ล็อก" lru ซึ่งทุกการดำเนินการรับและตั้งค่าจะพันรอบการล็อก (เธรด) การล็อกนี้ไม่สามารถทำให้เกิดการหยุดทำงานด้วยรันไทม์แบบ async เนื่องจากการล็อกนั้นได้รับและปล่อยโดยไม่มีคำสั่งให้ผลตอบแทน ดังนั้นการล็อกจึงเหมือนปรมาณูในแง่นั้น อย่างไรก็ตาม การล็อกยังคงมีประโยชน์เนื่องจากเราใช้เธรดสำหรับงานต่างๆ<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>อย่างไรก็ตาม<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> สตูว์นิ่ม</a> มีการใช้งานที่ง่ายกว่าสำหรับแคช lru ซึ่งฉันจะใช้หากพบเร็วกว่านี้</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> งานพื้นหลัง</a></h1><p>งานสองสามอย่างที่เราใช้งานนั้นต้องใช้ CPU มาก ดังนั้นเราจึงใช้เธรดอื่นสำหรับงานเหล่านี้:<ul><li><p>lsh: การแฮชที่ไวต่อพื้นที่ทำการคำนวณจำนวนมาก<li><p>รูปภาพ: การปรับขนาดรูปภาพต้องมีการถอดรหัส/เข้ารหัสรูปภาพ ดังนั้นจึงมีค่าใช้จ่ายสูง</ul><p>มีการใช้เธรดอีกสองเธรดเพื่ออัปเดตรายการไฟล์เนื้อหาและโฆษณา แม้ว่าจะไม่ใช่ซีพียูที่หิวโหย แต่ก็จำเป็นต้องมีเธรดเพื่อหลีกเลี่ยงการหยุดทำงานที่เกิดจากตัวเฝ้าดูไฟล์<p>นอกจากนี้ เรายังมีงาน async ที่ใช้เวลานานสำหรับ:<ul><li><p>คำแปล<li><p>คำขอ http</ul><p>งาน Lsh รูปภาพ การแปล และคำขอ http ได้รับการจัดการโดยใช้การตั้งค่าผู้ผลิต/ผู้บริโภค ยกเว้นว่าเราจะไม่ใช้แชนเนล เนื่องจากแชนเนลถูกบล็อก และเราไม่มีการใช้งานแบบ async ของแชนเนลที่ปลอดภัยด้วย เราใช้การใช้งาน async ของ<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> นี้</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . และตาราง async ซึ่งเหมือนกับบัสเหตุการณ์<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>เซิร์ฟเวอร์ nim ยังจัดการงาน async สามงาน:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>งานที่ตรวจสอบการใช้ mem เป็นเรื่องดี เพื่อหลีกเลี่ยงปัญหา OOM ระหว่างกระบวนการในคอนเทนเนอร์และนักเทียบท่า เนื่องจากนักเทียบท่า (หรือเคอร์เนล) จะไม่หยุดกระบวนการทันที และในช่วงเวลานี้ เซิร์ฟเวอร์อาจไม่ตอบสนอง ดังนั้น เป็นการดีกว่าที่จะรีสตาร์ทด้วยตนเองทันที<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>แม้ว่าการห่อช่องธรรมดาในรูทีน async น่าจะดีกว่า ... อนิจจา</table><h1 id=images><a class=header-anchor href=#images> รูปภาพ</a></h1><p>เราใช้ประโยชน์จาก<a href=https://github.com/imazen/imageflow/releases> การไหลของภาพ</a> เพื่อปรับขนาดและแคชรูปภาพในเครื่อง การผูกนั้นง่าย แต่กระบวนการมีส่วนร่วมเล็กน้อย กับ<code>getImg</code> เราดึงข้อมูลรูปภาพจาก URL ระยะไกล:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>จากนั้นเราต้องเพิ่มลงในบริบทของอิมเมจโฟลว์:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>หากเพิ่มรูปภาพไม่ได้ หมายความว่าโฟลว์ภาพไม่สามารถรับรู้ข้อมูลว่าเป็นรูปภาพที่ถูกต้อง หลังจากที่เราส่งข้อมูลแล้ว เราต้องส่งคิวรี่ไปยังบริบท จากนั้นอ่านการตอบสนองและรับผลลัพธ์:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>เราได้รับประเภท mime จากการตอบกลับ ซึ่งจะถูกส่งต่อในการตอบสนองของเว็บเซิร์ฟเวอร์ จากฝั่งเซิร์ฟเวอร์ การแปลจากพาธ url ไปยังโฟลว์รูปภาพจะได้รับการจัดการดังนี้:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>URL รูปภาพถูกส่งเป็นพารามิเตอร์ในรูปแบบบีบอัด zstd การบีบอัดทำให้ URL สั้นลง (ส่วนใหญ่) นี่เป็นวิธีที่ฉันพบจุดบกพร่องใน Google Chrome ซึ่งไม่สามารถจัดการ URL ที่ข้อความค้นหามีข้อมูลบีบอัดที่เข้ารหัสด้วย URL Firefox ก็ใช้ได้แทน<h2 id=ld-json><a class=header-anchor href=#ld-json> แอลดี-JSON</a></h2><p>เราเพิ่มสคริปต์ ldjson ในแต่ละหน้าเว็บ<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>และสำหรับหน้าแปล:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> โอเพนกราฟ</a></h2><p>เช่นเดียวกับ ldjson เรายังมีเมตาแท็ก opengraph:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>มาโครและเทมเพลต Nim มีประโยชน์เมื่อต้องจัดการกับโค้ดขนาดใหญ่สำเร็จรูปทั้งหมดนี้<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> คำขอ http ฝั่งเซิร์ฟเวอร์</a></h2><p>มีงานอื่นที่จัดการคำขอ http ทั้งหมด (เพื่อดึงรูปภาพ สคริปต์ ฯลฯ) จากฝั่งเซิร์ฟเวอร์ของเว็บ เราใช้ chronos httpclient:<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>ฉันต้องเพิ่ม<a href=https://github.com/untoreh/nim-chronos/tree/update> รองรับพร็อกซี https และถุงเท้า 5</a> httpclient เพื่อให้สามารถใช้การแปลได้อย่างมีประสิทธิภาพ<h1 id=config><a class=header-anchor href=#config> กำหนดค่า</a></h1><p>คุณอาจสังเกตเห็นตัวแปรตัวพิมพ์ใหญ่ตลอดทั้งโค้ด ทั้งหมดนี้เป็นตัวแปร config ที่กำหนดไว้ในไฟล์ ซึ่งสามารถปรับแต่งได้ในแต่ละเว็บไซต์<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> บทสรุป</a></h1><p>มีหลายอย่างที่ฉันยังไม่ได้กล่าวถึง เนื่องจากปีศาจอยู่ในรายละเอียด...อย่างไรก็ตาม นี่เป็นการทัวร์คร่าว ๆ ของรหัสฐานทั้งหมด ซึ่งรวมถึง:<ul><li><p>~12k เส้นนิม<li><p>~400 บรรทัดของ js<li><p>~ 1,000 บรรทัดของ scss<li><p>~ 3500 บรรทัดของหลาม<li><p>74 lines of rust (for bindings :P)</ul><p>ฉันจะทำอะไรแตกต่างออกไป?<ul><li><p>อาจเขียนใหม่ทั้งหมดด้วยสนิม ปัจจุบัน nim ไม่สามารถจัดการความปลอดภัยของหน่วยความจำได้อย่างดี และระยะเวลาที่ฉันต้องพึ่งพา gdb ในการแก้ไขข้อขัดข้องนั้นมากเกินไป และฉันยังไม่สามารถแก้ไขทั้งหมดได้ เป็นปัญหาใหญ่เมื่อระบบนิเวศครึ่งหนึ่งพึ่งพา GC และอีกครึ่งหนึ่งพึ่งพา ORC (หรือไม่ใช่แม้แต่ orc และเพียงแค่ ARC) การผสม async และ thread นั้นเจ็บปวดเช่นกัน และ async stacktraces ก็เป็นฝันร้าย (แม้ว่าฉันจะไม่รู้ว่าสนิมจะดีกว่าไหมในเรื่องนี้)<li><p>เป้าหมาย ก<a href=https://en.wikipedia.org/wiki/Progressive_web_app> กปภ</a> จากการเดินทาง โครงการเริ่มต้นค่อนข้างลำบาก ในตอนแรกควรจะเป็นหน้าคงที่ที่ให้บริการโดยเว็บเซิร์ฟเวอร์ จากนั้นมันก็กลายเป็นเว็บเซิร์ฟเวอร์เอง การโต้ตอบเกิดขึ้นภายหลัง ดังนั้นมันจึงกลายเป็นเพียงการผสมกันของ html ที่แสดงผลบวกกับ js/css สิ่งนี้ทำให้ฉันหละหลวมกับ API ซึ่งออกมาโดยไม่มีโครงสร้างใดๆ เลย (สมบูรณ์<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> ไม่สงบ</a> ). ในการเขียนใหม่ฉันจะใช้ ui framework เช่นกัน<a href=https://preactjs.com/> เพรช</a> ซึ่งรองรับ AMP เต็มรูปแบบ หรือ<a href=https://www.solidjs.com/> ของแข็ง</a>.<li><p>เพิ่มตัวแยกเฉพาะกิจเพิ่มเติมสำหรับแพลตฟอร์มยอดนิยม การแยกวิเคราะห์บทความธรรมดาไม่ได้ผล (หรือไม่ได้เลย) เมื่อแพลตฟอร์มยอดนิยมในปัจจุบันมีเนื้อหาน้อยมากและมีวิดีโอและรูปภาพจำนวนมาก ดังนั้นการคัดลอกจึงต้องกำหนดเป้าหมายไปที่สื่อสมบูรณ์แทนข้อความเพียงอย่างเดียว หากไม่เป็นเช่นนั้น คิดเป็นสัดส่วนเมื่อวางแผนสถาปัตยกรรมมีดโกน เนื้อหาและข้อมูลที่แอปจะให้บริการจะไม่สมดุล</ul><div id=post-tags-list>โพสต์แท็ก: <span class=post-tag><a href=https://www.unto.re/tag/apps> แอพ</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> การเขียนโปรแกรม</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> ซอฟต์แวร์</a></span></div><div class=page-foot><div class=copyright>11 ธันวาคม 2565</div><script async crossorigin=anonymous issue-term=pathname label=Comment repo=untoreh/untoreh.github.io src=https://utteranc.es/client.js></script></div></div><div class=page__footer><footer><div class=page__footer-copyright>© notreh - ขับเคลื่อนโดย<a href=https://github.com/tlienart/Franklin.jl> แฟรงคลิน</a></div><div class=page__footer-links>- <ul><li><a href=/th/sitemapxml> แผนผังเว็บไซต์</a></li> | <li><a href=/th/tag> แท็ก</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> RSS</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></footer></div><script crossorigin=anonymous defer id=fa integrity=sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH src=https://use.fontawesome.com/releases/v5.8.2/js/all.js></script><script src=/libs/colors.js></script><script src=/libs/menu.js></script><script defer src=/libs/lunr/lunr.min.js></script>