<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"lang=ro><meta charset=UTF-8><meta content=width=device-width,initial-scale=1 name=viewport><link href=https://www.unto.re/ro/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link title="site-ul lui untoreh"href=https://www.unto.re/feed.xml rel=alternate type=application/rss+xml><link href=https://www.unto.re/amp/ro/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2022,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><link href=/libs/highlight/github.min.css rel=stylesheet><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><link href=/css/bundle.css media=print onload=this.onload=null;this.removeAttribute('media'); rel=stylesheet><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> Construirea unui agregator de conținut pentru distracție și profit?</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/ro/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/ro/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2022-12-15T18:50:36.442","inLanguage":"ro","name":"","mainEntityOfPage":{"@id":"/ro/posts/Content-Aggregator/","@type":"Article"}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/ro/></a><div class=author__wrap><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><ul><li class=author__avatar onclick=toggleTheme()><img alt=" untoreh-light"class=flip-front src=/assets/appa.webp><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="Căutați pe site"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ro/posts/><i class="fas fa-pen menu-icons"></i> postări</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ro/media/><i class="fas fa-tv menu-icons"></i> mass-media</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div><button name="Website Menu"class=ham type=button><i class="fas fa-bars ham-icon"></i></button><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="Căutați pe site"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ro/posts/><i class="fas fa-pen menu-icons"></i> postări</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ro/media/><i class="fas fa-tv menu-icons"></i> mass-media</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div></nav></div></div></div><div><h1 id=title><a href=/ro/posts/Content-Aggregator> Construirea unui agregator de conținut pentru distracție și profit?</a></h1><blockquote id=page-description style=font-style:italic>O aplicație completă care răzuiește, procesează și prezintă conținut de pe web... pe web.</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> De ce?</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> Supraîncărcare informațională</a> ? Este cam rău în zilele noastre, o mulțime de surse de informații semnal-zgomot scăzute, restrângerea „feedurilor” astfel încât să nu fii copleșit este cam greu. Un instrument care filtrează informațiile și le prezintă într-un format ușor și rapid de digerat ar fi foarte util. Acesta este motivul pentru care consider<em> agregare de conținut</em> un câmp veșnic verde pentru perturbări. Este și va fi întotdeauna (atâta timp cât internetul este liber și există libertate de exprimare) o bună oportunitate de afaceri. Este una dintre acele cazuri în care este totul despre execuție (și deloc despre idee).<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> Gestionarea așteptărilor</a></h1><p>Acestea fiind spuse, aplicația mea în cele din urmă nu face nicio filtrare reală. De fapt, pur și simplu<em> agregate</em> conținut de pe web. Acest lucru se datorează faptului că nu am creat utilizatori în el și există puține stimulente pentru a face filtrare dacă nu poate fi adaptată pentru fiecare utilizator.<h1 id=the_architecture><a class=header-anchor href=#the_architecture> Arhitectura</a></h1><p>Diagrama arhitecturii:<img alt=" diagramă-agregator-conținut"src=/assets/posts/img/content-aggregator-diagram.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block>Sunt într-adevăr multe cercuri în el!...știi...micro...servicii? Aplicațiile pe care le-am construit sunt „scraper” și „server”, în timp ce „publisher” este doar o rutină încorporată în server. „Căutarea” și „proxy-urile” sunt instrumente externe care își fac treaba. „Frontend” nu este nimic special, un amestec de js și css la pachet cu webpack.<p>Deoarece există diferite părți în mișcare, voi merge în funcție de fluxul conținutului, începând de când conținutul este văzut pentru prima dată.<h1 id=the_scraper><a class=header-anchor href=#the_scraper> Screperul</a></h1><p>Razuirea se face în... ai ghicit, python. Cu toate acestea, nu sunt utilizate module ad-hoc de „răzuire”.<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> Ce răzuiești?</a></h2><p>A decide ce să răzuiești depinde de categoria conținutului. Numim categoriile „subiecte”.<ul><li><p>Fiecare subiect are o listă de cuvinte cheie.<li><p>Lista de cuvinte cheie, dacă sunt extrase din google adwords folosindu-le<a href=https://github.com/googleads/google-ads-python> python api</a><li><p>Cuvintele cheie sunt interogate pe mai multe motoare de căutare, periodic, într-o ordine rotundă. Dacă instanța are mai multe subiecte, subiectele cu conținut mai puțin disponibil sunt căutate mai întâi. Pentru efectuarea căutărilor pe care ne bazăm<a href=https://github.com/searxng/searxng> searx</a> cu proxy. Searx nu este tocmai prietenos cu bibliotecile, deoarece utilizarea sa principală este pentru frontend-ul său, așa că a necesitat să parcurgeți procesul corect pentru a inițializa modulul pentru a efectua interogări. Pentru a accelera lucrurile cu utilizarea threadpool-ului pentru a efectua mai multe interogări simultan, vom folosi threadpool-ul frecvent pe tot parcursul proiectului.<li><p>Fiecare căutare de cuvinte cheie generează o listă de surse potențiale de conținut (rezultatele motoarele de căutare) care sunt salvate în stocare pentru procesare ulterioară.<li><p>Când dorim să găsim conținut nou pentru un anumit subiect verificăm mai întâi dacă există surse disponibile, altfel generăm surse noi din lista de cuvinte cheie.<img alt=" continut-pipeline"src=/assets/posts/img/content-pipeline.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block><li><p>Sursele sunt procesate prin două biblioteci<a href=https://github.com/adbar/trafilatura> trafilatura</a> este cel principal, dacă nu reușește, facem backup la<a href=https://github.com/goose3/goose3> gâscă</a> . De asemenea, încercăm să găsim fluxuri pentru link-uri suplimentare (care ar fi considerate surse noi). Pentru furajele pe care le folosim<a href=https://github.com/dfm/feedfinder2> feedfinder</a> ci o simplă analiză a html pentru rss<code>link</code> etichetele ar fi de asemenea suficiente.<li><p>Tipul nostru principal de conținut este an<code>Article</code> , care din partea python este doar un dict, din partea nim cu parse-l ca obiect. Chei:<ul><li><p><code>title</code> : antetul articolului<li><p><code>content</code> : articolul în sine. Pentru a determina care este un articol bun, parcurgem diferiți pași de filtrare:<ul><li><p>Mai întâi verificăm dacă fie trafilatura, fie gâsca au text și dacă este suficient de lung. Dimensiunea noastră minimă este de 300 de cuvinte. Dacă dimensiunea nu este potrivită, aruncăm sursa (nu returnăm nimic).<li><p>Apoi luăm titlul și îl dezinfectăm eliminând adresele URL și spațiile albe<li><p>Dacă limba este străină, o traducem înapoi în engleză (normalizăm peste engleză) atât conținutul, cât și titlul.<li><p>În acest moment, verificăm utilizarea blasfei<a href=https://github.com/dimitrismistriotis/alt-profanity-check> blasfemie_verificare</a> . Nu că verificarea limbajului vulgar este în limba engleză bazată pe traducerea anterioară. Altfel am avea nevoie de un model de blasfemie pentru toate limbile.<li><p>După ce am înlocuit cuvintele proaste folosind filtrul de blasfemie, continuăm să igienizăm conținutul. Verificăm dacă articolul este relevant. Regulile pe care le folosim sunt:<ul><li><p>Conținutul trebuie să înceapă cu caractere alfanumerice, altfel există o schimbare mare că este gunoi.<li><p>Atât titlul, cât și conținutul nu pot fi „zgomot”. Zgomotul este definit de o expresie regex care captează cuvinte cheie precum „login”, „înscriere”, „acces refuzat”... etc.<li><p>Cel puțin un cuvânt din titlu trebuie să fie prezent în corp. În caz contrar, este posibil ca analizarea să aleagă părțile greșite ale paginii sursă pentru conținut.</ul><li><p>Dacă testele de relevanță au trecut, ca pas final curățăm conținutul de apariția prea multor paranteze, spații albe, caractere repetate și caractere speciale.<li><p>Dacă curățarea nu a șters totul, continuăm procesarea articolului.</ul><li><p><code>source</code> : linkul care indică sursa originală pe care am analizat-o<li><p><code>lang</code> : limbajul articolului, îl folosim<a href=https://github.com/pemistahl/lingua-py> limba</a> pentru a detecta limba<li><p><code>desc</code> : rezumatul, altfel un extras din continut<li><p><code>author</code> : autorul, altfel titlul paginii de start a link-ului sursă<li><p><code>pubDate</code> : data publicării articolului, sau acum<li><p><code>topic</code> : subiectul căruia îi aparține acest articol<li><p><code>tags</code> : cuvinte cheie relevante pentru un articol, folosim cea mai rapidă libră de extracție kw, adică<a href=https://github.com/csurfer/rake-nltk> grebla</a> , alternativele luate în considerare sunt<a href=https://github.com/kevinlu1248/pyate> pyate</a> (combobazic),<a href=https://github.com/DerwenAI/pytextrank> rang de text</a> și<a href=https://github.com/slanglab/phrasemachine> mașină de fraze</a><li><p><code>imageTitle</code> : textul alternativ pentru imagine<li><p><code>imageOrigin</code> : dacă parsare sursă (pentru imaginile pe care le folosim<a href=https://github.com/michaelhelmick/lassie> fata</a> ) nu a găsit o imagine, interogăm motoarele de căutare pentru o imagine relevantă, așa că imageOrigin indică pagina originală care a găzduit imaginea, altfel este egală cu adresa URL sursă.<li><p><code>imageUrl</code> : legătura reală către imagine. Folosim o verificare a filtrului de înflorire pentru imagini duplicate, deoarece nu ne plac duplicatele.<li><p><code>icon</code> : favicon-ul link-ului sursă</ul><li><p>După ce am procesat un cuvânt cheie, îi salvăm articolele găsite și se alimentează pe stocare. Ele vor fi folosite de către editor.</ul><p>Scrapingul se întâmplă continuu, este un demon. Pseudocodul buclei principale arată astfel și este configurat<em> pe site</em>:<ul><li><p>sincronizați proxy-urile pentru totdeauna<li><p>pentru fiecare subiect sortat după număr nepublicat (articole) (de mic spre mare) procedați după cum urmează<ul><li><p>dacă a trecut intervalul minim de la ultima lucrare, rulați un job de analiză pentru subiect. Intervalul crește cu cât avem mai multe articole nepublicate pentru un subiect și este întotdeauna 0 dacă nu avem articole nepublicate.<li><p>Faceți același lucru, dar pentru feeduri (pe care le-am colectat din surse, dacă avem)<li><p>Dacă site-ul este menit să creeze subiecte noi, creați unul. (Acest lucru are sens numai dacă nu decideți lista de subiecte la crearea site-ului.)<li><p>Alegeți un articol dintre cele publicate și trimiteți un tweet (trimitem 3 tweet-uri pe zi, folosind<a href=https://github.com/bear/python-twitter> python-twitter</a>)<li><p>Alegeți un articol dintre cele publicate și actualizați o pagină de facebook (facem 1 actualizare pe zi, folosind<a href=https://github.com/jgorset/facepy> facepy</a>)</ul><p>(Ne-am conectat și reddit, dar reddit nu permite postarea încrucișată, așa că a fost un efort irosit.)</ul><h1 id=publishing><a class=header-anchor href=#publishing> Publicare</a></h1><p>Odată ce avem conținut de publicat, trebuie să decidem ce să publicăm și cât de des. Nu am venit cu niciun truc aici, pentru că, așa cum am menționat anterior, alegerea a ceea ce să afișeze depinde de utilizator. Deci publicăm doar din<em> de la cel mai nou la cel mai vechi</em> , cu raționamentul că ceva ce am răzuit mai recent este mai relevant, este a<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> LIFO</a> coadă. Publicarea, deși se bazează destul de mult pe instrumentele python, se întâmplă în nim, deoarece rulează adiacent serverului, care este tot în nim.<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> Logica publicării</a></h2><p>Publicarea are loc continuu și, așa cum scrapingul are intervale inactive, publicarea are loc, în sens invers față de scraping. Când răzuim, încetinim când avem o<em> destul de mult</em> cache de articole nepublicate, cu publicarea încetinim atunci când memoria cache începe să se micșoreze prea mult. În acest fel, împreună cu răzuirea, ar trebui să existe întotdeauna<em> ceva conținut</em> a fi publicat<em> ceva timp</em> în viitor. Logica reală de publicare:<ul><li><p>Preluați un lot de articole nepublicate din cache. (Alegăm să publicăm 3 articole noi per cursă.)<li><p>Verificați dacă sunt duplicate. Verificarea dup-ului se face prin hashing sensibil la localitate, utilizând o libră nim,<a href=https://github.com/Nim-NLP/minhash/> minhash</a> . LSH consumă destul de mult CPU (știi... hashing) și necesită propriul său fir de execuție (mai sunt câteva sarcini pe care le gestionăm care necesită propriile fire de execuție).<li><p>Redarea paginii: aceasta nu este necesară, deoarece serverul gestionează interogările din mers, dar redarea aici este o formă de pre-caching.<li><p>Manipularea paginilor. Deoarece avem de-a face cu un site, trebuie să alegem câte articole să afișam pe pagină și să creștem paginile pe măsură ce publicăm mai multe articole. Alegem să grupăm articolele în pagini de ~10. Ultima pagină are întotdeauna mai puțin de 10 articole.<li><p>Salvați starea articolelor publicate, aceasta înseamnă mutarea articolelor de la starea „nepublicat” la „publicat” și baza de date LSH.<li><p>După publicarea articolelor noi, trebuie să ștergem memoria cache învechită. Trebuie să ștergem pagina de pornire, pagina de subiect și harta site-ului și fluxul rss.</ul><h1 id=serving><a class=header-anchor href=#serving> Servire</a></h1><p>Configuram locuri de muncă atât pentru a răzui un conținut de publicare, tot ce a mai rămas este să-l difuzăm.<h2 id=the_web_server><a class=header-anchor href=#the_web_server> Serverul web</a></h2><p>Dupa ce am avut<a href=https://github.com/dom96/jester> încercat</a><a href=https://github.com/dom96/httpbeast> diferit</a><a href=https://github.com/olliNiinivaara/GuildenStern/> web</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> servere</a>, din cauza diferitelor bug-uri cu care m-am rezolvat<a href=https://github.com/bung87/scorper> scorper</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> Gestionarea unei cereri</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> Routerul</a></h3><p>Folosim nim<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> implementarea potrivirii modelelor</a> pentru a se potrivi cu un tuplu de capturi regex. Aceasta este expresia regex care nu este deloc RESTful:<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> arată toate nodurile posibile pe care le poate avea o cale. Apoi ruta noastră arată astfel:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>Nu este frumos, dar faptul că nu mă bazez pe vreun router anume mi-a permis să schimb serverul web fără prea multă agitație atunci când testez. Este performant? Neclar! Nu am făcut niciun benchmark comparându-l cu altceva. Totuși, ceea ce miroase este regex-ul care poate avea erori și faptul că ordinea cazurilor contează.<blockquote><p>Așteptaţi un minut...</blockquote><p>Există o grămadă de lucruri pe care le facem la fiecare solicitare înainte de rutarea reală a paginii:<p>inițial am configurat codul de curățare (cu<code>defer:</code> ) care<em> ar trebui să</em> asigurați-vă că nu apar scurgeri.<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>Verificăm dacă firul este inițializat:<pre><code class="nim hljs">initThread()</code></pre><p>Acest lucru ar trebui să ruleze într-adevăr o singură dată (se setează un bool global după inițializare pentru a verifica) și ar putea fi făcut în afara handler-ului de cereri. Dar ce este de fapt initializat? Ei bine... destul de multe lucruri! Practic, folosim constante globale care necesită inițializare, de asemenea, unele dintre acestea nu sunt cu adevărat legate de fire, deoarece inițializează memoria în heap și sunt partajate între fire.<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>Apoi analizăm parametrii<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>La ce folosim parametrii? The<code>ParamKey</code> tipul enum îl descrie:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>Noi facem<em> microcaching</em> pentru cereri, astfel încât fiecare cerere este stocată în cache în funcție de tuplu<code>(path, query, accetEncoding)</code> , codificarea este necesară deoarece putem servi ambele corpuri (ne)comprimate. Un context de solicitare arată astfel:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>The<code>key</code> câmpul este folosit pentru a prelua pagina corectă din cache (corpul) din<code>pageCache</code>. Blocarea este necesară pentru a se asigura că solicitările multiple care apar în același timp nu dublează lucrările de randare (dacă o altă solicitare generează deja pagina, așteptați să se termine). Fiecare bază<code>HttpRequestRef</code> din chronos httpserver este stocat în<code>rq</code> camp. The<code>params</code> sunt deja analizate din cele precedente<code>handleParams</code>.<li><p>Acceptăm ștergerea conținutului prin intermediul<code>d</code> param, care ne permite să nuke articolele (în cazul în care filtrarea a eșuat, dar nu ar trebui să fie folosit niciodată în practică, doar pentru depanare) cu o simplă solicitare http get. Cine are nevoie de alte metode http? Nu eu.<li><p>Acceptăm și ștergerea memoriei cache. Putem fie să ștergem pagina,<code>c=0</code> sau toate paginile<code>c=1</code> . Partea enervantă este că trebuie să verificăm dacă calea este fie un articol, o pagină, o imagine sau un activ și să curățăm structura cache-ului corespunzătoare. Există o dublare logică evidentă aici cu routerul, dar deoarece aceasta se face înainte de rutare, trebuie să fie ad-hoc, gestionând doar cazurile relevante pentru curățarea cache-ului. Se face pre-routare deoarece, de asemenea, cache-ul este servit fără rutare, deoarece dacă cererea a fost deja generată, putem doar să răspundem cu corpul stocat în<code>respBody</code> câmp (și<code>respHeaders</code>, <code>respCode</code>).<li><p>După gestionarea operațiunilor de cache, analizăm calea.<li><p>După aceasta, are loc o altă deturnare:</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>De ce se face acest lucru și înainte de rutare? În mod implicit, oferim pagini traduse parțial. Suntem săraci :( iar traducerile se bazează pe servicii gratuite, dar nu ne putem permite timpi de încărcare grozavi, așa că rulăm traducerea amânată în timp ce difuzăm pagina tradusă numai cu fragmente care au fost stocate în cache în baza noastră de traduceri.<p>În acest moment există rutarea, cuprinsă într-o excepție, astfel încât, dacă difuzarea paginii corecte eșuează, emitem un<code>503</code> . Emiterea a<code>503</code> implică faptul că am încercat să direcționăm o adresă URL validă, dar nu am putut genera o pagină. Pentru adresele URL nevalide emitem a<code>301</code> redirecționare care implică faptul că adresa URL nu este validă. Servim 11 tipuri diferite de adrese URL:<ul><li><p>pagina principală: trage articole din cele mai recente subiecte, pseudoaleatoriu, nu facem nicio sortare în funcție de popularitate.<li><p>active generice (sub<code>/assets/</code> cale): sunt mapate direct la un director dedicat<li><p>imagini generice (sub<code>/i/</code> pah): proxy imaginile externe pentru a genera dimensiuni care se potrivesc site-ului nostru receptiv, atunci când imaginile nu sunt disponibile fie un pixel transparent, fie o pictogramă de imagine este servită implicit.<li><p>fișierul robots.txt<li><p>hărți de site (pentru pagina de pornire și subiecte și pagini): pagina de pornire găzduiește sitemapindexul care indică toate subiectele sitemap-uri, subiectele sitemap-uri indică toate paginile subiectului, paginile sitemap indică toate articolele paginii.<li><p>manifest pwa: manifestul pwa ar trebui să permită instalarea site-ului web ca pwa (dar, sincer, nu am testat acest lucru)<li><p>căutări: căutarea folosește<a href=https://github.com/valeriansaliou/sonic> sonic</a> cu<a href=https://github.com/alongwy/pysonic> pisonic</a> legături.<li><p>sugestii: sugestiile sunt, de asemenea, gestionate prin biblioteci sonice. Dar ei cer<li><p>fluxuri: ca și hărțile de site, avem fluxuri diferite pentru pagina de pornire și pentru diferite subiecte, deși nu există fluxuri pentru pagini singulare din motive evidente.<li><p>pagini de subiecte: pagina dedicată fiecărui subiect (de exemplu, cu calea<code>domain.com/my-topic/</code> ) Extrage cele mai recente articole publicate pentru subiect, care aparțin unui<em> neterminat</em> pagină.<li><p>pagini articole: Pagina articolului afișează titlul articolului, descrierea, linkul sursă, etichete, ora publicată (în subsol) iar în partea de jos tragem 3 articole conexe. Articolele asociate sunt preluate folosind o interogare de căutare pe titlul articolului sau etichete.</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> Despre randare</a></h2><p>Redarea paginii este procesată din partea nim folosind<a href=https://github.com/karaxnim/karax> karax</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> Aspect general de pagină</a></h3><p>Site-ul web este compus dintr-o bară fixă ​​de sus care arată:<ul><li><p>adresa URL a paginii de pornire, prin imaginea svg a siglei.<li><p>butonul pentru tema luminoasă/întunecată<li><p>URL curent folosind calea curentă<em> firimituri</em> ca text link<li><p>cele mai recente ~10 URL-uri de subiecte<li><p>Bara de căutare (cu butonul de căutare), unde se afișează sugestiile introduse<li><p>butonul de limbi, unde atunci când se face clic, lista de limbi plutește în sus</ul><p>Deoarece este un design receptiv, atunci când fereastra de vizualizare este mai mică, bara de sus ține doar caseta de căutare, în timp ce restul apare într-o bară laterală care poate fi comutată.<ul><li><p>Subsolul, care conține link-uri pentru harta site-ului, rss, rețele sociale, juridice<li><p>Sunt acceptate anunțuri în diferite locații</ul><h2 id=rss><a class=header-anchor href=#rss> RSS</a></h2><p>Aceasta este un exemplu de funcție, care arată ce facem când este publicată o nouă postare pentru a actualiza feedul:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> Sitemaps</a></h2><p>Acesta este nucleul adăugării de adrese URL la sitemap-urile:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> Șabloane</a></h2><p>Nu folosim un motor de șabloane, deoarece cea mai mare parte a randării se face cu karax, dar pentru pagini precum ToS folosim șabloane de fișiere, unde înlocuim doar o mulțime de variabile, cum ar fi un<code>envsubst</code> comanda.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> Pagini de articole</a></h2><p>Când redăm pagini precum home/subiecte și pagini numerotate, trebuie să arătăm o listă de articole, această funcție este apelată în buclă pentru câte articole vrem să arătăm:<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>Observați cum în unele rânduri „reclamele” se strecoară în X)<h2 id=topics_list><a class=header-anchor href=#topics_list> Lista de subiecte</a></h2><p>În bara de sus arătăm lista de subiecte, aceasta este ceea ce o imprimă:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>Există niște clase de design de materiale cu coduri urat mirositoare aici. Sincer, google componentele de design de materiale sunt naibii.<h2 id=post_footer><a class=header-anchor href=#post_footer> Subsolul postării</a></h2><p>Subsolul postării apare în dreapta jos a paginii unui articol (în litri) și imprimă doar data publicată.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> Extrase</a></h2><p>Când construim intrări în articole, este posibil să avem nevoie de extrase dacă nu este disponibil un rezumat.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>Wtf este<code>parseHtml</code> faci aici? Este cazul că permitem html în interiorul conținutului articolului (dar doar unele etichete), aceasta este o opțiune din modulul python trafilatura, pe care o menținem activată deoarece poate afecta formatul articolului. De asemenea, trebuie să fim atenți la tăierea șirurilor utf-8...<h2 id=minification><a class=header-anchor href=#minification> Minificare</a></h2><p>Ultima sarcină după ce am construit karax-ul<code>VNode</code> arborele este de a arunca octeții. Arborele dacă este prefixat cu antetul html și, opțional, este minimizat.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>De minificare se ocupă<a href=https://github.com/wilsonzlin/minify-html> minify-html</a> pe care le-am legat folosind<a href=https://github.com/nim-lang/c2nim> c2nim</a> , fișierul de legare conține:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>Dar pentru construire trebuie să furnizăm bibliotecile statice, adăugând această linie în nostru<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>Adică... asta e calea mea în care am construit biblioteca minify care<em> btw</em> nu are de fapt o funcție extern c pe care nim o poate consuma, așa că a trebuit să o scriem noi înșine.<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> Nimpy și căutarea pentru ștergerea gunoiului fără accidente</a></h1><p><a href=https://github.com/yglukhov/nimpy/> Legături Python pentru nim</a> trebuie să aruncați gratuit obiectele Python. Problema este că trebuie să controlăm când nim face GC. Biblioteca nimpy presupune că GIL este întotdeauna blocat (îl blochează la început), iar acesta este liber să apeleze la python oricând. Dar deblochăm gil-ul pentru a permite unui grup de fire python să ruleze cod în timp ce nim rulează alte lucruri. Dacă python-ul GIL a fost întotdeauna blocat de nim, grupul de fire ar fi inactiv de cele mai multe ori.<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>Acest lucru vă permite să executați codul Python care deține GIL, dar numai pe firul curent. Implementarea pentru achiziționarea/eliberarea GIL pe diferite fire de execuție nim necesită apelarea diferitelor funcții python C abi, deoarece GIL este un mutex. Apoi apelăm python folosind acest șablon:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>Folosim funcția nim locks and guards, pentru a ne asigura că tipurile Python sunt accesate numai atunci când GIL este ținut. Cu toate acestea, acest lucru necesită definirea piobiectelor cu garda:<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>Deci pot face:<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>Și ori de câte ori sun<code>myVar</code> care deține obiectul datetime, trebuie să-l împachetez astfel:<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>Acum putem bloca gil-ul când trebuie să rulăm GC, depășind nimpiul<code>PyObject</code> destructor cu asta:<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>Lacătul pe care îl folosim în interiorul destructorului nu este un<code>AsyncLock</code> pentru că ar fi prea scump, iar noi<em> nu</em> încuie întotdeauna, deoarece asta ar cauza blocaje! Dacă nu putem bloca gil-ul, întârziem colectarea și păstrăm indicatorul python brut în jur pentru când îl vom putea șterge. Sincer, nu știu dacă acest lucru cauzează alte forme de probleme, dar se pare că funcționează<em> destul de bine</em>.<p>Avem un modul nim numit<code>pyutils.nim</code> care face o grămadă de lucruri nim<>python, de exemplu:<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>Acesta este folosit destul de mult:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>Acesta este folosit atunci când am programat un job python și vrem să așteptăm ca acesta să se termine asincron:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>Legarea python asincronă corectă ar necesita finalizarea unui viitor asincron nim de la python la sfârșitul jobului programat python, ceea ce nu facem pentru că nu ne-am uitat suficient de adânc în manipularea obiectelor nim din python.<h2 id=ampification><a class=header-anchor href=#ampification> Amplificare</a></h2><p>Acceptăm Google amp, așa că generăm pagini de amp oarecum conforme cu amp. Nu ne propunem suport 1:1. De fapt, distrugem toate JavaScript-urile pe care le avem și servim doar html/css. Chiar și atunci trebuie să avem grijă să nu adăugăm atribute personalizate la etichetele html sau doar etichete html personalizate, amp este rău așa... Pentru conversia automată a paginii amp ne ocupăm de<code>head</code> si<code>body</code> etichetați diferit.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>Toate stilurile sunt îmbinate într-un singur script inline, ceea ce se păstrează este<code>link</code> etichete care nu sunt style/jscript, cum ar fi lang. Etichete de script pentru<code>ldljson</code>, <code>meta</code> Etichete. Verbatim gestionează nodurile care sunt<em> literal</em> , trebuie să le convertim în<code>XmlNode</code> (ceea ce înseamnă analizare) și gestionați-l corect. Corpul procesului este similar, păstrăm unele etichete, eliminăm altele, redenumim altele:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>The<code>form</code> eticheta este înlocuită cu<code>amp-form</code> , amp are multe dintre aceste etichete...<p>Trebuie să ne asigurăm că stilurile inline sunt în lungimea corectă:<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>Generația noastră de amplificatoare nu acoperă specificațiile complete ale amplificatorului, dar funcționează pentru conținutul nostru (prin încercare și eroare :S).<h2 id=search><a class=header-anchor href=#search> Căutare</a></h2><p>Ori de câte ori este publicat un articol, acesta este ingerat în baza de date sonică, baza de date sonică se ocupă de „colecții”, „găleți” și „obiecte”; Definim o colecție ca un site web, astfel încât fiecare site web care dorește să implementeze agregatorul de conținut are propria sa colecție. Noi nu folosim<code>buckets</code> , deși am putea considera fiecare subiect o găleată care ar restrânge prea mult căutarea, astfel încât fiecare site are doar o găleată „implicit”, iar fiecare obiect al găleții este un articol (care poate fi de diferite subiecte).<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>Când împingem conținut în sonic, trebuie să împărțim datele în bucăți, lungime maximă care este cunoscută la conectare. Ingerarea datelor pare să fie greșită uneori, deoarece pare să nu poată gestiona anumite caractere. În cazul în care serverul sonic se defectează cumva, avem și o funcție de reingestare a întregului conținut:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> Traducere</a></h2><p>Traducerea este o poveste destul de dezordonată. Sunt la a 4-a implementare (!) a unui wrapper de traducere, după ce am scris în php, du-te și<a href=https://github.com/untoreh/Translator.jl> julia</a> , asta se scrie si in nim. Variantele php/go sunt puțin putrede în zilele noastre, în timp ce varianta julia este folosită activ pentru acest blog. Cu toate acestea, pentru a obține o întârziere scăzută pentru serverul web, modul în care este implementată traducerea în julia nu este potrivit pentru service în timp real (traduce fișiere statice), și oricum adăugarea julia ca dependență odată ce avem deja python ar fi prea mare. cerinţă.<p>Așa că a trebuit să implementez un nou modul de traducere în nim. De fapt, modulul inițial de traducere nim semăna foarte mult cu implementarea julia, unde traduceam fișiere statice<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . După aceea, când serverul web a început să se formeze, l-am schimbat pentru a traduce nodurile karax la cerere. Acest lucru permite traducerea fiecărei pagini web exact la timp pentru cerere.<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>Mai sus este bucla principală de iterație<code>translateIter</code>:<ul><li><p><code>getTforms</code> mapează funcțiile cu etichete html, permițând efectuarea de mutații de la caz la caz.<li><p><code>rewriteUrl</code> inserează calea limbii (de ex<code>/en/</code> ) în calea URL.<li><p><code>translateVbtm</code> gestionează nodurile textuale care necesită parsare.</ul><p>Traducerea se aplică tuturor nodurilor text și<code>alt</code> și<code>title</code> atribute.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Deoarece trebuie să traducem fiecare nod de text separat (altfel nu putem reda html-ul), fiecare traducere de nod este un job separat. Deoarece joburile pot interoga serviciile de traducere de pe net, acestea trebuie să fie făcute asincron. Facem împărțirea și îmbinarea interogărilor de traducere pentru a economisi apelurile API, dar elementele interne ale motorului de traducere nu sunt importante de știut. Singurul lucru de remarcat este că inițial foloseam un<a href=https://github.com/nidhaloff/deep-translator> înveliș de piton</a> (pe care îl folosesc în continuare pentru traducerea conținutului răzuit) deoarece învelișurile auto-gestionate pentru API-uri externe este o durere, dar apoi am trecut la serviciul de traducere google și yandex self-wrapped în nim, deoarece python devine un blocaj considerabil atunci când gestionează multe traduceri concurente.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>De fapt, inițial, agregatorul de conținut trebuia să genereze doar fișiere statice pentru<code>caddy</code> pentru a servi, dar din cauza cantității de pagini de generat (care este o matrice de n_lang(20) x amp(2) x pagină), redarea leneșă a fost opțiunea mai bună.</table><h2 id=stats><a class=header-anchor href=#stats> Statistici</a></h2><p>Paginile cu subiecte și articole sunt urmărite pentru numărul de accesări.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>Folosim periodic numărul de accesări pentru a curăța paginile cu un număr scăzut.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> Baze de date</a></h2><p>Folosim<code>libmdbx</code> prin<a href=https://github.com/snej/nimdbx> această lib</a> . Probabil este exagerat, iar folosirea leveldb ar fi fost suficientă. Avem un tip<code>LRUTrans</code> unde ideea inițială a fost de a configura baza de date ca cache LRU, dar a fost considerabil mai lent. Implementarea poate fi găsită<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> Aici</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>Acest tip este utilizat pentru patru baze de date separate:<ul><li><p>traduceri<li><p>cache-ul paginii<li><p>memoria cache a imaginilor<li><p>statistici</ul><p>Tipul bazei de date este implementat cu getter și setter apoi efectuează de/compresie automată la citire/scriere. Din acest motiv nu ar trebui să fie folosit pentru imagini... dar vai... Există și o grămadă de micro cache-uri mici:<ul><li><p>vbtm: pentru conținut analizat (verbatim).<li><p>căutare: pentru interogări de căutare<li><p>fluxuri: pentru fluxuri de subiecte VNodes<li><p>rxcache: pentru regex, deoarece regex-urile statice de compilare nu sunt încă standardizate (și pentru că există mai multe biblioteci regex în nim)</ul><p>Acestea sunt implementate ca<a href=https://github.com/jackhftang/lrucache.nim> lru caches</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> , mai precis ca cache-uri lru „blocate”, în care fiecare operație de obținere și setare este înfășurată în jurul unui (thread)lock. Aceste blocări nu pot cauza blocări cu timpul de execuție asincron, deoarece blocarea este achiziționată și eliberată fără nicio declarație de randament, deci sunt atomice în acest sens, totuși sunt încă utile, deoarece folosim fire de execuție pentru diferite sarcini.<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>in orice caz<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> nim tocană</a> are o implementare mai simplă pentru lru cache pe care aș fi folosit-o dacă ar fi găsit mai devreme.</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> Lucrări de fundal</a></h1><p>Câteva sarcini pe care le folosim sunt înfometate de procesor, așa că folosim un fir diferit pentru ele:<ul><li><p>lsh: hashingul sensibil la localitate face o mulțime de calcule<li><p>imagini: redimensionarea imaginilor necesită decodarea/codificarea imaginilor, deci este costisitoare</ul><p>Încă două fire sunt folosite pentru a actualiza lista de fișiere cu materiale și reclamele, deși nu sunt înfometate de CPU, este necesar un fir pentru a evita blocajele cauzate de monitorul fișierelor.<p>Avem și sarcini asincrone de lungă durată pentru:<ul><li><p>traduceri<li><p>solicitări http</ul><p>Joburile Lsh, imagini, traduceri și solicitări http sunt gestionate folosind o configurație de producător/consumator. Cu excepția faptului că nu folosim canale, deoarece canalele se blochează și nu avem o implementare asincronă a acestora care să fie și threadsafe. Am folosit o implementare asincronă a<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> acest</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . Și un tabel asincron, care este ca un autobuz de evenimente<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>Serverul nim gestionează, de asemenea, trei sarcini asincrone:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>Sarcina care monitorizează utilizarea mem-ului este plăcut să existe, pentru a evita problemele OOM între procesul containerizat și docker, deoarece docker (sau kernel-ul) nu oprește imediat procesul și, în această perioadă de timp, serverul poate deveni fără răspuns, deci este mai bine să reporniți manual imediat.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>deși includerea unui canal simplu în rutine asincrone este probabil mai bună... vai</table><h1 id=images><a class=header-anchor href=#images> Imagini</a></h1><p>Facem pârghie<a href=https://github.com/imazen/imageflow/releases> fluxul de imagini</a> pentru a redimensiona și a stoca în cache imaginile local. Legăturile sunt simple, dar procesul este puțin complicat. Cu<code>getImg</code> preluăm datele imaginii de la adresa URL la distanță:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>Apoi trebuie să-l adăugăm la un context de flux de imagini:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Dacă imaginea nu poate fi adăugată, înseamnă că imageflow nu a recunoscut datele ca imagine validă. După ce am trimis datele, trebuie să trimitem o interogare în context, apoi să citim răspunsul și să obținem rezultatul:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>Primim tipul mime din răspuns, care va fi transmis în răspunsul serverului web. Din partea serverului, traducerea de la calea URL la fluxul de imagini este gestionată astfel:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>Url-ul imaginii este trimis ca parametri, în formă comprimată zstd. Compresia scurtează adresele URL (de cele mai multe ori). Acesta este, de asemenea, modul în care am găsit o eroare în Google Chrome, unde nu a putut gestiona adresele URL în care interogarea avea date comprimate codificate în URL. Firefox a fost bine în schimb.<h2 id=ld-json><a class=header-anchor href=#ld-json> LD-JSON</a></h2><p>Adăugăm la fiecare pagină web scripturi ldjson.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>Și pentru paginile traduse:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> Opengraph</a></h2><p>La fel ca ldjson, oferim și metaetichete opengraph:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>Macro-urile și șabloanele Nim sunt utile atunci când aveți de-a face cu tot acest cod greoi.<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> Cereri http pe partea serverului</a></h2><p>Există o altă sarcină, care se ocupă de toate solicitările http (pentru a prelua imagini, scripturi, etc) din partea serverului web. Folosim httpclientul chronos:<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>A trebuit să adaug<a href=https://github.com/untoreh/nim-chronos/tree/update> suport pentru proxy-uri https și socks5</a> către clientul http pentru a putea folosi traducerile în mod eficient.<h1 id=config><a class=header-anchor href=#config> Config</a></h1><p>S-ar putea să fi observat variabile cu majuscule în tot codul. Toate acestea sunt variabile de configurare, care sunt definite într-un fișier, care pot fi personalizate pe site.<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> Concluzie</a></h1><p>Există o grămadă de lucruri pe care nu le-am menționat, deoarece diavolul este în detalii... cu toate acestea, acesta este un tur aproximativ al întregii baze de cod care se ridică la:<ul><li><p>~12k linii de nim<li><p>~400 de linii de js<li><p>~1000 de linii de scss<li><p>~3500 de linii de piton<li><p>74 lines of rust (for bindings :P)</ul><p>Ce as face eu diferit?<ul><li><p>Probabil rescrie totul în rugină, nim în prezent nu se descurcă bine cu siguranța memoriei, iar timpul pe care a trebuit să mă bazez pe gdb pentru a remedia blocările a fost prea mult și nici nu am reușit să le repar pe toate. Este o mare problemă atunci când jumătate din ecosistem se bazează pe GC și cealaltă jumătate pe ORC (sau nici măcar pe orc și doar pe ARC). Amestecarea asincronă și a firelor este, de asemenea, dureroasă, iar stacktraces asincrone sunt un coșmar (deși nu știu dacă rugina este mai bună în acest sens.)<li><p>Țintă a<a href=https://en.wikipedia.org/wiki/Progressive_web_app> PWA</a> de la început. Proiectul a avut un început destul de supărător. La început trebuia să fie pagini statice servite de un server web, apoi a devenit un server web în sine. Interactivitatea a venit ca o idee ulterioară, așa că a devenit doar un amestec de html redate plus js/css. Acest lucru m-a făcut prea relaxat în ceea ce privește API-ul, care a ieșit fără nicio structură (complet<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> neliniştit</a> ). În rescriere, aș folosi un cadru ui<a href=https://preactjs.com/> predica</a> care are suport complet AMP, sau<a href=https://www.solidjs.com/> solidjs</a>.<li><p>Adăugați mai multe analizoare ad-hoc pentru platformele populare. Analiza simplă a articolelor nu funcționează prea bine (sau deloc) atunci când cele mai populare platforme din zilele noastre oferă foarte puțin conținut și o mulțime de videoclipuri și imagini, prin urmare, scrapingul trebuie să fie mai orientat spre media îmbogățită în loc de doar text, dacă nu este așa. luate în considerare la planificarea arhitecturii scraper, conținutul și informațiile pe care APP le va servi vor fi dezechilibrate.</ul><div id=post-tags-list>Post Tag-uri: <span class=post-tag><a href=https://www.unto.re/tag/apps> aplicații</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> programare</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> software</a></span></div><div class=page-foot><div class=copyright>11 decembrie 2022</div><script async crossorigin=anonymous issue-term=pathname label=Comment repo=untoreh/untoreh.github.io src=https://utteranc.es/client.js></script></div></div><div class=page__footer><footer><div class=page__footer-copyright>© untoreh - Dezvoltat de<a href=https://github.com/tlienart/Franklin.jl> Franklin</a></div><div class=page__footer-links>- <ul><li><a href=/ro/sitemapxml> Sitemap</a></li> | <li><a href=/ro/tag> Etichete</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> RSS</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></footer></div><script crossorigin=anonymous defer id=fa integrity=sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH src=https://use.fontawesome.com/releases/v5.8.2/js/all.js></script><script src=/libs/colors.js></script><script src=/libs/menu.js></script><script defer src=/libs/lunr/lunr.min.js></script>