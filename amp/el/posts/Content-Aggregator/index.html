<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"amp lang=el><script async src=https://cdn.ampproject.org/v0.js></script><meta charset=utf-8><meta content=width=device-width,minimum-scale=1,initial-scale=1 name=viewport><style amp-custom>.hljs{display:block;font-size:14px;line-height:1.45em;overflow-x:auto;padding:.5em;color:var(--text-color);background:var(--block-background)}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:var(--text-color);font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:var(--text-color);font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.franklin-content .row{display:block}.franklin-content .left{float:left;margin-right:15px}.franklin-content .right{float:right}.franklin-content .container img{width:auto;padding-left:0;border-radius:10px}.franklin-content .footnote{position:relative;top:-.5em;font-size:70%}.franklin-toc li{margin:.6rem 0}.franklin-content h1{font-size:24px}.franklin-content h3{font-size:20px}.franklin-content h1,h3,h4,h5,h6{text-align:left}.franklin-content h1{padding-bottom:.5em;border-bottom:3px double #d3d3d3;margin-top:1.5em;margin-bottom:1em}.franklin-content h1 a{color:inherit}.franklin-content h1 a:hover{text-decoration:none}.franklin-content h2 a:hover{text-decoration:none}.franklin-content h3 a{color:inherit}.franklin-content h3 a:hover{text-decoration:none}.franklin-content h4 a{color:inherit}.franklin-content h4 a:hover{text-decoration:none}.franklin-content h5 a{color:inherit}.franklin-content h5 a:hover{text-decoration:none}.franklin-content h6 a{color:inherit}.franklin-content h6 a:hover{text-decoration:none}.franklin-content table{margin-left:auto;margin-right:auto;border-collapse:collapse;text-align:center}.franklin-content table *{line-height:.75rem}.franklin-toc ol ol{list-style-type:lower-alpha}.franklin-content th,td{font-size:var(--small);padding:10px;border:1px solid #000}.franklin-content blockquote{background:var(--block-background);border-left:7px solid #a8a8a8;margin:1.5em 10px;padding:.5em 10px;font-style:italic}.franklin-content blockquote p{display:inline}.franklin-content li p{margin:10px 0}.franklin-content a:hover{text-decoration:underline}.franklin-content .bibref a,.franklin-content .eqref a{color:green}.franklin-content sup{font-size:70%;vertical-align:super;line-height:0}.franklin-content sup a.fnref,.franklin-content td.fndef-backref a{overflow:visible;display:initial;padding-bottom:.3rem;padding-top:.2rem}.franklin-content table.fndef{margin:0 0 10px}.franklin-content .fndef tr,td{padding:0;border:0;text-align:left}.franklin-content .fndef tr{border-left:2px solid #d3d3d3}.franklin-content .fndef td.fndef-backref{vertical-align:top;font-size:70%;padding-left:5px}.franklin-content .fndef td.fndef-content{font-size:80%;padding-left:10px;width:100%}.franklin-content img{width:70%;text-align:center;padding-left:10%}.franklin-content .img-small img{width:50%;text-align:center;padding-left:20%}.katex{font-size:1em}.katex-display .katex{display:inline-block;white-space:normal}.katex-display:after{counter-increment:eqnum;content:"(" counter(eqnum) ")";position:relative;float:right;padding-right:5px}code.plaintext{display:block}.scrollbox{width:10em;height:10em;overflow:auto;visibility:hidden}.scrollbox-content,.scrollbox:focus,.scrollbox:hover{visibility:visible}.scrollbox_delayed{transition:visibility .2s}.scrollbox_delayed:hover{transition:visibility 0s .2s}.hljs{font-size:var(--small);line-height:1.35em;border-radius:10px}.hljs-meta,.hljs-metap,.hljs-metas{font-weight:700}.hljs-meta{color:#19b333}.hljs-metas{color:red}.hljs-metap{color:#3383e7}.franklin-content .colbox-blue{background-color:#eef3f5;padding:5px 10px;margin-left:5px;margin-top:5px;margin-bottom:5px;border-radius:0 10px 10px 0;border-left:5px solid #4c9cf1}body.light{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--alt4:#ffbebe;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}body.dark{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}.author__place .author__bio{font-size:1rem}.franklin-content blockquote{border-left-color:var(--accent)}.franklin-content #title a{padding:.5rem;line-height:100%}.franklin-content img{width:auto;text-align:center;padding:0}.page__footer{margin-top:1rem;padding-top:1rem}.franklin-content .intro{font-size:1.2rem;text-align:left}.franklin-content .intro ul{list-style-type:none;font-size:1.1rem;font-style:italic}.franklin-content .intro a{font-variant:small-caps;padding-bottom:.2rem;font-size:1.4rem;font-style:normal}.franklin-content .intro .icon{padding:0 .2rem;font-size:1rem}.franklin-content .active-projects ul h4{font-size:1.5rem;font-variant:small-caps;font-style:normal;margin:.2rem}.franklin-content h3{font-size:.9rem}.posts_list h3{text-align:center}.svg-inline--fa.icon{width:1rem}.masthead__inner-wrap{display:block;width:100%;padding:10px 0;height:inherit}.author__name{display:none}.author__place{font-size:.65em}.page__footer ul>li{list-style-type:none}ul>li.author__urls a:hover{filter:drop-shadow(.1rem .1rem 0 var(--accent2)) brightness(1.5);filter:brightness(1.5);transition-property:-moz-filter,-ms-filter,-o-filter,filter;transition-duration:.2s}ul>li.author__place a{color:var(--accent3);text-decoration:none;text-shadow:0 0 .01rem var(--alt2)}.langs-dropdown-wrapper{cursor:pointer}.langs-dropdown-content.show{display:block}.lang-link .flag-icon{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu .lang-list{transition:height}#site-nav .langs-dropdown-menu .lang-link:hover{color:var(--foreground-color)}.page-foot{font-size:.7em;line-height:1.25em;text-align:right;display:inline-block;width:100%}.tag-content{padding-top:1rem}.author__bio li{list-style:none}.author__bio li p{margin:0;padding:0}#tag-name{font-size:1.5rem;padding:.5rem;font-weight:700;font-variant:small-caps}#tag_title{font-variant:small-caps}#tag_title .wrap{text-align:left}#tag_title>.wrap>*{display:inline-block;text-align:left}#tag_cloud{font-weight:700}.posts_list.franklin-content>ul{list-style-type:"> "}.posts_list.franklin-content>.title{font-variant:small-caps}.posts_list.franklin-content>.title>h2{font-size:1rem;font-style:italic}.posts_list.franklin-content>.title>a>h1,.posts_list.franklin-content>.title>h2{display:inline}.posts_list.franklin-content>ul>li{line-height:1.2rem;padding:.1rem}.posts_list.franklin-content>ul>li>p{padding:.1rem;margin:.1rem}.posts_list.franklin-content>.title,.posts_list.franklin-content>.title>h2{text-align:center;display:block;margin:1rem}.page__footer-links>ul>li>a{padding:.2rem;margin:.2rem}#tag_cloud>a{padding:.2rem;font-variant:small-caps;vertical-align:middle;margin:.3rem;display:inline-block;text-decoration:none;text-shadow:0 0 5rem #fff}#tag_cloud .icon{font-size:1rem;vertical-align:middle;margin-right:.2rem;margin-left:.2rem}#tag_cloud_wrapper{display:inline-block;width:100%;text-align:center}#post-tags-list{font-variant:small-caps;font-weight:700}.media{font-size:1.5rem;line-height:2rem}#library .book-author{color:var(--accent2);font-size:.9rem;display:inline}.shows_list h3{font-size:1.5rem}a.imdb{padding:0 .5rem}#searchResults ul li{margin-bottom:1rem}.lunrSearchForm .search-input:focus{background:var(--block-background)}.lunrSearchForm .search-button{cursor:pointer}.lunrSearchForm .search-button:focus{color:var(--accent)}.result-title a{text-decoration:none}.result-title a:hover{text-decoration:underline}.result-preview,.resultCount{color:gray}.result-query{font-weight:700}footer>*{float:left}footer a{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}footer ul.author__wrap>li{float:left;padding:0 .2rem}footer ul.author__wrap>li a{line-height:2rem;height:inherit;display:block}footer ul.author__wrap{float:right;margin:0}footer .page__footer-copyright{margin:0}footer .page__footer-links{margin:0 .2rem 0 .4rem}footer .page__footer-links ul{display:inline;margin:0 .4rem 0 0;padding:0}footer .page__footer-links li{display:inline}@media (min-width:680px){#tag-name,.tag-desc{text-align:left}}@media (min-width:680px) and (max-width:1300px){#site-nav .ham:hover{cursor:pointer}#site-nav .vert{transition:max-height .33s ease-in,filter .33s ease-in}}@media (max-width:680px){.masthead__inner-wrap{display:block}#tag-name,.tag-desc{text-align:center}.page__footer{width:100%;display:block}.page__footer{text-align:center}footer{display:inline-block;text-align:center}footer>*{display:inline-block;float:none}footer ul.author__wrap{float:none}footer .author__urls.social-icons{font-size:1rem}.page-foot .copyright{display:inline-block}}@media (max-width:680px){footer ul.author__wrap{margin-top:1rem;text-align:center;margin-left:0;padding-left:0}footer ul.author__wrap>li{float:none;display:inline-block}.page__footer{margin-top:3.5rem}}.site-title:after{-webkit-animation:chars 5.52s linear 1s forwards,cursor 1s 3;animation:chars 5.52s linear 1s forwards,cursor 1s 3}.hvr-buzz-out{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px #0000}.hvr-buzz-out:active,.hvr-buzz-out:focus,.hvr-buzz-out:hover{-webkit-animation-name:hvr-buzz-out;animation-name:hvr-buzz-out;-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-timing-function:linear;animation-timing-function:linear;-webkit-animation-iteration-count:1;animation-iteration-count:1}.franklin-content a:before{transition-property:left,right;transition-duration:.3s;transition-timing-function:ease-out}.franklin-content a:active:before,.franklin-content a:focus:before,.franklin-content a:hover:before{left:0;right:0}.hvr-outline-in:before{pointer-events:none;transition-duration:.2s;transition-property:top,right,bottom,left}.horiz .hvr-outline-in:active:before,.horiz .hvr-outline-in:focus:before,.horiz .hvr-outline-in:hover:before{top:-.5rem;right:-.5rem;bottom:-.5rem;left:0;opacity:1}.vert .hvr-outline-in:active:before,.vert .hvr-outline-in:focus:before,.vert .hvr-outline-in:hover:before{top:-.5rem;right:0;bottom:-.5rem;left:-.5rem;opacity:1}.masthead__menu ul li.author__avatar img{transition:transform .8s}.masthead__menu li.author__avatar:hover img{transform:rotateY(180deg);cursor:pointer}body.light .hljs{display:block;overflow-x:auto;padding:.5em;color:#000;background:#f8f8ff}body.light .hljs-comment,body.light .hljs-quote{color:#408080;font-style:italic}body.light .hljs-keyword,body.light .hljs-literal,body.light .hljs-selector-tag,body.light .hljs-subst{color:#954121}body.light .hljs-number{color:#40a070}body.light .hljs-doctag,body.light .hljs-string{color:#219161}body.light .hljs-section,body.light .hljs-selector-class,body.light .hljs-selector-id,body.light .hljs-type{color:#19469d}body.light .hljs-params{color:#00f}body.light .hljs-title{color:#458;font-weight:700}body.light .hljs-attribute,body.light .hljs-name,body.light .hljs-tag{color:navy;font-weight:400}body.light .hljs-template-variable,body.light .hljs-variable{color:teal}body.light .hljs-link,body.light .hljs-regexp{color:#b68}body.light .hljs-bullet,body.light .hljs-symbol{color:#990073}body.light .hljs-built_in,body.light .hljs-builtin-name{color:#0086b3}body.light .hljs-meta{color:#999;font-weight:700}body.light .hljs-deletion{background:#fdd}body.light .hljs-addition{background:#dfd}body.light .hljs-emphasis{font-style:italic}body.light .hljs-strong{font-weight:700}.flag.flag-gu{background-position:-96px -55px}.flag.flag-mn{background-position:-208px -88px}.flag.flag-va{background-position:-48px -154px}.flag.flag-tibet{background-position:-32px -143px}.flag.flag-fo{background-position:-64px -44px}.flag.flag-tl{background-position:-80px -143px}.flag.flag-kz{background-position:-144px -77px}.flag.flag-zm{background-position:-16px -165px}.flag.flag-uz{background-position:-32px -154px}.flag.flag-dk{background-position:-64px -33px}.flag.flag-scotland{background-position:-176px -121px}.flag.flag-gi{background-position:-224px -44px}.flag.flag-gy{background-position:-128px -55px}.flag.flag-bj{background-position:-112px -11px}.flag.flag-mo{background-position:-224px -88px}.flag.flag-ir{background-position:-112px -66px}.flag.flag-io{background-position:-80px -66px}.flag.flag-tm{background-position:-96px -143px}.flag.flag-ch{background-position:-96px -22px}.flag.flag-mt{background-position:-32px -99px}.flag.flag-gp{background-position:-16px -55px}.flag.flag-im{background-position:-48px -66px}.flag.flag-tv{background-position:-176px -143px}.flag.flag-mu{background-position:-48px -99px}.flag.flag-pe{background-position:-96px -110px}.flag.flag-vi{background-position:-112px -154px}.flag.flag-hn{background-position:-176px -55px}.flag.flag-ss{background-position:-128px -132px}.flag.flag-ae{background-position:-16px 0}.flag.flag-td{background-position:-240px -132px}.flag.flag-pw{background-position:0 -121px}.flag.flag-nu{background-position:-32px -110px}.flag.flag-bt{background-position:-208px -11px}.flag.flag-cv{background-position:-240px -22px}.flag.flag-mh{background-position:-144px -88px}.flag.flag-la{background-position:-160px -77px}.flag.flag-py{background-position:-16px -121px}.flag.flag-br{background-position:-176px -11px}.flag.flag-ye{background-position:-224px -154px}.flag.flag-ie{background-position:0 -66px}.flag.flag-gh{background-position:-208px -44px}.flag.flag-cg{background-position:-80px -22px}.flag.flag-cu{background-position:-224px -22px}.flag.flag-hu{background-position:-224px -55px}.flag.flag-sg{background-position:-224px -121px}.flag.flag-at{background-position:-176px 0}.flag.flag-lk{background-position:-224px -77px}.flag.flag-vu{background-position:-144px -154px}.flag.flag-bo{background-position:-160px -11px}.flag.flag-jo{background-position:-208px -66px}.flag.flag-er{background-position:-208px -33px}.flag.flag-rs{background-position:-80px -121px}.flag.flag-nr{background-position:-16px -110px}.flag.flag-ls{background-position:-256px -77px}.flag.flag-jm{background-position:-192px -66px}.flag.flag-tz{background-position:-208px -143px}.flag.flag-ki{background-position:-16px -77px}.flag.flag-sj{background-position:0 -132px}.flag.flag-cz{background-position:-16px -33px}.flag.flag-pg{background-position:-128px -110px}.flag.flag-lv{background-position:-32px -88px}.flag.flag-do{background-position:-96px -33px}.flag.flag-lu{background-position:-16px -88px}.flag.flag-no{background-position:-256px -99px}.flag.flag-kw{background-position:-112px -77px}.flag.flag-mx{background-position:-96px -99px}.flag.flag-yt{background-position:-240px -154px}.flag.flag-ly{background-position:-48px -88px}.flag.flag-cy{background-position:0 -33px}.flag.flag-my{background-position:-112px -99px}.flag.flag-sm{background-position:-48px -132px}.flag.flag-et{background-position:-240px -33px}.flag.flag-tj{background-position:-48px -143px}.flag.flag-ai{background-position:-64px 0}.flag.flag-kp{background-position:-64px -77px}.flag.flag-uy{background-position:-16px -154px}.flag.flag-gs{background-position:-64px -55px}.flag.flag-kurdistan{background-position:-96px -77px}.flag.flag-rw{background-position:-112px -121px}.flag.flag-ec{background-position:-128px -33px}.flag.flag-mm{background-position:-192px -88px}.flag.flag-pa{background-position:-80px -110px}.flag.flag-wales{background-position:-160px -154px}.flag.flag-kg{background-position:-256px -66px}.flag.flag-ve{background-position:-80px -154px}.flag.flag-tk{background-position:-64px -143px}.flag.flag-ca{background-position:-16px -22px}.flag.flag-is{background-position:-128px -66px}.flag.flag-ke{background-position:-240px -66px}.flag.flag-gq{background-position:-32px -55px}.flag.flag-tf{background-position:-256px -132px}.flag.flag-ad{background-position:0 0}.flag.flag-sk{background-position:-16px -132px}.flag.flag-pm{background-position:-192px -110px}.flag.flag-om{background-position:-64px -110px}.flag.flag-an{background-position:-112px 0}.flag.flag-ws{background-position:-192px -154px}.flag.flag-sh{background-position:-240px -121px}.flag.flag-mp{background-position:-240px -88px}.flag.flag-gt{background-position:-80px -55px}.flag.flag-cf{background-position:-64px -22px}.flag.flag-zanzibar{background-position:0 -165px}.flag.flag-mw{background-position:-80px -99px}.flag.flag-catalonia{background-position:-32px -22px}.flag.flag-ug{background-position:-240px -143px}.flag.flag-je{background-position:-176px -66px}.flag.flag-km{background-position:-32px -77px}.flag.flag-bf{background-position:-48px -11px}.flag.flag-mc{background-position:-80px -88px}.flag.flag-sy{background-position:-192px -132px}.flag.flag-sn{background-position:-64px -132px}.flag.flag-eu{background-position:-256px -33px}.flag.flag-bn{background-position:-144px -11px}.flag.flag-st{background-position:-144px -132px}.flag.flag-england{background-position:-192px -33px}.flag.flag-lc{background-position:-192px -77px}.flag.flag-dm{background-position:-80px -33px}.flag.flag-be{background-position:-32px -11px}.flag.flag-ni{background-position:-224px -99px}.flag.flag-mz{background-position:-128px -99px}.flag.flag-pf{background-position:-112px -110px}.flag.flag-tn{background-position:-112px -143px}.flag.flag-ee{background-position:-144px -33px}.flag.flag-xk{background-position:-208px -154px}.flag.flag-sx{background-position:-176px -132px}.flag.flag-sd{background-position:-192px -121px}.flag.flag-gd{background-position:-128px -44px}.flag.flag-ci{background-position:-112px -22px}.flag.flag-sz{background-position:-208px -132px}.flag.flag-cl{background-position:-144px -22px}.flag.flag-fi{background-position:0 -44px}.flag.flag-ga{background-position:-96px -44px}.flag.flag-np{background-position:0 -110px}.flag.flag-re{background-position:-48px -121px}.flag.flag-bg{background-position:-64px -11px}.flag.flag-sc{background-position:-160px -121px}.flag.flag-ng{background-position:-208px -99px}.flag.flag-qa{background-position:-32px -121px}.flag.flag-mk{background-position:-160px -88px}.flag.flag-aw{background-position:-208px 0}.flag.flag-kn{background-position:-48px -77px}.flag.flag-al{background-position:-80px 0}.flag.flag-bw{background-position:-240px -11px}.flag.flag-um{background-position:-256px -143px}.flag.flag-ky{background-position:-128px -77px}.flag.flag-tt{background-position:-160px -143px}.flag.flag-so{background-position:-80px -132px}.flag.flag-lt{background-position:0 -88px}.flag.flag-by{background-position:-256px -11px}.flag.flag-bb{background-position:0 -11px}.flag.flag-us{background-position:0 -154px}.flag.flag-md{background-position:-96px -88px}.flag.flag-ag{background-position:-48px 0}.flag.flag-hm{background-position:-160px -55px}.flag.flag-as{background-position:-160px 0}.flag.flag-eg{background-position:-160px -33px}.flag.flag-sv{background-position:-160px -132px}.flag.flag-sl{background-position:-32px -132px}.flag.flag-fk{background-position:-32px -44px}.flag.flag-am{background-position:-96px 0}.flag.flag-ck{background-position:-128px -22px}.flag.flag-tw{background-position:-192px -143px}.flag.flag-kh{background-position:0 -77px}.flag.flag-to{background-position:-128px -143px}.flag.flag-cd{background-position:-48px -22px}.flag.flag-pn{background-position:-208px -110px}.flag.flag-vc{background-position:-64px -154px}.flag.flag-somaliland{background-position:-96px -132px}.flag.flag-bi{background-position:-96px -11px}.flag.flag-pr{background-position:-224px -110px}.flag.flag-co{background-position:-192px -22px}.flag.flag-fm{background-position:-48px -44px}.flag.flag-bm{background-position:-128px -11px}.flag.flag-ar{background-position:-144px 0}.flag.flag-bv{background-position:-224px -11px}.flag.flag-sb{background-position:-144px -121px}.flag.flag-mq{background-position:-256px -88px}.flag.flag-eh{background-position:-176px -33px}.flag.flag-bh{background-position:-80px -11px}.flag.flag-hr{background-position:-192px -55px}.flag.flag-mv{background-position:-64px -99px}.flag.flag-mg{background-position:-128px -88px}.flag.flag-dz{background-position:-112px -33px}.flag.flag-gg{background-position:-192px -44px}.flag.flag-gm{background-position:-256px -44px}.flag.flag-af{background-position:-32px 0}.flag.flag-li{background-position:-208px -77px}.flag.flag-sr{background-position:-112px -132px}.flag.flag-vg{background-position:-96px -154px}.flag.flag-cr{background-position:-208px -22px}.flag.flag-tc{background-position:-224px -132px}.flag.flag-ao{background-position:-128px 0}.flag.flag-ma{background-position:-64px -88px}.flag.flag-mr{background-position:0 -99px}.flag.flag-gn{background-position:0 -55px}.flag.flag-ne{background-position:-176px -99px}.flag.flag-nf{background-position:-192px -99px}.flag.flag-wf{background-position:-176px -154px}.flag.flag-hk{background-position:-144px -55px}.flag.flag-gf{background-position:-160px -44px}.flag.flag-ps{background-position:-240px -110px}.flag.flag-ic{background-position:-240px -55px}.flag.flag-cw{background-position:-256px -22px}.flag.flag-ml{background-position:-176px -88px}.flag.flag-ax{background-position:-224px 0}.flag.flag-gl{background-position:-240px -44px}.flag.flag-dj{background-position:-48px -33px}.flag.flag-ht{background-position:-208px -55px}.flag.flag-lr{background-position:-240px -77px}.flag.flag-tg{background-position:0 -143px}.flag.flag-ba{background-position:-256px 0}.flag.flag-ge{background-position:-144px -44px}.flag.flag-bz{background-position:0 -22px}.flag.flag-au{background-position:-192px 0}.flag.flag-iq{background-position:-96px -66px}.flag.flag-cm{background-position:-160px -22px}.flag.flag-gw{background-position:-112px -55px}.flag.flag-az{background-position:-240px 0}.flag.flag-na{background-position:-144px -99px}.flag.flag-fj{background-position:-16px -44px}.flag.flag-zw{background-position:-32px -165px}.flag.flag-bs{background-position:-192px -11px}.flag.flag-il{background-position:-16px -66px}.flag.flag-nz{background-position:-48px -110px}.flag.flag-me{background-position:-112px -88px}.flag.flag-si{background-position:-256px -121px}.flag.flag-nc{background-position:-160px -99px}.flag.flag-lb{background-position:-176px -77px}</style><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><meta charset=UTF-8><link href=https://www.unto.re/el/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link title="ιστοσελίδα του untoreh"href=https://www.unto.re/feed.xml rel=alternate type=application/rss+xml><link href=https://www.unto.re/amp/el/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2023,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> Δημιουργία ενός συλλέκτη περιεχομένου για διασκέδαση και κέρδη;</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/el/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/el/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2023-05-22T16:50:05.291","inLanguage":"el","name":"","mainEntityOfPage":{"@id":"/el/posts/Content-Aggregator/","@type":"Article"}}</script><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/el/></a><div class=author__wrap><ul><li class=author__avatar><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/el/posts/><i class="fas fa-pen menu-icons"></i> αναρτήσεις</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/el/media/><i class="fas fa-tv menu-icons"></i> μεσο ΜΑΖΙΚΗΣ ΕΝΗΜΕΡΩΣΗΣ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"></ul></div><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/el/posts/><i class="fas fa-pen menu-icons"></i> αναρτήσεις</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/el/media/><i class="fas fa-tv menu-icons"></i> μεσο ΜΑΖΙΚΗΣ ΕΝΗΜΕΡΩΣΗΣ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"></ul></div></nav></div></div></div><div><h1 id=title><a href=/el/posts/Content-Aggregator> Δημιουργία ενός συλλέκτη περιεχομένου για διασκέδαση και κέρδη;</a></h1><blockquote id=page-description style=font-style:italic>Μια πλήρης εφαρμογή που ξύνει, επεξεργάζεται και παρουσιάζει περιεχόμενο από τον Ιστό...στον Ιστό.</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> Γιατί;</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> Πολλές πληροφορίες</a> ? Είναι κάπως άσχημο αυτές τις μέρες, το πολύ χαμηλό σήμα σε πηγές πληροφοριών θορύβου, το να περιορίσεις τις "τροφοδοσίες" σου έτσι ώστε να μην κατακλύζεσαι είναι κάπως δύσκολο. Ένα εργαλείο που φιλτράρει τις πληροφορίες και τις παρουσιάζει σε μορφή που είναι τόσο εύκολη όσο και γρήγορη στην αφομοίωση θα ήταν πολύ χρήσιμο. Αυτός είναι ο λόγος που θεωρώ<em> συγκέντρωση περιεχομένου</em> ένα καταπράσινο χωράφι για αναστάτωση. Είναι και θα είναι πάντα (όσο το διαδίκτυο είναι ελεύθερο και υπάρχει ελεύθερος λόγος) μια καλή επιχειρηματική ευκαιρία. Είναι από εκείνες τις περιπτώσεις όπου όλα είναι σχετικά με την εκτέλεση (και καθόλου με την ιδέα).<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> Διαχείριση προσδοκιών</a></h1><p>Τούτου λεχθέντος, η εφαρμογή μου τελικά δεν κάνει κανένα πραγματικό φιλτράρισμα. Στην πραγματικότητα είναι απλά<em> αδρανή</em> περιεχόμενο από τον Ιστό. Αυτό οφείλεται στο γεγονός ότι δεν δημιούργησα χρήστες σε αυτό και υπάρχει μικρό κίνητρο για το φιλτράρισμα εάν δεν μπορεί να προσαρμοστεί ανά χρήστη.<h1 id=the_architecture><a class=header-anchor href=#the_architecture> Η αρχιτεκτονική</a></h1><p>Το διάγραμμα της αρχιτεκτονικής:Υπάρχουν όντως πολλοί κύκλοι σε αυτό!...ξέρεις...μικρο...υπηρεσίες; Οι εφαρμογές που έφτιαξα είναι το "scraper" και ο "server", ενώ ο "publisher" είναι απλώς μια ρουτίνα ενσωματωμένη στον διακομιστή. Η «αναζήτηση» και οι «πληρεξούσιοι» είναι εξωτερικά εργαλεία που κάνουν τη δουλειά τους. Το "Frontend" δεν είναι τίποτα το ιδιαίτερο, ένας συνδυασμός js και css σε πακέτο με webpack.<p>Δεδομένου ότι υπάρχουν διαφορετικά κινούμενα μέρη, θα προχωρήσω σύμφωνα με τη ροή του περιεχομένου, ξεκινώντας από την πρώτη φορά που το περιεχόμενο εμφανίζεται.<h1 id=the_scraper><a class=header-anchor href=#the_scraper> Η Ξύστρα</a></h1><p>Η απόξεση γίνεται στο...μάντεψες, python. Ωστόσο, δεν χρησιμοποιούνται ad hoc ενότητες "απόξεσης".<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> Τι ξύνεις;</a></h2><p>Το να αποφασίσετε τι να ξύσετε εξαρτάται από την κατηγορία του περιεχομένου. Τις κατηγορίες τις ονομάζουμε «θέματα».<ul><li><p>Κάθε θέμα έχει μια λίστα με λέξεις-κλειδιά.<li><p>Ο κατάλογος των λέξεων-κλειδιών αν προκύψει από το google adwords χρησιμοποιώντας τους<a href=https://github.com/googleads/google-ads-python> python api</a><li><p>Οι λέξεις-κλειδιά ερωτώνται σε πολλαπλές μηχανές αναζήτησης, με σειρά περιοδικά. Εάν η παρουσία έχει πολλά θέματα, αναζητούνται πρώτα τα θέματα με λιγότερο διαθέσιμο περιεχόμενο. Για την εκτέλεση των αναζητήσεων στις οποίες βασιζόμαστε<a href=https://github.com/searxng/searxng> searx</a> με πληρεξούσιους. Το Searx δεν είναι ακριβώς φιλικό προς τη βιβλιοθήκη, δεδομένου ότι η κύρια χρήση του είναι για το frontend του, επομένως χρειάστηκε η διερεύνηση της σωστής διαδικασίας για την προετοιμασία της ενότητας για την εκτέλεση ερωτημάτων. Για να επιταχύνουμε τα πράγματα με τη χρήση του threadpool για την εκτέλεση πολλών ερωτημάτων ταυτόχρονα, θα χρησιμοποιούμε συχνά το threadpool σε όλο το έργο.<li><p>Κάθε αναζήτηση λέξης-κλειδιού δημιουργεί μια λίστα πιθανών πηγών περιεχομένου (Τα αποτελέσματα των μηχανών αναζήτησης) που αποθηκεύονται στον αποθηκευτικό χώρο για μεταγενέστερη επεξεργασία.<li><p>Όταν θέλουμε να βρούμε νέο περιεχόμενο για ένα συγκεκριμένο θέμα, πρώτα ελέγχουμε αν υπάρχουν διαθέσιμες πηγές, διαφορετικά δημιουργούμε νέες πηγές από τη λίστα λέξεων-κλειδιών.<li><p>Οι πηγές επεξεργάζονται μέσω δύο βιβλιοθηκών<a href=https://github.com/adbar/trafilatura> trafilatura</a> είναι το κύριο, αν αποτύχει κάνουμε backup σε<a href=https://github.com/goose3/goose3> χήνα</a> . Προσπαθούμε επίσης να βρούμε ροές για πρόσθετους συνδέσμους (που θα θεωρούνται νέες πηγές). Για τροφοδοσίες χρησιμοποιούμε<a href=https://github.com/dfm/feedfinder2> τροφοδότης</a> αλλά μια απλή ανάλυση του html για rss<code>link</code> οι ετικέτες θα ήταν επίσης αρκετές.<li><p>Ο κύριος τύπος περιεχομένου μας είναι ένα<code>Article</code> , το οποίο από την πλευρά του python είναι απλώς ένα dict, από την πλευρά του nim με την ανάλυση του ως αντικείμενο. Κλειδιά:<ul><li><p><code>title</code> : η κεφαλίδα του άρθρου<li><p><code>content</code> : το ίδιο το άρθρο. Για να προσδιορίσουμε ποιο είναι ένα καλό άρθρο, περνάμε από διάφορα βήματα φιλτραρίσματος:<ul><li><p>Αρχικά ελέγχουμε αν είτε η τραφιλατούρα είτε η χήνα έχουν κείμενο και αν είναι αρκετά μεγάλο. Το ελάχιστο μέγεθός μας είναι 300 λέξεις. Εάν το μέγεθος δεν ταιριάζει, απορρίπτουμε την πηγή (δεν επιστρέφουμε τίποτα).<li><p>Στη συνέχεια, ανακτούμε τον τίτλο και τον απολυμαίνουμε αφαιρώντας url και κενά<li><p>Εάν η γλώσσα είναι ξένη, τη μεταφράζουμε ξανά στα αγγλικά (κανονικοποιούμε στα αγγλικά) τόσο το περιεχόμενο όσο και τον τίτλο.<li><p>Σε αυτό το σημείο ελέγχουμε για βωμολοχίες χρησιμοποιώντας<a href=https://github.com/dimitrismistriotis/alt-profanity-check> βωμολοχία_έλεγχος</a> . Όχι ότι ο έλεγχος της βωμολοχίας είναι αγγλικός με βάση την προηγούμενη μετάφραση είναι απαραίτητος. Διαφορετικά θα χρειαζόμασταν ένα μοντέλο βωμολοχίας για όλες τις γλώσσες.<li><p>Αφού αντικαταστήσαμε τις κακές λέξεις χρησιμοποιώντας το φίλτρο βωμολοχίας, συνεχίζουμε με την απολύμανση του περιεχομένου. Ελέγχουμε αν το άρθρο είναι σχετικό. Υπάρχουν κανόνες που χρησιμοποιούμε είναι:<ul><li><p>Το περιεχόμενο πρέπει να ξεκινά με αλφαριθμητικούς χαρακτήρες, διαφορετικά υπάρχει μεγάλη αλλαγή ότι είναι σκουπίδι.<li><p>Τόσο ο τίτλος όσο και το περιεχόμενο δεν μπορεί να είναι "θόρυβος". Ο θόρυβος ορίζεται από ένα regex που καταγράφει λέξεις-κλειδιά όπως "είσοδος", "εγγραφή", "δεν επιτρέπεται η πρόσβαση"... κ.λπ.<li><p>Τουλάχιστον μία λέξη στον τίτλο πρέπει να υπάρχει στο σώμα. Διαφορετικά, είναι πιθανό η ανάλυση να επέλεξε λάθος μέρη της σελίδας πηγής για περιεχόμενο.</ul><li><p>Εάν οι δοκιμές συνάφειας έχουν περάσει, ως τελικό βήμα καθαρίζουμε το περιεχόμενο από υπερβολικά πολλές αγκύλες, κενά διαστήματα, επαναλαμβανόμενους χαρακτήρες και ειδικούς χαρακτήρες.<li><p>Εάν ο καθαρισμός δεν έχει διαγράψει όλα, συνεχίζουμε την επεξεργασία του άρθρου.</ul><li><p><code>source</code> : ο σύνδεσμος που δείχνει την αρχική πηγή που αναλύσαμε<li><p><code>lang</code> : τη γλώσσα του άρθρου, χρησιμοποιούμε<a href=https://github.com/pemistahl/lingua-py> lingua</a> για να εντοπίσετε τη γλώσσα<li><p><code>desc</code> : η περίληψη, διαφορετικά απόσπασμα από το περιεχόμενο<li><p><code>author</code> : ο συγγραφέας, διαφορετικά ο τίτλος της αρχικής σελίδας του συνδέσμου πηγής<li><p><code>pubDate</code> : η ημερομηνία δημοσίευσης του άρθρου ή τώρα<li><p><code>topic</code> : το θέμα στο οποίο ανήκει αυτό το άρθρο<li><p><code>tags</code> : σχετικές λέξεις-κλειδιά για ένα άρθρο, χρησιμοποιούμε την ταχύτερη lib εξαγωγής kw, που είναι<a href=https://github.com/csurfer/rake-nltk> τσουγκράνα</a> , εναλλακτικές που εξετάζονται είναι<a href=https://github.com/kevinlu1248/pyate> pyate</a> (combobasic),<a href=https://github.com/DerwenAI/pytextrank> textrank</a> και<a href=https://github.com/slanglab/phrasemachine> φρασημηχανή</a><li><p><code>imageTitle</code> : το εναλλακτικό κείμενο για την εικόνα<li><p><code>imageOrigin</code> : αν ανάλυση πηγής (για εικόνες που χρησιμοποιούμε<a href=https://github.com/michaelhelmick/lassie> κόρη</a> ) δεν έχει βρει εικόνα, ρωτάμε τις μηχανές αναζήτησης για μια σχετική εικόνα, επομένως το imageOrigin δείχνει την αρχική σελίδα που φιλοξενούσε την εικόνα, διαφορετικά είναι ίση με τη διεύθυνση url της πηγής.<li><p><code>imageUrl</code> : ο πραγματικός σύνδεσμος προς την εικόνα. Χρησιμοποιούμε έναν έλεγχο φίλτρου άνθισης για διπλότυπες εικόνες, επειδή δεν μας αρέσουν οι διπλότυπες.<li><p><code>icon</code> : το favicon του συνδέσμου πηγής</ul><li><p>Αφού επεξεργαστούμε μια λέξη-κλειδί, αποθηκεύουμε τα άρθρα και τις ροές που βρέθηκαν στον αποθηκευτικό χώρο. Θα χρησιμοποιηθούν από τον εκδότη.</ul><p>Το ξύσιμο γίνεται συνέχεια, είναι δαίμονας. Ο ψευδοκώδικας του κύριου βρόχου μοιάζει με αυτό και έχει ρυθμιστεί<em> ανά τοποθεσία</em>:<ul><li><p>συγχρονίστε τους διακομιστές μεσολάβησης για πάντα<li><p>για κάθε θέμα ταξινομημένο κατά πλήθος μη δημοσιευμένων (άρθρων) (χαμηλή προς υψηλή) κάντε τα εξής<ul><li><p>εάν έχει περάσει ελάχιστο διάστημα από την τελευταία εργασία, εκτελέστε μια εργασία ανάλυσης για το θέμα. Το διάστημα αυξάνεται όσο περισσότερα αδημοσίευτα άρθρα έχουμε για ένα θέμα και είναι πάντα 0 εάν δεν έχουμε αδημοσίευτα άρθρα.<li><p>Κάντε το ίδιο, αλλά για ροές (που συλλέξαμε από πηγές, αν έχουμε)<li><p>Εάν ο ιστότοπος προορίζεται για τη δημιουργία νέων θεμάτων, δημιουργήστε ένα. (Αυτό έχει νόημα μόνο αν δεν αποφασίσετε τη λίστα θεμάτων κατά τη δημιουργία του ιστότοπου.)<li><p>Επιλέξτε ένα άρθρο από τα δημοσιευμένα και στείλτε ένα tweet (στέλνουμε 3 tweets την ημέρα, χρησιμοποιώντας<a href=https://github.com/bear/python-twitter> python-twitter</a>)<li><p>Επιλέξτε ένα άρθρο από τα δημοσιευμένα και ενημερώστε μια σελίδα στο facebook (κάνουμε 1 ενημέρωση την ημέρα, χρησιμοποιώντας<a href=https://github.com/jgorset/facepy> όμορφος</a>)</ul><p>(Επίσης, συνδέσαμε το reddit, αλλά το reddit δεν επιτρέπει τη διασταυρούμενη ανάρτηση, επομένως ήταν χαμένος κόπος.)</ul><h1 id=publishing><a class=header-anchor href=#publishing> Εκδόσεις</a></h1><p>Μόλις έχουμε περιεχόμενο για δημοσίευση, πρέπει να αποφασίσουμε τι θα δημοσιεύσουμε και πόσο συχνά. Δεν βρήκα κανένα κόλπο εδώ, γιατί όπως ανέφερα προηγουμένως η επιλογή του τι να εμφανιστεί εξαρτάται από τον χρήστη. Έτσι απλά δημοσιεύουμε από<em> νεότερο προς παλαιότερο</em> , με το σκεπτικό ότι κάτι που ξύσαμε πιο πρόσφατα είναι πιο σχετικό, είναι α<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> LIFO</a> Ουρά. Η δημοσίευση, αν και εξαρτάται αρκετά από τα εργαλεία python, συμβαίνει στο nim, επειδή εκτελείται δίπλα στον διακομιστή, ο οποίος είναι επίσης στο nim.<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> Η εκδοτική λογική</a></h2><p>Η δημοσίευση γίνεται συνεχώς, και όπως η απόξεση έχει διαστήματα αδράνειας, έτσι και η δημοσίευση γίνεται αντιστρόφως από την απόξεση. Όταν ξύνουμε, επιβραδύνουμε όταν έχουμε α<em> αρκετά μεγάλο</em> κρυφή μνήμη αδημοσίευτων άρθρων, με τη δημοσίευση επιβραδύνουμε όταν η κρυφή μας μνήμη αρχίζει να συρρικνώνεται πάρα πολύ. Με αυτόν τον τρόπο, σε συνδυασμό με το ξύσιμο, θα πρέπει πάντα να υπάρχει<em> κάποιο περιεχόμενο</em> προς δημοσίευση<em> κάποια στιγμή</em> στο μέλλον. Η πραγματική λογική δημοσίευσης:<ul><li><p>Λάβετε μια παρτίδα αδημοσίευτων άρθρων από την κρυφή μνήμη. (Επιλέγουμε να δημοσιεύουμε 3 νέα άρθρα ανά σειρά.)<li><p>Ελέγξτε αν είναι διπλότυπα. Ο έλεγχος αντιγραφής πραγματοποιείται μέσω κατακερματισμού ευαίσθητης τοποθεσίας, αξιοποιώντας ένα nim lib,<a href=https://github.com/Nim-NLP/minhash/> minhash</a> . Το LSH είναι αρκετά εντάσεως CPU (ξέρετε...κατακερματισμός) και απαιτεί το δικό του νήμα, (υπάρχουν μια-δυο άλλες εργασίες που χειριζόμαστε και απαιτούν τα δικά τους νήματα).<li><p>Απόδοση σελίδας: αυτό δεν απαιτείται, καθώς ο διακομιστής χειρίζεται ερωτήματα on-the-fly, αλλά η απόδοση εδώ είναι μια μορφή εκ των προτέρων αποθήκευσης στην κρυφή μνήμη.<li><p>Χειρισμός σελίδας. Δεδομένου ότι έχουμε να κάνουμε με έναν ιστότοπο, πρέπει να επιλέξουμε πόσα άρθρα θα εμφανίζονται ανά σελίδα και να αυξάνουμε τις σελίδες καθώς δημοσιεύουμε περισσότερα άρθρα. Επιλέγουμε να ομαδοποιήσουμε άρθρα σε σελίδες των ~10. Η τελευταία σελίδα είναι πάντα λιγότερα από 10 άρθρα.<li><p>Αποθηκεύστε την κατάσταση των δημοσιευμένων άρθρων, αυτό σημαίνει μετακίνηση των άρθρων από την κατάσταση "μη δημοσιευμένο" σε "δημοσιευμένο" και τη βάση δεδομένων LSH.<li><p>Μετά τη δημοσίευση νέων άρθρων πρέπει να καθαρίσουμε τις μπαγιάτικες κρυφές μνήμες. Πρέπει να καθαρίσουμε την αρχική σελίδα, τη σελίδα θέματος και τον χάρτη ιστότοπου και τη ροή rss.</ul><h1 id=serving><a class=header-anchor href=#serving> Σερβίρισμα</a></h1><p>Ρυθμίζουμε εργασίες και για να χαράσσουμε ένα περιεχόμενο δημοσίευσης, το μόνο που απομένει είναι η προβολή του.<h2 id=the_web_server><a class=header-anchor href=#the_web_server> Ο διακομιστής Ιστού</a></h2><p>Αφού έχει<a href=https://github.com/dom96/jester> δοκιμασμένος</a><a href=https://github.com/dom96/httpbeast> διαφορετικός</a><a href=https://github.com/olliNiinivaara/GuildenStern/> ιστός</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> διακομιστές</a>, λόγω διαφορετικών σφαλμάτων με τα οποία συμβιβάστηκα<a href=https://github.com/bung87/scorper> σκόρπερ</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> Χειρισμός αιτήματος</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> Το ρούτερ</a></h3><p>Χρησιμοποιούμε nim<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> εφαρμογή αντιστοίχισης προτύπων</a> για να ταιριάζει με μια πλειάδα συλλήψεων regex. Αυτό είναι το regex που δεν είναι καθόλου ξεκούραστο:<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> δείχνει όλους τους πιθανούς κόμβους που μπορεί να έχει ένα μονοπάτι. Τότε η δρομολόγησή μας μοιάζει με:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>Δεν είναι όμορφο, αλλά το να μην βασίζομαι σε κάποιον συγκεκριμένο δρομολογητή μου επέτρεψε να ανταλλάξω τον υποκείμενο διακομιστή ιστού χωρίς πολλή φασαρία κατά τη δοκιμή. Είναι επιτελεστικό; Ασαφείς! Δεν έχω κάνει κανένα σημείο αναφοράς που να το συγκρίνει με κάτι άλλο. Ωστόσο, αυτό που μυρίζει είναι το regex που μπορεί να έχει σφάλματα, και το γεγονός ότι η σειρά των θηκών έχει σημασία.<blockquote><p>Περίμενε ένα λεπτό...</blockquote><p>Υπάρχουν πολλά πράγματα που κάνουμε σε κάθε αίτημα πριν από την πραγματική δρομολόγηση της σελίδας:<p>Αρχικά ρυθμίζουμε τον κωδικό εκκαθάρισης (με<code>defer:</code> ) οι οποίες<em> πρέπει</em> βεβαιωθείτε ότι δεν υπάρχουν διαρροές.<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>Ελέγχουμε αν το νήμα είναι αρχικοποιημένο:<pre><code class="nim hljs">initThread()</code></pre><p>Αυτό πρέπει πραγματικά να εκτελείται μόνο μία φορά (ορίζει ένα καθολικό bool μετά την προετοιμασία για έλεγχο) και θα μπορούσε να γίνει εκτός του προγράμματος χειρισμού αιτημάτων. Αλλά τι είναι πραγματικά αρχικοποιημένο; Λοιπόν... πάρα πολλά πράγματα! Βασικά χρησιμοποιούμε καθολικές σταθερές που απαιτούν αρχικοποίηση, επίσης μερικές από αυτές δεν σχετίζονται πραγματικά με το νήμα, καθώς αρχικοποιούν τη μνήμη στο σωρό και μοιράζονται σε όλα τα νήματα<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>Στη συνέχεια αναλύουμε τις παραμέτρους<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>Τι χρησιμοποιούμε τις παραμέτρους; ο<code>ParamKey</code> Ο τύπος enum το περιγράφει:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>Κανουμε<em> microcaching</em> για αιτήματα, οπότε κάθε αίτημα αποθηκεύεται στην κρυφή μνήμη σύμφωνα με την πλειάδα<code>(path, query, accetEncoding)</code> , απαιτείται κωδικοποίηση γιατί μπορούμε να εξυπηρετήσουμε και τα δύο (μη)συμπιεσμένα σώματα. Ένα πλαίσιο αιτήματος μοιάζει με αυτό:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>ο<code>key</code> Το πεδίο χρησιμοποιείται για την ανάκτηση της σωστής προσωρινής αποθηκευμένης σελίδας (σώμα) από<code>pageCache</code>. Το κλείδωμα απαιτείται για να διασφαλιστεί ότι πολλαπλά αιτήματα που γίνονται ταυτόχρονα δεν αντιγράφουν εργασίες απόδοσης (εάν άλλο αίτημα δημιουργεί ήδη τη σελίδα, περιμένετε να ολοκληρωθεί). Κάθε βάση<code>HttpRequestRef</code> από τον chronos httpsserver αποθηκεύεται στο<code>rq</code> πεδίο. ο<code>params</code> έχουν ήδη αναλυθεί από το προηγούμενο<code>handleParams</code>.<li><p>Υποστηρίζουμε τη διαγραφή περιεχομένου μέσω του<code>d</code> param, που μας επιτρέπει να κάνουμε πυρηνικά άρθρα (σε περίπτωση που το φιλτράρισμα αποτύχει, αλλά δεν πρέπει ποτέ να χρησιμοποιείται στην πράξη, μόνο για εντοπισμό σφαλμάτων) με ένα απλό αίτημα λήψης http. Ποιος χρειάζεται άλλες μεθόδους http; Οχι εγώ.<li><p>Υποστηρίζουμε επίσης τη διαγραφή της προσωρινής μνήμης. Μπορούμε είτε να διαγράψουμε τη σελίδα,<code>c=0</code> ή όλες τις σελίδες<code>c=1</code> . Τα ενοχλητικά κομμάτια είναι ότι πρέπει να ελέγξουμε αν η διαδρομή είναι είτε ένα άρθρο, μια σελίδα, μια εικόνα ή ένα στοιχείο, και να καθαρίσουμε την κατάλληλη δομή κρυφής μνήμης. Υπάρχει κάποιο προφανές λογικό διπλότυπο εδώ με το δρομολογητή, αλλά εφόσον αυτό γίνεται εκ των προτέρων δρομολόγησης, πρέπει να είναι ad-hoc, να χειρίζεται μόνο περιπτώσεις σχετικές με την εκκαθάριση της προσωρινής μνήμης. Γίνεται εκ των προτέρων δρομολόγηση επειδή επίσης η κρυφή μνήμη εξυπηρετείται χωρίς δρομολόγηση, αφού εάν το αίτημα έχει ήδη δημιουργηθεί, μπορούμε απλώς να απαντήσουμε με το σώμα που είναι αποθηκευμένο στο<code>respBody</code> πεδίο (και<code>respHeaders</code>, <code>respCode</code>).<li><p>Αφού χειριστούμε τις λειτουργίες της κρυφής μνήμης, αναλύουμε τη διαδρομή.<li><p>Μετά από αυτό, συμβαίνει μια άλλη αεροπειρατεία:</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>Γιατί αυτό γίνεται επίσης πριν από τη δρομολόγηση; Από προεπιλογή εξυπηρετούμε μερικώς μεταφρασμένες σελίδες. Είμαστε φτωχοί :( και οι μεταφράσεις βασίζονται σε δωρεάν υπηρεσίες, αλλά δεν μπορούμε να αντέξουμε οικονομικούς χρόνους φόρτωσης, επομένως εκτελούμε τη μετάφραση με αναβολή ενώ εξυπηρετούμε τη σελίδα μεταφρασμένη με μόνο αποσπάσματα που έχουν αποθηκευτεί προσωρινά στη βάση δεδομένων μεταφράσεων μας.<p>Σε αυτό το σημείο υπάρχει η δρομολόγηση, τυλιγμένη σε μια εξαίρεση έτσι ώστε αν αποτύχει η προβολή της σωστής σελίδας, εκδώσουμε ένα<code>503</code> . Έκδοση α<code>503</code> σημαίνει ότι προσπαθήσαμε να δρομολογήσουμε μια έγκυρη διεύθυνση url αλλά δεν μπορέσαμε να δημιουργήσουμε μια σελίδα. Για μη έγκυρα url εκδίδουμε α<code>301</code> ανακατεύθυνση που σημαίνει ότι το url δεν είναι έγκυρο. Εξυπηρετούμε 11 διαφορετικά είδη url:<ul><li><p>αρχική σελίδα: αντλεί άρθρα από τα πιο πρόσφατα θέματα, ψευδώς τυχαία, δεν κάνουμε ταξινόμηση με βάση τη δημοτικότητα.<li><p>γενικά περιουσιακά στοιχεία (υπό<code>/assets/</code> διαδρομή): αντιστοιχίζονται απευθείας σε έναν αποκλειστικό κατάλογο<li><p>γενικές εικόνες (κάτω από<code>/i/</code> pah): πραγματοποιούμε μεσολάβηση εξωτερικών εικόνων για να δημιουργήσουμε μεγέθη που ταιριάζουν στον αποκριτικό ιστότοπό μας, όταν οι εικόνες δεν είναι διαθέσιμες είτε ένα διαφανές εικονοστοιχείο είτε ένα εικονίδιο εικόνας εμφανίζεται ως προεπιλογή.<li><p>αρχείο robots.txt<li><p>χάρτες ιστότοπου (για αρχική σελίδα και θέματα και σελίδες): Η αρχική σελίδα φιλοξενεί το ευρετήριο χάρτη ιστότοπου που δείχνει σε όλα τα θέματα χάρτες ιστοτόπου, τα θέματα χάρτες ιστοτόπου δείχνουν σε όλες τις σελίδες του θέματος, ο χάρτης ιστότοπου σελίδων δείχνει σε όλα τα άρθρα της σελίδας.<li><p>pwa manifest: το pwa manifest θα πρέπει να επιτρέπει στον ιστότοπο να εγκατασταθεί ως pwa (αλλά ειλικρινά δεν το έχω δοκιμάσει)<li><p>αναζητήσεις: Η αναζήτηση αξιοποιεί<a href=https://github.com/valeriansaliou/sonic> ηχητικός</a> με το<a href=https://github.com/alongwy/pysonic> pysonic</a> δεσίματα.<li><p>προτάσεις: Οι προτάσεις αντιμετωπίζονται επίσης μέσω ηχητικών βιβλιοθηκών. Αλλά απαιτούν<li><p>ροές: Όπως και οι χάρτες ιστότοπου, έχουμε διαφορετικές ροές για την αρχική σελίδα και για τα διαφορετικά θέματα, αν και δεν υπάρχουν ροές για μεμονωμένες σελίδες για προφανείς λόγους.<li><p>θεματικές σελίδες: Η σελίδα που είναι αφιερωμένη σε κάθε θέμα (π.χ. με διαδρομή<code>domain.com/my-topic/</code> ) Τραβάει τα τελευταία άρθρα που έχουν δημοσιευτεί για το θέμα, τα οποία ανήκουν σε ένα<em> ημιτελής</em> σελίδα.<li><p>σελίδες άρθρων: Η σελίδα του άρθρου δείχνει τον τίτλο του άρθρου, την περιγραφή, τον σύνδεσμο πηγής, τις ετικέτες, τον χρόνο δημοσίευσης (στο υποσέλιδο) και στο κάτω μέρος τραβάμε 3 σχετικά άρθρα. Τα σχετικά άρθρα λαμβάνονται χρησιμοποιώντας ένα ερώτημα αναζήτησης στον τίτλο ή τις ετικέτες του άρθρου.</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> Σχετικά με την απόδοση</a></h2><p>Η απόδοση της σελίδας επεξεργάζεται από την πλευρά nim χρησιμοποιώντας<a href=https://github.com/karaxnim/karax> καραξ</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> Γενική διάταξη σελίδας</a></h3><p>Ο ιστότοπος αποτελείται από μια επάνω σταθερή γραμμή που δείχνει:<ul><li><p>το url της αρχικής σελίδας, μέσω της εικόνας του λογότυπου svg.<li><p>το κουμπί ανοιχτό/σκοτεινό θέμα<li><p>τρέχουσα διεύθυνση url χρησιμοποιώντας την τρέχουσα διαδρομή<em> ψίχουλα</em> ως κείμενο συνδέσμου<li><p>τις πιο πρόσφατες ~ 10 url θεμάτων<li><p>Η γραμμή αναζήτησης (με κουμπί αναζήτησης), όπου εμφανίζονται προτάσεις όταν πληκτρολογείτε<li><p>το κουμπί γλώσσες, όπου όταν κάνετε κλικ, η λίστα των γλωσσών επιπλέει επάνω</ul><p>Δεδομένου ότι είναι μια σχεδίαση με απόκριση, όταν η θύρα προβολής είναι μικρότερη, η επάνω γραμμή συγκρατεί μόνο το πλαίσιο αναζήτησης, ενώ το υπόλοιπο εμφανίζεται σε μια πλευρική γραμμή με δυνατότητα εναλλαγής.<ul><li><p>Το υποσέλιδο, κρατώντας συνδέσμους για τον χάρτη ιστότοπου, rss, κοινωνικά, νομικά<li><p>Υποστηρίζονται διαφημίσεις σε διαφορετικές τοποθεσίες</ul><h2 id=rss><a class=header-anchor href=#rss> RSS</a></h2><p>Αυτό είναι ένα παράδειγμα συνάρτησης, δείχνει τι κάνουμε όταν δημοσιεύεται μια νέα ανάρτηση για την ενημέρωση της ροής:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> Χάρτες ιστότοπου</a></h2><p>Αυτός είναι ο πυρήνας της προσθήκης url στους χάρτες ιστότοπου:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> Πρότυπα</a></h2><p>Δεν χρησιμοποιούμε μηχανή προτύπων, καθώς το μεγαλύτερο μέρος της απόδοσης γίνεται με karax, αλλά για σελίδες όπως το ToS χρησιμοποιούμε πρότυπα αρχείων, όπου απλώς αντικαθιστούμε μια δέσμη μεταβλητών, όπως<code>envsubst</code> εντολή.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> Σελίδες άρθρων</a></h2><p>Όταν αποδίδουμε σελίδες όπως αρχική/θέματα και αριθμημένες σελίδες, πρέπει να εμφανίζουμε μια λίστα άρθρων, αυτή η συνάρτηση καλείται σε έναν βρόχο για τον αριθμό των άρθρων που θέλουμε να εμφανίσουμε:<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>Σημειώστε πώς σε ορισμένες γραμμές οι "διαφημίσεις" σέρνονται στο X)<h2 id=topics_list><a class=header-anchor href=#topics_list> Λίστα θεμάτων</a></h2><p>Στην επάνω γραμμή εμφανίζουμε τη λίστα θεμάτων, αυτό είναι που την εκτυπώνει:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>Υπάρχουν μερικά δύσοσμα μαθήματα σχεδίασης σκληρού κωδικοποιημένου υλικού εδώ μέσα. Ειλικρινά τα στοιχεία σχεδιασμού υλικού της Google είναι χάλια.<h2 id=post_footer><a class=header-anchor href=#post_footer> Υποσέλιδο ανάρτησης</a></h2><p>Το υποσέλιδο της ανάρτησης εμφανίζεται κάτω δεξιά σε μια σελίδα άρθρου (σε ltr) και εκτυπώνει πραγματικά μόνο την ημερομηνία δημοσίευσης.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> Αποσπάσματα</a></h2><p>Κατά τη δημιουργία καταχωρήσεων άρθρων μπορεί να χρειαστούμε αποσπάσματα εάν δεν υπάρχει διαθέσιμη περίληψη.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>Wtf είναι<code>parseHtml</code> κάνει εδώ; Είναι η περίπτωση που επιτρέπουμε την html μέσα σε περιεχόμενα άρθρου (αλλά μόνο ορισμένες ετικέτες), αυτή είναι μια επιλογή από τη μονάδα python trafilatura, την οποία διατηρούμε ενεργοποιημένη επειδή μπορεί να επηρεάσει τη μορφή του άρθρου. Πρέπει επίσης να είμαστε προσεκτικοί σχετικά με το κόψιμο των χορδών utf-8...<h2 id=minification><a class=header-anchor href=#minification> Ελαχιστοποίηση</a></h2><p>Η τελευταία εργασία μετά την κατασκευή του karax<code>VNode</code> δέντρο είναι να πετάξει τα byte. Το δέντρο εάν έχει πρόθεμα με την κεφαλίδα html και προαιρετικά ελαχιστοποιείται.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>Η ελαχιστοποίηση γίνεται από<a href=https://github.com/wilsonzlin/minify-html> minify-html</a> που έχουμε δεσμευτεί να χρησιμοποιήσουμε<a href=https://github.com/nim-lang/c2nim> c2nim</a> , το δεσμευτικό αρχείο περιέχει:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>Αλλά για την κατασκευή πρέπει να παρέχουμε τις στατικές βιβλιοθήκες, προσθέτοντας αυτή τη γραμμή στη δική μας<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>Εννοώ...αυτός είναι ο δρόμος μου όταν έχτισα τη βιβλιοθήκη minify που<em> btw</em> στην πραγματικότητα δεν έχει μια εξωτερική συνάρτηση c που μπορεί να καταναλώσει το nim, οπότε έπρεπε να τη γράψουμε μόνοι μας.<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> Nimpy και η αναζήτηση για διαγραφή σκουπιδιών χωρίς ατυχήματα</a></h1><p><a href=https://github.com/yglukhov/nimpy/> Δεσμοί Python για nim</a> πρέπει να απορρίψετε αντικείμενα python. Το πρόβλημα είναι ότι πρέπει να ελέγχουμε πότε ο nim κάνει GC. Η βιβλιοθήκη nimpy υποθέτει ότι το GIL είναι πάντα κλειδωμένο (το κλειδώνει στην αρχή), ότι είναι ελεύθερο να καλεί τον python όποτε θέλει. Αλλά ξεκλειδώνουμε το gil για να επιτρέψουμε σε ένα threadpool python να εκτελεί κώδικα ενώ το nim εκτελεί άλλα πράγματα. Εάν το python GIL ήταν πάντα κλειδωμένο από το nim, το threadpool θα ήταν αδρανές τις περισσότερες φορές.<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>Αυτό επιτρέπει τον τρόπο εκτέλεσης του κώδικα python που κρατά το GIL, αλλά μόνο στο τρέχον νήμα. Η υλοποίηση για την απόκτηση/απελευθέρωση του GIL σε διαφορετικά νήματα nim απαιτεί την κλήση διαφορετικών συναρτήσεων python C abi, επειδή το GIL είναι ένα mutex. Στη συνέχεια καλούμε python χρησιμοποιώντας αυτό το πρότυπο:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>Χρησιμοποιούμε τη δυνατότητα nim locks και guards, για να διασφαλίσουμε ότι οι τύποι python είναι προσβάσιμοι μόνο όταν διατηρείται το GIL. Ωστόσο, αυτό απαιτεί τον καθορισμό των pyobjects με το φύλακα:<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>Μπορώ λοιπόν να κάνω:<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>Και όποτε τηλεφωνώ<code>myVar</code> που περιέχει το αντικείμενο datetime, πρέπει να το τυλίξω ως εξής:<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>Τώρα μπορούμε να κλειδώσουμε το gil όταν πρέπει να εκτελέσουμε το GC, παρακάμπτοντας το nimpy<code>PyObject</code> καταστροφέας με αυτό:<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>Η κλειδαριά που χρησιμοποιούμε μέσα στον καταστροφέα δεν είναι<code>AsyncLock</code> καθώς αυτό θα ήταν πολύ ακριβό, και εμείς<em> όχι</em> πάντα κλειδώνετε, γιατί αυτό θα προκαλούσε πάγκους! Εάν δεν μπορούμε να κλειδώσουμε το gil, καθυστερούμε τη συλλογή και κρατάμε τον ακατέργαστο δείκτη python για το πότε θα μπορέσουμε να τον καθαρίσουμε. Ειλικρινά δεν ξέρω αν αυτό προκαλεί άλλες μορφές προβλημάτων, αλλά φαίνεται να λειτουργεί<em> αρκετά καλά</em>.<p>Έχουμε μια μονάδα nim που ονομάζεται<code>pyutils.nim</code> που κάνει ένα σωρό πράγματα nim<>python, για παράδειγμα:<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>Αυτό χρησιμοποιείται αρκετά:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>Αυτό χρησιμοποιείται όταν έχουμε προγραμματίσει μια εργασία python και θέλουμε να περιμένουμε να ολοκληρωθεί ασύγχρονα:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>Η σωστή σύνδεση python async θα απαιτούσε την ολοκλήρωση ενός nim async future από την python στο τέλος της προγραμματισμένης εργασίας της python, κάτι που δεν το κάνουμε επειδή δεν έχουμε ψάξει αρκετά βαθιά για το χειρισμό αντικειμένων nim από την python.<h2 id=ampification><a class=header-anchor href=#ampification> Ενίσχυση</a></h2><p>Υποστηρίζουμε τον ενισχυτή Google, επομένως δημιουργούμε σελίδες ενισχυτών που είναι κάπως συμβατές με amp. Δεν στοχεύουμε σε υποστήριξη 1:1. Στην πραγματικότητα εξουδετερώνουμε όλο το javascript που έχουμε και εξυπηρετούμε μόνο html/css. Ακόμη και τότε πρέπει να προσέχουμε να μην προσθέτουμε προσαρμοσμένα χαρακτηριστικά σε ετικέτες html ή απλώς προσαρμοσμένες ετικέτες html, ο amp είναι κακός έτσι... Για την αυτόματη μετατροπή σελίδας ενισχυτή χειριζόμαστε το<code>head</code> και το<code>body</code> επισημάνετε διαφορετικά.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>Όλα τα στυλ συγχωνεύονται σε ένα ενσωματωμένο σενάριο, αυτό που διατηρείται είναι<code>link</code> ετικέτες που δεν είναι στυλ/jscript, όπως lang. Ετικέτες σεναρίου για<code>ldljson</code>, <code>meta</code> ετικέτες. Κατά λέξη χειρίζεται κόμβους που είναι<em> κατά γράμμα</em> , πρέπει να τα μετατρέψουμε σε<code>XmlNode</code> (που σημαίνει ανάλυση) και χειριστείτε το σωστά. Το σώμα της διαδικασίας είναι παρόμοιο, διατηρούμε ορισμένες ετικέτες, αφαιρούμε άλλες, μετονομάζουμε άλλες:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>ο<code>form</code> η ετικέτα αντικαθίσταται με<code>amp-form</code> , ο ενισχυτής έχει πολλές από αυτές τις ετικέτες...<p>Πρέπει να διασφαλίσουμε ότι τα ενσωματωμένα στυλ βρίσκονται στο σωστό μήκος:<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>Η παραγωγή ενισχυτή μας δεν καλύπτει την πλήρη προδιαγραφή ενισχυτή, αλλά λειτουργεί για το περιεχόμενό μας (μέσω δοκιμής και σφάλματος :S).<h2 id=search><a class=header-anchor href=#search> Αναζήτηση</a></h2><p>Κάθε φορά που δημοσιεύεται ένα άρθρο, εισάγεται στη βάση δεδομένων sonic, η βάση δεδομένων sonic χειρίζεται "συλλογές", "κουβάδες" και "αντικείμενα". Ορίζουμε μια συλλογή ως ιστότοπο, επομένως κάθε ιστότοπος που θέλει να αναπτύξει το πρόγραμμα συγκέντρωσης περιεχομένου έχει τη δική του συλλογή. Δεν χρησιμοποιούμε<code>buckets</code> , αν και θα μπορούσαμε να θεωρήσουμε κάθε θέμα έναν κάδο που θα περιόριζε υπερβολικά την αναζήτηση, επομένως κάθε ιστότοπος έχει μόνο έναν κάδο "προεπιλογή" και κάθε αντικείμενο του κάδου είναι ένα άρθρο (το οποίο μπορεί να είναι διαφορετικών θεμάτων).<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>Όταν προωθούμε περιεχόμενο στο ηχητικό, πρέπει να χωρίσουμε τα δεδομένα σε κομμάτια, το μέγιστο μήκος των οποίων είναι γνωστό κατά τη σύνδεση. Η απορρόφηση δεδομένων φαίνεται να είναι προβληματική μερικές φορές, καθώς φαίνεται ότι δεν μπορεί να χειριστεί ορισμένους συγκεκριμένους χαρακτήρες. Σε περίπτωση που ο διακομιστής sonic χαλάσει με κάποιο τρόπο, έχουμε επίσης μια λειτουργία για να επαναλάβουμε όλο το περιεχόμενο:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> Μετάφραση</a></h2><p>Η μετάφραση είναι μια πολύ ακατάστατη ιστορία. Είμαι στην 4η (!) υλοποίηση ενός μεταφραστικού περιτυλίγματος, αφού έχω γράψει σε php, πήγαινε και<a href=https://github.com/untoreh/Translator.jl> Τζούλια</a> , αυτό γράφεται και στο nim. Οι παραλλαγές php/go είναι λίγο σάπιες στις μέρες μας, ενώ η παραλλαγή julia χρησιμοποιείται ενεργά για αυτό το blog. Ωστόσο, για να επιτευχθεί χαμηλή καθυστέρηση για τον διακομιστή ιστού, ο τρόπος με τον οποίο υλοποιείται η μετάφραση στο julia δεν είναι κατάλληλος για εξυπηρέτηση σε πραγματικό χρόνο (μεταφράζει στατικά αρχεία) και ούτως ή άλλως η προσθήκη του julia ως εξάρτησης όταν έχουμε ήδη python θα ήταν πολύ μεγάλη απαίτηση.<p>Έπρεπε λοιπόν να εφαρμόσω μια νέα ενότητα μετάφρασης στο nim. Στην πραγματικότητα, η αρχική ενότητα μετάφρασης nim έμοιαζε πολύ με την υλοποίηση της Julia, όπου μεταφράζαμε στατικά αρχεία<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . Στη συνέχεια, όταν ο διακομιστής ιστού άρχισε να διαμορφώνεται, τον άλλαξα για να μεταφράσω τους κόμβους karax κατά παραγγελία. Αυτό επιτρέπει τη μετάφραση κάθε ιστοσελίδας ακριβώς έγκαιρα για το αίτημα.<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>Πάνω είναι ο κύριος βρόχος επανάληψης<code>translateIter</code>:<ul><li><p><code>getTforms</code> αντιστοιχίζει τις λειτουργίες σε ετικέτες html, επιτρέποντας την εκτέλεση μεταλλάξεων κατά περίπτωση.<li><p><code>rewriteUrl</code> εισάγει τη διαδρομή lang (π.χ<code>/en/</code> ) στη διαδρομή url.<li><p><code>translateVbtm</code> χειρίζεται αυτολεξεί κόμβους που απαιτούν ανάλυση.</ul><p>Η μετάφραση εφαρμόζεται σε όλους τους κόμβους κειμένου και στο<code>alt</code> και<code>title</code> γνωρίσματα.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Επειδή πρέπει να μεταφράσουμε κάθε κόμβο κειμένου ξεχωριστά (διαφορετικά δεν μπορούμε να αποδώσουμε πίσω το html) κάθε μετάφραση κόμβου είναι μια ξεχωριστή εργασία. Δεδομένου ότι οι εργασίες μπορούν να αναζητήσουν υπηρεσίες μετάφρασης του δικτύου, πρέπει να γίνονται ασύγχρονα. Κάνουμε διαχωρισμό και συγχώνευση ερωτημάτων μετάφρασης για να εξοικονομήσουμε κλήσεις api, αλλά δεν είναι σημαντικό να γνωρίζουμε τα εσωτερικά στοιχεία της μηχανής μετάφρασης. Το μόνο πράγμα που πρέπει να σημειώσω είναι ότι αρχικά χρησιμοποιούσα α<a href=https://github.com/nidhaloff/deep-translator> περιτύλιγμα python</a> (το οποίο εξακολουθώ να χρησιμοποιώ για τη μετάφραση αποκομμένου περιεχομένου) επειδή τα αυτοδιαχειριζόμενα περιτυλίγματα για εξωτερικά apis είναι επώδυνο, αλλά στη συνέχεια άλλαξα σε self wrapped υπηρεσία μετάφρασης google και yandex σε nim, επειδή η python γίνεται σημαντικό μποτιλιάρισμα κατά τον χειρισμό πολλών ταυτόχρονων μεταφράσεων.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>Στην πραγματικότητα, αρχικά ο συσσωρευτής περιεχομένου έπρεπε να δημιουργήσει απλώς στατικά αρχεία για<code>caddy</code> για προβολή, αλλά επειδή ο αριθμός των σελίδων που έπρεπε να δημιουργηθούν (που είναι ένας πίνακας n_lang(20) x amp(2) x σελίδα), η τεμπέλης απόδοση ήταν η καλύτερη επιλογή.</table><h2 id=stats><a class=header-anchor href=#stats> Στατιστικά στοιχεία</a></h2><p>Οι σελίδες θεμάτων και άρθρων παρακολουθούνται για πλήθος επισκέψεων.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>Χρησιμοποιούμε πλήθος επισκέψεων για να καθαρίζουμε σελίδες με χαμηλό πλήθος περιοδικά.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> Βάσεις δεδομένων</a></h2><p>Χρησιμοποιούμε<code>libmdbx</code> διά μέσου<a href=https://github.com/snej/nimdbx> αυτό το lib</a> . Πιθανώς είναι υπερβολικό, και η χρήση του leveldb θα ήταν αρκετή. Έχουμε έναν τύπο<code>LRUTrans</code> όπου η αρχική ιδέα ήταν να εγκατασταθεί η βάση δεδομένων ως προσωρινή μνήμη LRU, αλλά ήταν πολύ πιο αργή. Η υλοποίηση μπορεί να βρεθεί<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> εδώ</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>Αυτός ο τύπος χρησιμοποιείται για τέσσερις ξεχωριστές βάσεις δεδομένων:<ul><li><p>μεταφράσεις<li><p>προσωρινή μνήμη σελίδας<li><p>κρυφή μνήμη εικόνων<li><p>στατιστικα</ul><p>Ο τύπος βάσης δεδομένων υλοποιείται με λήπτες και ρυθμιστές και στη συνέχεια κάνει αυτόματη αποσυμπίεση κατά την ανάγνωση/εγγραφή. Για αυτό το λόγο δεν πρέπει να χρησιμοποιείται για εικόνες...αλλά δυστυχώς... Υπάρχουν επίσης ένα σωρό μικρές micro cache:<ul><li><p>vbtm: για αναλυμένο (κατά λέξη) περιεχόμενο<li><p>αναζήτηση: για ερωτήματα αναζήτησης<li><p>feeds: για τροφοδοσίες θεμάτων VNodes<li><p>rxcache: για regex, επειδή τα static regex του χρόνου μεταγλώττισης δεν είναι ακόμη τυποποιημένα (επίσης επειδή υπάρχουν πολλές βιβλιοθήκες regex στο nim)</ul><p>Αυτά υλοποιούνται ως<a href=https://github.com/jackhftang/lrucache.nim> lru caches</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> , πιο συγκεκριμένα ως «κλειδωμένες» κρυφές μνήμες lru, όπου κάθε λειτουργία λήψης και ρύθμισης τυλίγεται γύρω από μια κλειδαριά (νημάτιο). Αυτά τα κλείδωμα δεν μπορούν να προκαλέσουν στάθμευση με τον ασύγχρονο χρόνο εκτέλεσης, επειδή το κλείδωμα αποκτάται και απελευθερώνεται χωρίς καμία δήλωση απόδοσης, επομένως είναι ατομικά με αυτή την έννοια, ωστόσο εξακολουθούν να είναι χρήσιμα, καθώς χρησιμοποιούμε νήματα για διαφορετικές εργασίες.<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>Ωστόσο<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> νιμ στιφάδο</a> έχει μια απλούστερη υλοποίηση για την προσωρινή μνήμη lru την οποία θα χρησιμοποιούσα αν έβρισκα νωρίτερα.</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> Εργασίες φόντου</a></h1><p>Μερικές εργασίες που χρησιμοποιούμε είναι CPU Hunged, επομένως χρησιμοποιούμε ένα διαφορετικό νήμα για αυτές:<ul><li><p>lsh: Ο κατακερματισμός με ευαίσθητη τοποθεσία κάνει πολλούς υπολογισμούς<li><p>εικόνες: Η αλλαγή μεγέθους εικόνας απαιτεί αποκωδικοποίηση/κωδικοποίηση εικόνων, επομένως είναι δαπανηρή</ul><p>Δύο ακόμη νήματα χρησιμοποιούνται για την ενημέρωση της λίστας αρχείων στοιχείων και των διαφημίσεων, αν και δεν χρειάζεται cpu, απαιτείται ένα νήμα για την αποφυγή διακοπής λειτουργίας που προκαλούνται από το πρόγραμμα παρακολούθησης αρχείων.<p>Έχουμε επίσης ασύγχρονες μακροχρόνιες εργασίες για:<ul><li><p>μεταφράσεις<li><p>http αιτήματα</ul><p>Οι εργασίες Lsh, εικόνων, μετάφρασης και αιτημάτων http αντιμετωπίζονται χρησιμοποιώντας μια ρύθμιση παραγωγού/καταναλωτή. Εκτός από το ότι δεν χρησιμοποιούμε κανάλια, επειδή τα κανάλια μπλοκάρουν και δεν έχουμε μια ασύγχρονη εφαρμογή τους που είναι επίσης ασφαλής σε νήματα. Χρησιμοποιήσαμε μια ασύγχρονη υλοποίηση του<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> Αυτό</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . Και ένα ασύγχρονο τραπέζι, που είναι σαν λεωφορείο εκδηλώσεων<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>Ο διακομιστής nim χειρίζεται επίσης τρεις εργασίες ασυγχρονισμού:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>Η εργασία που παρακολουθεί τη χρήση των μνημών είναι ωραίο να έχετε, για να αποφύγετε προβλήματα OOM μεταξύ της διαδικασίας με κοντέινερ και του docker, επειδή το docker (ή ο πυρήνας) δεν σκοτώνει τη διαδικασία αμέσως και σε αυτό το χρονικό διάστημα ο διακομιστής μπορεί να μην ανταποκρίνεται. είναι καλύτερα να επανεκκινήσετε αμέσως χειροκίνητα.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>αν και το να τυλίξεις ένα απλό κανάλι σε ασύγχρονες ρουτίνες είναι μάλλον καλύτερο...αλίμονο</table><h1 id=images><a class=header-anchor href=#images> εικόνες</a></h1><p>Μοχλεύουμε<a href=https://github.com/imazen/imageflow/releases> ροή εικόνας</a> για αλλαγή μεγέθους και αποθήκευση εικόνων τοπικά. Τα δεσίματα είναι απλά, αλλά η διαδικασία είναι λίγο περίπλοκη. Με<code>getImg</code> λαμβάνουμε τα δεδομένα εικόνας από το απομακρυσμένο url:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>Στη συνέχεια, πρέπει να το προσθέσουμε σε ένα πλαίσιο ροής εικόνας:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Εάν η εικόνα δεν μπορεί να προστεθεί, σημαίνει ότι η ροή εικόνας απέτυχε να αναγνωρίσει τα δεδομένα ως έγκυρη εικόνα. Αφού στείλουμε τα δεδομένα, πρέπει να στείλουμε ένα ερώτημα στο περιβάλλον, στη συνέχεια να διαβάσουμε την απάντηση και να πάρουμε το αποτέλεσμα:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>Λαμβάνουμε τον τύπο mime από την απάντηση, που θα προωθηθεί στην απάντηση του διακομιστή web. Από την πλευρά του διακομιστή, η μετάφραση από τη διαδρομή url στη ροή εικόνας γίνεται ως εξής:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>Το url της εικόνας αποστέλλεται ως παράμετρος, σε συμπιεσμένη μορφή zstd. Η συμπίεση συντομεύει τα url (τις περισσότερες φορές). Έτσι βρήκα επίσης ένα σφάλμα στο google chrome, όπου δεν μπορούσε να χειριστεί url όπου το ερώτημα είχε συμπιεσμένα δεδομένα με κωδικοποίηση url. Ο Firefox ήταν εντάξει.<h2 id=ld-json><a class=header-anchor href=#ld-json> LD-JSON</a></h2><p>Προσθέτουμε σε κάθε ιστοσελίδα σενάρια ldjson.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>Και για μεταφρασμένες σελίδες:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> Opengraph</a></h2><p>Όπως και το ldjson, παρέχουμε επίσης μετα-ετικέτες opengraph:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>Οι μακροεντολές και τα πρότυπα Nim είναι χρήσιμα όταν αντιμετωπίζετε όλο αυτόν τον βαρύ κώδικα λέβητα.<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> Αιτήματα http από την πλευρά του διακομιστή</a></h2><p>Υπάρχει μια άλλη εργασία, η οποία χειρίζεται όλα τα αιτήματα http (για λήψη εικόνων, σεναρίων κ.λπ.) από την πλευρά του διακομιστή web. Χρησιμοποιούμε το chronos httpclient:<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>έπρεπε να προσθέσω<a href=https://github.com/untoreh/nim-chronos/tree/update> υποστήριξη για https και socks5 proxies</a> στον httpclient για να μπορεί να χρησιμοποιεί αποτελεσματικά τις μεταφράσεις.<h1 id=config><a class=header-anchor href=#config> Διαμόρφωση</a></h1><p>Μπορεί να έχετε παρατηρήσει μεταβλητές με κεφαλαία σε όλο τον κώδικα. Όλα αυτά είναι μεταβλητές διαμόρφωσης, που ορίζονται σε ένα αρχείο, το οποίο μπορεί να προσαρμοστεί ανά ιστότοπο.<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> συμπέρασμα</a></h1><p>Υπάρχουν ένα σωρό πράγματα που δεν έχω αναφέρει, αφού ο διάβολος είναι στις λεπτομέρειες... ωστόσο αυτή είναι μια πρόχειρη περιήγηση σε ολόκληρη τη βάση του κώδικα που αντιστοιχεί σε:<ul><li><p>~ 12k γραμμές nim<li><p>~ 400 γραμμές js<li><p>~ 1000 γραμμές scss<li><p>~ 3500 γραμμές πύθωνα<li><p>74 lines of rust (for bindings :P)</ul><p>Τι θα έκανα διαφορετικά;<ul><li><p>Πιθανώς να ξαναγράψω το όλο θέμα σε σκουριά, το nim αυτή τη στιγμή δεν χειρίζεται σωστά την ασφάλεια της μνήμης και ο χρόνος που χρειάστηκε να βασιστώ στο gdb για να διορθώσω σφάλματα ήταν πάρα πολύς και δεν κατάφερα καν να τα διορθώσω όλα. Είναι μεγάλο πρόβλημα όταν το μισό οικοσύστημα βασίζεται στο GC και το άλλο μισό στο ORC (ή ούτε καν ορκ και μόνο ARC). Η ανάμειξη async και threads είναι επίσης επώδυνη και τα async stacktraces είναι ένας εφιάλτης, (αν και δεν ξέρω αν η σκουριά είναι καλύτερη από αυτή την άποψη.)<li><p>Στόχος α<a href=https://en.wikipedia.org/wiki/Progressive_web_app> PWA</a> από την αρχή. Το έργο είχε αρκετά ενοχλητικό ξεκίνημα. Στην αρχή υποτίθεται ότι ήταν στατικές σελίδες που εξυπηρετούνταν από έναν διακομιστή ιστού, μετά έγινε ο ίδιος διακομιστής ιστού. Η διαδραστικότητα ήρθε ως εκ των υστέρων, επομένως έγινε απλώς ένας συνδυασμός αποδοθέντων html συν js/css. Αυτό με έκανε πολύ χαλαρό στο API, το οποίο βγήκε χωρίς καμία απολύτως δομή (εντελώς<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> ΑΝΗΣΥΧΟΣ</a> ). Στην επανεγγραφή θα χρησιμοποιούσα ένα πλαίσιο UI<a href=https://preactjs.com/> προκηρύσσουν</a> που διαθέτει πλήρη υποστήριξη AMP ή<a href=https://www.solidjs.com/> solidjs</a>.<li><p>Προσθέστε περισσότερους ad-hoc αναλυτές για δημοφιλείς πλατφόρμες. Η απλή ανάλυση άρθρων δεν λειτουργεί καλά (ή καθόλου) όταν οι πιο δημοφιλείς πλατφόρμες σήμερα προσφέρουν πολύ λίγο περιεχόμενο και πολλά βίντεο και εικόνες, επομένως η απόξεση πρέπει να στοχεύει περισσότερο σε εμπλουτισμένα μέσα αντί για κείμενο, αν αυτό δεν είναι που λαμβάνεται υπόψη κατά τον σχεδιασμό της αρχιτεκτονικής του scraper, το περιεχόμενο και οι πληροφορίες που θα εξυπηρετεί η APP δεν θα είναι ισορροπημένες.</ul><div id=post-tags-list>Ετικέτες ανάρτησης: <span class=post-tag><a href=https://www.unto.re/tag/apps> εφαρμογές</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> προγραμματισμός</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> λογισμικό</a></span></div><div class=page-foot><div class=copyright>11 Δεκεμβρίου 2022</div></div></div><div class=page__footer><footer><div class=page__footer-copyright>© untoreh - Powered by<a href=https://github.com/tlienart/Franklin.jl> Φράνκλιν</a></div><div class=page__footer-links>- <ul><li><a href=/el/sitemapxml> Χάρτης ιστοτόπου</a></li> | <li><a href=/el/tag> Ετικέτες</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> RSS</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li></ul></footer></div>