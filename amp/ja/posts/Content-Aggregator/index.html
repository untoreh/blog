<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"amp lang=ja><script async src=https://cdn.ampproject.org/v0.js></script><meta charset=utf-8><meta content=width=device-width,minimum-scale=1,initial-scale=1 name=viewport><style amp-custom>.hljs{display:block;font-size:14px;line-height:1.45em;overflow-x:auto;padding:.5em;color:var(--text-color);background:var(--block-background)}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:var(--text-color);font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:var(--text-color);font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.franklin-content .row{display:block}.franklin-content .left{float:left;margin-right:15px}.franklin-content .right{float:right}.franklin-content .container img{width:auto;padding-left:0;border-radius:10px}.franklin-content .footnote{position:relative;top:-.5em;font-size:70%}.franklin-toc li{margin:.6rem 0}.franklin-content h1{font-size:24px}.franklin-content h3{font-size:20px}.franklin-content h1,h3,h4,h5,h6{text-align:left}.franklin-content h1{padding-bottom:.5em;border-bottom:3px double #d3d3d3;margin-top:1.5em;margin-bottom:1em}.franklin-content h1 a{color:inherit}.franklin-content h1 a:hover{text-decoration:none}.franklin-content h2 a:hover{text-decoration:none}.franklin-content h3 a{color:inherit}.franklin-content h3 a:hover{text-decoration:none}.franklin-content h4 a{color:inherit}.franklin-content h4 a:hover{text-decoration:none}.franklin-content h5 a{color:inherit}.franklin-content h5 a:hover{text-decoration:none}.franklin-content h6 a{color:inherit}.franklin-content h6 a:hover{text-decoration:none}.franklin-content table{margin-left:auto;margin-right:auto;border-collapse:collapse;text-align:center}.franklin-content table *{line-height:.75rem}.franklin-toc ol ol{list-style-type:lower-alpha}.franklin-content th,td{font-size:var(--small);padding:10px;border:1px solid #000}.franklin-content blockquote{background:var(--block-background);border-left:7px solid #a8a8a8;margin:1.5em 10px;padding:.5em 10px;font-style:italic}.franklin-content blockquote p{display:inline}.franklin-content li p{margin:10px 0}.franklin-content a:hover{text-decoration:underline}.franklin-content .bibref a,.franklin-content .eqref a{color:green}.franklin-content sup{font-size:70%;vertical-align:super;line-height:0}.franklin-content sup a.fnref,.franklin-content td.fndef-backref a{overflow:visible;display:initial;padding-bottom:.3rem;padding-top:.2rem}.franklin-content table.fndef{margin:0 0 10px}.franklin-content .fndef tr,td{padding:0;border:0;text-align:left}.franklin-content .fndef tr{border-left:2px solid #d3d3d3}.franklin-content .fndef td.fndef-backref{vertical-align:top;font-size:70%;padding-left:5px}.franklin-content .fndef td.fndef-content{font-size:80%;padding-left:10px;width:100%}.franklin-content img{width:70%;text-align:center;padding-left:10%}.franklin-content .img-small img{width:50%;text-align:center;padding-left:20%}.katex{font-size:1em}.katex-display .katex{display:inline-block;white-space:normal}.katex-display:after{counter-increment:eqnum;content:"(" counter(eqnum) ")";position:relative;float:right;padding-right:5px}code.plaintext{display:block}.scrollbox{width:10em;height:10em;overflow:auto;visibility:hidden}.scrollbox-content,.scrollbox:focus,.scrollbox:hover{visibility:visible}.scrollbox_delayed{transition:visibility .2s}.scrollbox_delayed:hover{transition:visibility 0s .2s}.hljs{font-size:var(--small);line-height:1.35em;border-radius:10px}.hljs-meta,.hljs-metap,.hljs-metas{font-weight:700}.hljs-meta{color:#19b333}.hljs-metas{color:red}.hljs-metap{color:#3383e7}.franklin-content .colbox-blue{background-color:#eef3f5;padding:5px 10px;margin-left:5px;margin-top:5px;margin-bottom:5px;border-radius:0 10px 10px 0;border-left:5px solid #4c9cf1}body.light{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--alt4:#ffbebe;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}body.dark{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}.author__place .author__bio{font-size:1rem}.franklin-content blockquote{border-left-color:var(--accent)}.franklin-content #title a{padding:.5rem;line-height:100%}.franklin-content img{width:auto;text-align:center;padding:0}.page__footer{margin-top:1rem;padding-top:1rem}.franklin-content .intro{font-size:1.2rem;text-align:left}.franklin-content .intro ul{list-style-type:none;font-size:1.1rem;font-style:italic}.franklin-content .intro a{font-variant:small-caps;padding-bottom:.2rem;font-size:1.4rem;font-style:normal}.franklin-content .intro .icon{padding:0 .2rem;font-size:1rem}.franklin-content .active-projects ul h4{font-size:1.5rem;font-variant:small-caps;font-style:normal;margin:.2rem}.franklin-content h3{font-size:.9rem}.posts_list h3{text-align:center}.svg-inline--fa.icon{width:1rem}.masthead__inner-wrap{display:block;width:100%;padding:10px 0;height:inherit}.author__name{display:none}.author__place{font-size:.65em}.page__footer ul>li{list-style-type:none}ul>li.author__urls a:hover{filter:drop-shadow(.1rem .1rem 0 var(--accent2)) brightness(1.5);filter:brightness(1.5);transition-property:-moz-filter,-ms-filter,-o-filter,filter;transition-duration:.2s}ul>li.author__place a{color:var(--accent3);text-decoration:none;text-shadow:0 0 .01rem var(--alt2)}.langs-dropdown-wrapper{cursor:pointer}.langs-dropdown-content.show{display:block}.lang-link .flag-icon{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu .lang-list{transition:height}#site-nav .langs-dropdown-menu .lang-link:hover{color:var(--foreground-color)}.page-foot{font-size:.7em;line-height:1.25em;text-align:right;display:inline-block;width:100%}.tag-content{padding-top:1rem}.author__bio li{list-style:none}.author__bio li p{margin:0;padding:0}#tag-name{font-size:1.5rem;padding:.5rem;font-weight:700;font-variant:small-caps}#tag_title{font-variant:small-caps}#tag_title .wrap{text-align:left}#tag_title>.wrap>*{display:inline-block;text-align:left}#tag_cloud{font-weight:700}.posts_list.franklin-content>ul{list-style-type:"> "}.posts_list.franklin-content>.title{font-variant:small-caps}.posts_list.franklin-content>.title>h2{font-size:1rem;font-style:italic}.posts_list.franklin-content>.title>a>h1,.posts_list.franklin-content>.title>h2{display:inline}.posts_list.franklin-content>ul>li{line-height:1.2rem;padding:.1rem}.posts_list.franklin-content>ul>li>p{padding:.1rem;margin:.1rem}.posts_list.franklin-content>.title,.posts_list.franklin-content>.title>h2{text-align:center;display:block;margin:1rem}.page__footer-links>ul>li>a{padding:.2rem;margin:.2rem}#tag_cloud>a{padding:.2rem;font-variant:small-caps;vertical-align:middle;margin:.3rem;display:inline-block;text-decoration:none;text-shadow:0 0 5rem #fff}#tag_cloud .icon{font-size:1rem;vertical-align:middle;margin-right:.2rem;margin-left:.2rem}#tag_cloud_wrapper{display:inline-block;width:100%;text-align:center}#post-tags-list{font-variant:small-caps;font-weight:700}.media{font-size:1.5rem;line-height:2rem}#library .book-author{color:var(--accent2);font-size:.9rem;display:inline}.shows_list h3{font-size:1.5rem}a.imdb{padding:0 .5rem}#searchResults ul li{margin-bottom:1rem}.lunrSearchForm .search-input:focus{background:var(--block-background)}.lunrSearchForm .search-button{cursor:pointer}.lunrSearchForm .search-button:focus{color:var(--accent)}.result-title a{text-decoration:none}.result-title a:hover{text-decoration:underline}.result-preview,.resultCount{color:gray}.result-query{font-weight:700}footer>*{float:left}footer a{-webkit-text-decoration:underline dotted;text-decoration:underline dotted}footer ul.author__wrap>li{float:left;padding:0 .2rem}footer ul.author__wrap>li a{line-height:2rem;height:inherit;display:block}footer ul.author__wrap{float:right;margin:0}footer .page__footer-copyright{margin:0}footer .page__footer-links{margin:0 .2rem 0 .4rem}footer .page__footer-links ul{display:inline;margin:0 .4rem 0 0;padding:0}footer .page__footer-links li{display:inline}@media (min-width:680px){#tag-name,.tag-desc{text-align:left}}@media (min-width:680px) and (max-width:1300px){#site-nav .ham:hover{cursor:pointer}#site-nav .vert{transition:max-height .33s ease-in,filter .33s ease-in}}@media (max-width:680px){.masthead__inner-wrap{display:block}#tag-name,.tag-desc{text-align:center}.page__footer{width:100%;display:block}.page__footer{text-align:center}footer{display:inline-block;text-align:center}footer>*{display:inline-block;float:none}footer ul.author__wrap{float:none}footer .author__urls.social-icons{font-size:1rem}.page-foot .copyright{display:inline-block}}@media (max-width:680px){footer ul.author__wrap{margin-top:1rem;text-align:center;margin-left:0;padding-left:0}footer ul.author__wrap>li{float:none;display:inline-block}.page__footer{margin-top:3.5rem}}.site-title:after{-webkit-animation:chars 5.52s linear 1s forwards,cursor 1s 3;animation:chars 5.52s linear 1s forwards,cursor 1s 3}.hvr-buzz-out{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px #0000}.hvr-buzz-out:active,.hvr-buzz-out:focus,.hvr-buzz-out:hover{-webkit-animation-name:hvr-buzz-out;animation-name:hvr-buzz-out;-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-timing-function:linear;animation-timing-function:linear;-webkit-animation-iteration-count:1;animation-iteration-count:1}.franklin-content a:before{transition-property:left,right;transition-duration:.3s;transition-timing-function:ease-out}.franklin-content a:active:before,.franklin-content a:focus:before,.franklin-content a:hover:before{left:0;right:0}.hvr-outline-in:before{pointer-events:none;transition-duration:.2s;transition-property:top,right,bottom,left}.horiz .hvr-outline-in:active:before,.horiz .hvr-outline-in:focus:before,.horiz .hvr-outline-in:hover:before{top:-.5rem;right:-.5rem;bottom:-.5rem;left:0;opacity:1}.vert .hvr-outline-in:active:before,.vert .hvr-outline-in:focus:before,.vert .hvr-outline-in:hover:before{top:-.5rem;right:0;bottom:-.5rem;left:-.5rem;opacity:1}.masthead__menu ul li.author__avatar img{transition:transform .8s}.masthead__menu li.author__avatar:hover img{transform:rotateY(180deg);cursor:pointer}body.light .hljs{display:block;overflow-x:auto;padding:.5em;color:#000;background:#f8f8ff}body.light .hljs-comment,body.light .hljs-quote{color:#408080;font-style:italic}body.light .hljs-keyword,body.light .hljs-literal,body.light .hljs-selector-tag,body.light .hljs-subst{color:#954121}body.light .hljs-number{color:#40a070}body.light .hljs-doctag,body.light .hljs-string{color:#219161}body.light .hljs-section,body.light .hljs-selector-class,body.light .hljs-selector-id,body.light .hljs-type{color:#19469d}body.light .hljs-params{color:#00f}body.light .hljs-title{color:#458;font-weight:700}body.light .hljs-attribute,body.light .hljs-name,body.light .hljs-tag{color:navy;font-weight:400}body.light .hljs-template-variable,body.light .hljs-variable{color:teal}body.light .hljs-link,body.light .hljs-regexp{color:#b68}body.light .hljs-bullet,body.light .hljs-symbol{color:#990073}body.light .hljs-built_in,body.light .hljs-builtin-name{color:#0086b3}body.light .hljs-meta{color:#999;font-weight:700}body.light .hljs-deletion{background:#fdd}body.light .hljs-addition{background:#dfd}body.light .hljs-emphasis{font-style:italic}body.light .hljs-strong{font-weight:700}.flag.flag-gu{background-position:-96px -55px}.flag.flag-mn{background-position:-208px -88px}.flag.flag-va{background-position:-48px -154px}.flag.flag-tibet{background-position:-32px -143px}.flag.flag-fo{background-position:-64px -44px}.flag.flag-tl{background-position:-80px -143px}.flag.flag-kz{background-position:-144px -77px}.flag.flag-zm{background-position:-16px -165px}.flag.flag-uz{background-position:-32px -154px}.flag.flag-dk{background-position:-64px -33px}.flag.flag-scotland{background-position:-176px -121px}.flag.flag-gi{background-position:-224px -44px}.flag.flag-gy{background-position:-128px -55px}.flag.flag-bj{background-position:-112px -11px}.flag.flag-mo{background-position:-224px -88px}.flag.flag-ir{background-position:-112px -66px}.flag.flag-io{background-position:-80px -66px}.flag.flag-tm{background-position:-96px -143px}.flag.flag-ch{background-position:-96px -22px}.flag.flag-mt{background-position:-32px -99px}.flag.flag-gp{background-position:-16px -55px}.flag.flag-im{background-position:-48px -66px}.flag.flag-tv{background-position:-176px -143px}.flag.flag-mu{background-position:-48px -99px}.flag.flag-pe{background-position:-96px -110px}.flag.flag-vi{background-position:-112px -154px}.flag.flag-hn{background-position:-176px -55px}.flag.flag-ss{background-position:-128px -132px}.flag.flag-ae{background-position:-16px 0}.flag.flag-td{background-position:-240px -132px}.flag.flag-pw{background-position:0 -121px}.flag.flag-nu{background-position:-32px -110px}.flag.flag-bt{background-position:-208px -11px}.flag.flag-cv{background-position:-240px -22px}.flag.flag-mh{background-position:-144px -88px}.flag.flag-la{background-position:-160px -77px}.flag.flag-py{background-position:-16px -121px}.flag.flag-br{background-position:-176px -11px}.flag.flag-ye{background-position:-224px -154px}.flag.flag-ie{background-position:0 -66px}.flag.flag-gh{background-position:-208px -44px}.flag.flag-cg{background-position:-80px -22px}.flag.flag-cu{background-position:-224px -22px}.flag.flag-hu{background-position:-224px -55px}.flag.flag-sg{background-position:-224px -121px}.flag.flag-at{background-position:-176px 0}.flag.flag-lk{background-position:-224px -77px}.flag.flag-vu{background-position:-144px -154px}.flag.flag-bo{background-position:-160px -11px}.flag.flag-jo{background-position:-208px -66px}.flag.flag-er{background-position:-208px -33px}.flag.flag-rs{background-position:-80px -121px}.flag.flag-nr{background-position:-16px -110px}.flag.flag-ls{background-position:-256px -77px}.flag.flag-jm{background-position:-192px -66px}.flag.flag-tz{background-position:-208px -143px}.flag.flag-ki{background-position:-16px -77px}.flag.flag-sj{background-position:0 -132px}.flag.flag-cz{background-position:-16px -33px}.flag.flag-pg{background-position:-128px -110px}.flag.flag-lv{background-position:-32px -88px}.flag.flag-do{background-position:-96px -33px}.flag.flag-lu{background-position:-16px -88px}.flag.flag-no{background-position:-256px -99px}.flag.flag-kw{background-position:-112px -77px}.flag.flag-mx{background-position:-96px -99px}.flag.flag-yt{background-position:-240px -154px}.flag.flag-ly{background-position:-48px -88px}.flag.flag-cy{background-position:0 -33px}.flag.flag-my{background-position:-112px -99px}.flag.flag-sm{background-position:-48px -132px}.flag.flag-et{background-position:-240px -33px}.flag.flag-tj{background-position:-48px -143px}.flag.flag-ai{background-position:-64px 0}.flag.flag-kp{background-position:-64px -77px}.flag.flag-uy{background-position:-16px -154px}.flag.flag-gs{background-position:-64px -55px}.flag.flag-kurdistan{background-position:-96px -77px}.flag.flag-rw{background-position:-112px -121px}.flag.flag-ec{background-position:-128px -33px}.flag.flag-mm{background-position:-192px -88px}.flag.flag-pa{background-position:-80px -110px}.flag.flag-wales{background-position:-160px -154px}.flag.flag-kg{background-position:-256px -66px}.flag.flag-ve{background-position:-80px -154px}.flag.flag-tk{background-position:-64px -143px}.flag.flag-ca{background-position:-16px -22px}.flag.flag-is{background-position:-128px -66px}.flag.flag-ke{background-position:-240px -66px}.flag.flag-gq{background-position:-32px -55px}.flag.flag-tf{background-position:-256px -132px}.flag.flag-ad{background-position:0 0}.flag.flag-sk{background-position:-16px -132px}.flag.flag-pm{background-position:-192px -110px}.flag.flag-om{background-position:-64px -110px}.flag.flag-an{background-position:-112px 0}.flag.flag-ws{background-position:-192px -154px}.flag.flag-sh{background-position:-240px -121px}.flag.flag-mp{background-position:-240px -88px}.flag.flag-gt{background-position:-80px -55px}.flag.flag-cf{background-position:-64px -22px}.flag.flag-zanzibar{background-position:0 -165px}.flag.flag-mw{background-position:-80px -99px}.flag.flag-catalonia{background-position:-32px -22px}.flag.flag-ug{background-position:-240px -143px}.flag.flag-je{background-position:-176px -66px}.flag.flag-km{background-position:-32px -77px}.flag.flag-bf{background-position:-48px -11px}.flag.flag-mc{background-position:-80px -88px}.flag.flag-sy{background-position:-192px -132px}.flag.flag-sn{background-position:-64px -132px}.flag.flag-eu{background-position:-256px -33px}.flag.flag-bn{background-position:-144px -11px}.flag.flag-st{background-position:-144px -132px}.flag.flag-england{background-position:-192px -33px}.flag.flag-lc{background-position:-192px -77px}.flag.flag-dm{background-position:-80px -33px}.flag.flag-be{background-position:-32px -11px}.flag.flag-ni{background-position:-224px -99px}.flag.flag-mz{background-position:-128px -99px}.flag.flag-pf{background-position:-112px -110px}.flag.flag-tn{background-position:-112px -143px}.flag.flag-ee{background-position:-144px -33px}.flag.flag-xk{background-position:-208px -154px}.flag.flag-sx{background-position:-176px -132px}.flag.flag-sd{background-position:-192px -121px}.flag.flag-gd{background-position:-128px -44px}.flag.flag-ci{background-position:-112px -22px}.flag.flag-sz{background-position:-208px -132px}.flag.flag-cl{background-position:-144px -22px}.flag.flag-fi{background-position:0 -44px}.flag.flag-ga{background-position:-96px -44px}.flag.flag-np{background-position:0 -110px}.flag.flag-re{background-position:-48px -121px}.flag.flag-bg{background-position:-64px -11px}.flag.flag-sc{background-position:-160px -121px}.flag.flag-ng{background-position:-208px -99px}.flag.flag-qa{background-position:-32px -121px}.flag.flag-mk{background-position:-160px -88px}.flag.flag-aw{background-position:-208px 0}.flag.flag-kn{background-position:-48px -77px}.flag.flag-al{background-position:-80px 0}.flag.flag-bw{background-position:-240px -11px}.flag.flag-um{background-position:-256px -143px}.flag.flag-ky{background-position:-128px -77px}.flag.flag-tt{background-position:-160px -143px}.flag.flag-so{background-position:-80px -132px}.flag.flag-lt{background-position:0 -88px}.flag.flag-by{background-position:-256px -11px}.flag.flag-bb{background-position:0 -11px}.flag.flag-us{background-position:0 -154px}.flag.flag-md{background-position:-96px -88px}.flag.flag-ag{background-position:-48px 0}.flag.flag-hm{background-position:-160px -55px}.flag.flag-as{background-position:-160px 0}.flag.flag-eg{background-position:-160px -33px}.flag.flag-sv{background-position:-160px -132px}.flag.flag-sl{background-position:-32px -132px}.flag.flag-fk{background-position:-32px -44px}.flag.flag-am{background-position:-96px 0}.flag.flag-ck{background-position:-128px -22px}.flag.flag-tw{background-position:-192px -143px}.flag.flag-kh{background-position:0 -77px}.flag.flag-to{background-position:-128px -143px}.flag.flag-cd{background-position:-48px -22px}.flag.flag-pn{background-position:-208px -110px}.flag.flag-vc{background-position:-64px -154px}.flag.flag-somaliland{background-position:-96px -132px}.flag.flag-bi{background-position:-96px -11px}.flag.flag-pr{background-position:-224px -110px}.flag.flag-co{background-position:-192px -22px}.flag.flag-fm{background-position:-48px -44px}.flag.flag-bm{background-position:-128px -11px}.flag.flag-ar{background-position:-144px 0}.flag.flag-bv{background-position:-224px -11px}.flag.flag-sb{background-position:-144px -121px}.flag.flag-mq{background-position:-256px -88px}.flag.flag-eh{background-position:-176px -33px}.flag.flag-bh{background-position:-80px -11px}.flag.flag-hr{background-position:-192px -55px}.flag.flag-mv{background-position:-64px -99px}.flag.flag-mg{background-position:-128px -88px}.flag.flag-dz{background-position:-112px -33px}.flag.flag-gg{background-position:-192px -44px}.flag.flag-gm{background-position:-256px -44px}.flag.flag-af{background-position:-32px 0}.flag.flag-li{background-position:-208px -77px}.flag.flag-sr{background-position:-112px -132px}.flag.flag-vg{background-position:-96px -154px}.flag.flag-cr{background-position:-208px -22px}.flag.flag-tc{background-position:-224px -132px}.flag.flag-ao{background-position:-128px 0}.flag.flag-ma{background-position:-64px -88px}.flag.flag-mr{background-position:0 -99px}.flag.flag-gn{background-position:0 -55px}.flag.flag-ne{background-position:-176px -99px}.flag.flag-nf{background-position:-192px -99px}.flag.flag-wf{background-position:-176px -154px}.flag.flag-hk{background-position:-144px -55px}.flag.flag-gf{background-position:-160px -44px}.flag.flag-ps{background-position:-240px -110px}.flag.flag-ic{background-position:-240px -55px}.flag.flag-cw{background-position:-256px -22px}.flag.flag-ml{background-position:-176px -88px}.flag.flag-ax{background-position:-224px 0}.flag.flag-gl{background-position:-240px -44px}.flag.flag-dj{background-position:-48px -33px}.flag.flag-ht{background-position:-208px -55px}.flag.flag-lr{background-position:-240px -77px}.flag.flag-tg{background-position:0 -143px}.flag.flag-ba{background-position:-256px 0}.flag.flag-ge{background-position:-144px -44px}.flag.flag-bz{background-position:0 -22px}.flag.flag-au{background-position:-192px 0}.flag.flag-iq{background-position:-96px -66px}.flag.flag-cm{background-position:-160px -22px}.flag.flag-gw{background-position:-112px -55px}.flag.flag-az{background-position:-240px 0}.flag.flag-na{background-position:-144px -99px}.flag.flag-fj{background-position:-16px -44px}.flag.flag-zw{background-position:-32px -165px}.flag.flag-bs{background-position:-192px -11px}.flag.flag-il{background-position:-16px -66px}.flag.flag-nz{background-position:-48px -110px}.flag.flag-me{background-position:-112px -88px}.flag.flag-si{background-position:-256px -121px}.flag.flag-nc{background-position:-160px -99px}.flag.flag-lb{background-position:-176px -77px}</style><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{0%{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><meta charset=UTF-8><link href=https://www.unto.re/ja/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link href=https://www.unto.re/feed.xml rel=alternate title=untorehのサイト type=application/rss+xml><link href=https://www.unto.re/amp/ja/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2023,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> 楽しみと利益のためにコンテンツアグリゲーターを構築しますか?</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/ja/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/ja/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2023-05-22T16:50:00.465","inLanguage":"ja","name":"","mainEntityOfPage":{"@id":"/ja/posts/Content-Aggregator/","@type":"Article"}}</script><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/ja/></a><div class=author__wrap><ul><li class=author__avatar><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ja/posts/><i class="fas fa-pen menu-icons"></i> 投稿</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ja/media/><i class="fas fa-tv menu-icons"></i> メディア</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"></ul></div><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ja/posts/><i class="fas fa-pen menu-icons"></i> 投稿</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ja/media/><i class="fas fa-tv menu-icons"></i> メディア</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"></ul></div></nav></div></div></div><div><h1 id=title><a href=/ja/posts/Content-Aggregator> 楽しみと利益のためにコンテンツアグリゲーターを構築しますか?</a></h1><blockquote id=page-description style=font-style:italic>ウェブからコンテンツをスクレイピング、処理、表示する完全なアプリです...ウェブ上で。</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> なんで？</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> 情報過多</a> ?最近はちょっと悪いです。信号からノイズへの低い情報源がたくさんあり、圧倒されないように「フィード」を絞り込むのはちょっと難しいです。情報をフィルタリングし、簡単かつ迅速に消化できる形式で表示するツールがあれば、非常に便利です。これが私が考える理由です<em> コンテンツ集約</em> 破壊のための常緑のフィールド。それは、(インターネットが無料で、言論の自由がある限り) 良いビジネス チャンスです。これは、実行がすべてである (アイデアはまったくない) 例の 1 つです。<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> 期待の管理</a></h1><p>そうは言っても、最終的に私のアプリは実際のフィルタリングを行いません。実は単純に<em> 骨材</em> ウェブからのコンテンツ。これは、私がユーザーを組み込んでいないためであり、ユーザーごとに調整できない場合、フィルタリングを行うインセンティブはほとんどありません。<h1 id=the_architecture><a class=header-anchor href=#the_architecture> 建築学、建築物、建築様式</a></h1><p>アーキテクチャの図:その中には確かにたくさんの円があります!...ご存知のように...マイクロ...サービスですか?私が構築したアプリは「スクレーパー」と「サーバー」であり、「パブリッシャー」はサーバーに埋め込まれた単なるルーチンです。 「検索」と「プロキシ」は、それぞれの仕事をする外部ツールです。 「フロントエンド」は特別なものではなく、webpack にバンドルされている js と css の組み合わせです。<p>動く部分が違うので、初めて見たところから流れに沿っていきます。<h1 id=the_scraper><a class=header-anchor href=#the_scraper> スクレーパー</a></h1><p>スクレイピングは...お察しのとおり、pythonで行われます。ただし、アドホックな「スクレイピング」モジュールは使用されません。<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> 何をこするの？</a></h2><p>何をスクレイピングするかは、コンテンツのカテゴリによって異なります。カテゴリを「トピック」と呼びます。<ul><li><p>すべてのトピックにはキーワードのリストがあります。<li><p>を使用して Google アドワーズから取得した場合のキーワードのリスト<a href=https://github.com/googleads/google-ads-python> パイソン API</a><li><p>キーワードは、定期的にラウンド ロビンの順序で、複数の検索エンジンでクエリされます。インスタンスに複数のトピックがある場合、利用可能なコンテンツが少ないトピックが最初に検索されます。私たちが頼りにしている検索を実行するため<a href=https://github.com/searxng/searxng> サークス</a> プロキシ付き。 Searx は、主な用途がフロントエンドであるため、正確にはライブラリ フレンドリーではありません。そのため、クエリを実行するためにモジュールを初期化するための正しいプロセスを掘り下げる必要がありました。スレッドプールを使用して複数のクエリを同時に実行する速度を上げるために、プロジェクト全体でスレッドプールを頻繁に使用します。<li><p>すべてのキーワード検索は、後で処理するためにストレージに保存される潜在的なコンテンツ ソース (検索エンジンの結果) のリストを生成します。<li><p>特定のトピックの新しいコンテンツを見つけたい場合、まず利用可能なソースがあるかどうかを確認し、そうでない場合はキーワード リストから新しいソースを生成します。<li><p>ソースは 2 つのライブラリを介して処理されます<a href=https://github.com/adbar/trafilatura> トラフィラトゥーラ</a> がメインです。失敗した場合はバックアップします<a href=https://github.com/goose3/goose3> ガチョウ</a> .また、追加のリンク (新しいソースと見なされる) のフィードを見つけようとします。私たちが使用するフィードについて<a href=https://github.com/dfm/feedfinder2> フィードファインダー</a> しかし、RSS の html の単純な解析<code>link</code> タグでも十分です。<li><p>私たちの主なコンテンツタイプは<code>Article</code> 、これはpython側からは単なるdictであり、nim側からはオブジェクトとして解析します。キー:<ul><li><p><code>title</code> : 記事のヘッダー<li><p><code>content</code> : 記事自体。何が良い記事かを判断するために、さまざまなフィルタリング手順を実行します。<ul><li><p>最初に、trafilatura または goose のいずれかにテキストがあるかどうか、およびそれが十分に長いかどうかを確認します。最小サイズは 300 語です。サイズが一致しない場合、ソースは破棄されます (何も返されません)。<li><p>次に、タイトルを取得し、URL と空白を削除してサニタイズします。<li><p>言語が外国語の場合、コンテンツとタイトルの両方を英語に翻訳し直します (英語で正規化します)。<li><p>この時点で、次を使用して冒とく的な表現をチェックします<a href=https://github.com/dimitrismistriotis/alt-profanity-check> profanity_check</a> .不適切な表現のチェックは、以前の翻訳に基づく英語である必要はありません。そうしないと、すべての言語に冒涜モデルが必要になります。<li><p>冒涜フィルターを使用して悪い言葉を置き換えた後、コンテンツのサニタイズを続けます。記事が関連性があるかどうかを確認します。私たちが使用するルールは次のとおりです。<ul><li><p>コンテンツは英数字で始めなければなりません。そうしないと、ゴミになる可能性が高くなります。<li><p>タイトルとコンテンツの両方が「ノイズ」であってはなりません。ノイズは、「ログイン」、「サインアップ」、「アクセス拒否」などのキーワードをキャプチャする正規表現によって定義されます。<li><p>タイトルの少なくとも 1 つの単語が本文に含まれている必要があります。そうしないと、解析でコンテンツのソース ページの間違った部分が選択される可能性があります。</ul><li><p>関連性テストに合格した場合、最終ステップとして、コンテンツをクリーニングして、括弧、空白、繰り返し文字、および特殊文字が多すぎないようにします。<li><p>クリーニングですべてが削除されていない場合は、記事の処理を続行します。</ul><li><p><code>source</code> : 解析した元のソースへのリンク<li><p><code>lang</code> : 記事の言語、使用します<a href=https://github.com/pemistahl/lingua-py> リンガ</a> 言語を検出する<li><p><code>desc</code> : 要約、それ以外の場合はコンテンツからの抜粋<li><p><code>author</code> : 作者、それ以外はソースのホームページのタイトルリンク<li><p><code>pubDate</code> : 記事の発行日、または現在<li><p><code>topic</code> : この記事が属するトピック<li><p><code>tags</code> : 記事に関連するキーワード。最速の kw 抽出ライブラリを使用します。<a href=https://github.com/csurfer/rake-nltk> レーキ</a> 、考慮される代替案は次のとおりです<a href=https://github.com/kevinlu1248/pyate> パイテ</a> (コンボベーシック)、<a href=https://github.com/DerwenAI/pytextrank> テキストランク</a> と<a href=https://github.com/slanglab/phrasemachine> フレーズマシン</a><li><p><code>imageTitle</code> : 画像の代替テキスト<li><p><code>imageOrigin</code> : ソース解析の場合 (使用する画像の場合)<a href=https://github.com/michaelhelmick/lassie> ラッシー</a> ) 画像が見つからない場合、関連する画像を検索エンジンに照会するため、imageOrigin は画像をホストした元のページを指し、それ以外の場合はソース URL と同じになります。<li><p><code>imageUrl</code> : 画像への実際のリンク。重複画像は好きではないため、重複画像にはブルーム フィルター チェックを使用します。<li><p><code>icon</code> : ソース リンクのファビコン</ul><li><p>キーワードを処理した後、見つかった記事とフィードをストレージに保存します。それらは発行者によって使用されます。</ul><p>削り続けて、鬼です。メインループの疑似コードはこんな感じで、構成されています<em> サイトごと</em>:<ul><li><p>プロキシを永久に同期する<li><p>未公開 (記事) 数 (低いものから高いもの) で並べ替えられたトピックごとに、次の操作を行います。<ul><li><p>最後のジョブからの最小間隔が経過した場合は、トピックの解析ジョブを実行します。間隔は、トピックの未公開記事が多いほど増加し、未公開記事がない場合は常に 0 です。<li><p>同じことを行いますが、フィード (ソースがある場合はソースから収集したもの) に対しても行います。<li><p>サイトが新しいトピックを作成することを意図している場合は、トピックを作成します。 (これは、サイト作成時にトピック リストを決定しない場合にのみ意味があります。)<li><p>公開された記事から選んでツイートする（1日3回、<a href=https://github.com/bear/python-twitter> python-ツイッター</a>)<li><p>公開されたものから記事を選択し、Facebook ページを更新します (1 日 1 回の更新を使用して、<a href=https://github.com/jgorset/facepy> フェイスピー</a>)</ul><p>（redditも接続しましたが、redditはクロスポストができないので無駄な手間でした。）</ul><h1 id=publishing><a class=header-anchor href=#publishing> 出版</a></h1><p>公開するコンテンツができたら、何をどのくらいの頻度で公開するかを決定する必要があります。前に述べたように、何を表示するかの選択はユーザーに依存するため、ここではトリックを思いつきませんでした。だから私たちはちょうどから公開します<em> 新しいものから古いものへ</em> 、最近スクレイピングしたものの方が関連性が高いという理由で、それは<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> リフォ</a> 列。パブリッシュは Python ツールにかなり依存していますが、nim で行われます。これは、同じく nim にあるサーバーに隣接して実行されるためです。<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> パブリッシュのロジック</a></h2><p>パブリッシュは継続的に行われ、スクレイピングにアイドル間隔があるように、パブリッシュにはスクレイピングとは逆に、アイドル間隔があります。こするとき、私たちが持っているとき、私たちは減速します<em> 十分な長さ</em> 未公開の記事のキャッシュ。公開すると、キャッシュが縮小し始めると速度が低下します。このように、スクレイピングと相まって、常に存在する必要があります<em> いくつかのコンテンツ</em> 公開予定<em> しばらく</em> 将来。実際の公開ロジック:<ul><li><p>未公開記事のバッチをキャッシュから取得します。 (実行ごとに 3 つの新しい記事を公開することを選択します。)<li><p>それらが重複しているかどうかを確認します。重複チェックは、nim lib を活用して、局所性に敏感なハッシュを通じて行われます。<a href=https://github.com/Nim-NLP/minhash/> ミンハッシュ</a> . LSH は非常に CPU を集中的に使用し (ご存じのように...ハッシュ)、独自のスレッドを必要とします (独自のスレッドを必要とするいくつかのタスクを処理します)。<li><p>ページのレンダリング: サーバーはオンザフライでクエリを処理するため、これは必須ではありませんが、ここでのレンダリングは事前キャッシュの形式です。<li><p>ページ処理。私たちはサイトを扱っているので、ページごとに表示する記事の数を選択し、より多くの記事を公開するにつれてページを増やす必要があります。記事を最大 10 ページにグループ化することを選択します。最新ページは常に10記事未満です。<li><p>公開された記事の状態を保存します。これは、記事を「非公開」から「公開」ステータスに移動することを意味し、LSH データベースも保存します。<li><p>新しい記事を公開した後、古いキャッシュをクリアする必要があります。ホームページ、トピック ページ、サイトマップ、RSS フィードをクリアする必要があります。</ul><h1 id=serving><a class=header-anchor href=#serving> サービング</a></h1><p>パブリッシュ コンテンツをスクレイピングするためのジョブをセットアップし、あとはそれを提供するだけです。<h2 id=the_web_server><a class=header-anchor href=#the_web_server> ウェブサーバー</a></h2><p>した後<a href=https://github.com/dom96/jester> 試した</a><a href=https://github.com/dom96/httpbeast> 違う</a><a href=https://github.com/olliNiinivaara/GuildenStern/> ウェブ</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> サーバー</a>、私が解決したさまざまなバグのため<a href=https://github.com/bung87/scorper> スコーパー</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> リクエストの処理</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> ルーター</a></h3><p>私たちはニムを使います<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> パターンマッチングの実装</a> 正規表現キャプチャのタプルに一致します。これは、RESTful ではない正規表現です。<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> パスが持つことができるすべてのノードを示します。次に、ルーティングは次のようになります。<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>きれいではありませんが、特定のルーターに依存していないため、テスト時に大騒ぎせずに下層の Web サーバーを交換できました。パフォーマンスですか？不明！他のものと比較するベンチマークは行っていません。ただし、匂いがするのは、バグを持つ可能性のある正規表現と、ケースの順序が重要であるという事実です。<blockquote><p>ちょっと待って...</blockquote><p>実際のページ ルーティングの前に、各リクエストで行う処理がいくつかあります。<p>最初に、クリーンアップ コードをセットアップします (<code>defer:</code> ） どれの<em> したほうがいい</em> 漏れが起こらないようにします。<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>スレッドが初期化されているかどうかを確認します。<pre><code class="nim hljs">initThread()</code></pre><p>これは実際には 1 回だけ実行する必要があり (初期化後にグローバル bool を設定してチェックします)、要求ハンドラーの外部で実行できます。しかし、実際に初期化されるのは何ですか?うーん・・・かなりの量！基本的に、初期化を必要とするグローバル定数を (ab) 使用します。また、ヒープ上のメモリを初期化し、スレッド間で共有されるため、実際にはスレッドに関連しないものもあります。<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>次に、パラメータを解析します<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>パラメータは何に使用しますか?の<code>ParamKey</code> 列挙型はそれを説明します：<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>私たちはします<em> マイクロキャッシング</em> タプルに従ってすべてのリクエストがキャッシュされるように、リクエストに対して<code>(path, query, accetEncoding)</code> 、圧縮されていない両方の本文を提供できるため、エンコードが必要です。リクエスト コンテキストは次のようになります。<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>NS<code>key</code> フィールドは、キャッシュされた正しいページ (本文) を取得するために使用されます。<code>pageCache</code>.ロックは、同時に発生する複数のリクエストによってレンダリング ジョブが重複しないようにするために必要です (別のリクエストが既にページを生成している場合は、それが完了するまで待ちます)。すべての拠点<code>HttpRequestRef</code> chronos httpserver から、<code>rq</code> 分野。の<code>params</code> 以前のものからすでに解析されています<code>handleParams</code>.<li><p>によるコンテンツの削除をサポートしています。<code>d</code> これにより、単純な http get リクエストで記事を核にすることができます (フィルタリングが失敗した場合に備えて、デバッグのためだけに実際には使用しないでください)。他の http メソッドが必要なのは誰ですか?私じゃない。<li><p>キャッシュクリアもサポートしています。ページを削除するか、<code>c=0</code> またはすべてのページ<code>c=1</code> .厄介なのは、パスが記事、ページ、画像、アセットのいずれであるかを確認し、適切なキャッシュ構造を削除する必要があることです。ここではルーターとのロジックの重複が明らかですが、これはルーティング前に行われるため、アドホックである必要があり、キャッシュのパージに関連するケースのみを処理します。ルーティングなしでキャッシュが提供されるため、事前ルーティングが行われます。リクエストがすでに生成されている場合は、<code>respBody</code> フィールド (および<code>respHeaders</code>, <code>respCode</code>).<li><p>キャッシュ操作を処理した後、パスを解析します。<li><p>この後、別のハイジャックが進行中です。</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>これもルーティングの前に行われるのはなぜですか?デフォルトでは、部分的に翻訳されたページを提供しています。私たちは貧弱です :( 翻訳は無料サービスに基づいていますが、ひどい読み込み時間を許容できないため、翻訳データベースにキャッシュされたスニペットのみで翻訳されたページを提供している間、翻訳を延期して実行します.<p>この時点で、正しいページの提供に失敗した場合に例外を発行するように、ルーティングが例外でラップされています。<code>503</code> .を発行する<code>503</code> 有効な URL をルーティングしようとしたが、ページを生成できなかったことを意味します。無効な URL に対しては、<code>301</code> URL が無効であることを意味するリダイレクト。 11 種類の URL を提供しています。<ul><li><p>ホームページ: 最新のトピックから記事を取得します。疑似ランダムです。人気度に基づいた並べ替えは行いません。<li><p>一般的な資産 (<code>/assets/</code> path): 専用ディレクトリに直接マップされます<li><p>一般的な画像 (下<code>/i/</code> pah): 外部画像をプロキシして、レスポンシブ Web サイトに適合するサイズを生成します。画像が利用できない場合は、透明なピクセルまたは画像アイコンがデフォルトとして提供されます。<li><p>robots.txt ファイル<li><p>サイトマップ (ホームページとトピックとページ用): ホームページは、すべてのトピック サイトマップを指す sitemapindex をホストし、トピック サイトマップはトピックのすべてのページを指し、ページ サイトマップはページのすべての記事を指します。<li><p>pwa マニフェスト: pwa マニフェストは、Web サイトを pwa としてインストールできるようにする必要があります (ただし、率直に言って、これはテストしていません)。<li><p>検索: 検索は<a href=https://github.com/valeriansaliou/sonic> ソニック</a> とともに<a href=https://github.com/alongwy/pysonic> ピソニック</a> バインディング。<li><p>提案: 提案も音響ライブラリを通じて処理されます。しかし、彼らは必要とします<li><p>フィード: サイトマップと同様に、ホームページとトピックごとに異なるフィードがありますが、明らかな理由から単一ページのフィードはありません。<li><p>トピックページ: 各トピック専用のページ (例: パス付き)<code>domain.com/my-topic/</code> ) に属する、トピックについて発行された最新の記事をプルします。<em> 未完成</em> ページ。<li><p>記事ページ: 記事ページには、記事のタイトル、説明、ソース リンク、タグ、公開時刻 (フッター) が表示され、下部に 3 つの関連記事が表示されます。関連記事は、記事のタイトルまたはタグに対する検索クエリを使用して取得されます。</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> レンダリングについて</a></h2><p>ページのレンダリングは nim 側から処理されます。<a href=https://github.com/karaxnim/karax> カラックス</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> 一般的なページ レイアウト</a></h3><p>ウェブサイトは、以下を示す上部の固定バーで構成されています。<ul><li><p>ロゴの SVG 画像を介したホームページの URL。<li><p>ライト/ダーク テーマ ボタン<li><p>現在のパスを使用した現在の URL<em> パン粉</em> リンクテキストとして<li><p>最新の ~10 個のトピックの URL<li><p>入力した候補がポップアップする検索バー (検索ボタン付き)<li><p>クリックすると言語のリストが表示される言語ボタン</ul><p>レスポンシブ デザインであるため、ビューポートが小さい場合、トップ バーには検索ボックスのみが表示され、残りは切り替え可能なサイドバーに表示されます。<ul><li><p>サイトマップ、RSS、ソーシャル、法務へのリンクを保持するフッター<li><p>さまざまな場所での広告がサポートされています</ul><h2 id=rss><a class=header-anchor href=#rss> RSS</a></h2><p>これは関数の例で、フィードを更新するために新しい投稿が公開されたときに何をするかを示しています。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> サイトマップ</a></h2><p>これは、サイトマップに URL を追加する際の核心です。<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> テンプレート</a></h2><p>ほとんどのレンダリングは karax で行われるため、テンプレート エンジンは使用しませんが、ToS のようなページではファイル テンプレートを使用します。<code>envsubst</code> 指図。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> 記事ページ</a></h2><p>記事のリストを表示する必要があるホーム/トピックや番号付きページなどのページをレンダリングする場合、この関数は、表示する記事の数のループで呼び出されます。<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>一部の行で「広告」が X にどのように忍び寄るかに注意してください)<h2 id=topics_list><a class=header-anchor href=#topics_list> トピックス一覧</a></h2><p>上部のバーにトピック リストが表示されます。これが出力されます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>ここには、ハードコードされたマテリアル デザインのクラスがいくつかあります。率直に言って、Google のマテリアル デザイン コンポーネントはひどいものです。<h2 id=post_footer><a class=header-anchor href=#post_footer> 投稿フッター</a></h2><p>記事のフッターは記事ページの右下 (左端) に表示され、実際には公開日のみが表示されます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> 抜粋</a></h2><p>記事のエントリを作成するときに、要約が利用できない場合は抜粋が必要になることがあります。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>Wtfは<code>parseHtml</code> ここで行って？記事のコンテンツ内で html を許可する場合 (一部のタグのみ)、これは python モジュール trafilatura のオプションであり、記事の形式に影響を与える可能性があるため、有効のままにします。また、utf-8 文字列のチャンクにも注意する必要があります...<h2 id=minification><a class=header-anchor href=#minification> 縮小化</a></h2><p>karax を構築した後の最後のタスク<code>VNode</code> tree はバイトをダンプします。 html ヘッダーがプレフィックスとして付加され、オプションで縮小された場合のツリー。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>縮小はによって処理されます<a href=https://github.com/wilsonzlin/minify-html> minify-html</a> を使用してバインドしました<a href=https://github.com/nim-lang/c2nim> c2nim</a> 、バインディング ファイルには以下が含まれます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>しかし、ビルドのために静的ライブラリを提供する必要があり、この行を<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>つまり...それが私の道であり、縮小ライブラリを構築しました<em> ところで</em> 実際には、nim が消費できる extern c 関数がないため、自分で作成する必要がありました。<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> Nimpy とクラッシュのないガベージ削除の探求</a></h1><p><a href=https://github.com/yglukhov/nimpy/> nim の Python バインディング</a> Pythonオブジェクトを解放する必要があります。問題は、nim が GC を実行するタイミングを制御する必要があることです。 nimpy ライブラリは、GIL が常にロックされている (最初にロックする) ことを想定しているため、いつでも自由に Python を呼び出すことができます。しかし、nim が他のものを実行している間に Python スレッドプールがコードを実行できるようにするために、gil のロックを解除します。 Python GIL が常に nim によってロックされていた場合、ほとんどの場合、スレッドプールはアイドル状態になります。<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>これにより、GIL を保持する Python コードを実行する方法が許可されますが、現在のスレッドでのみ実行されます。 GIL はミューテックスであるため、異なる nim スレッドで GIL を取得/解放するための実装では、異なる python C abi 関数を呼び出す必要があります。次に、このテンプレートを使用して python を呼び出します。<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>GIL が保持されている場合にのみ Python 型にアクセスできるように、nim のロックとガード機能を利用します。ただし、これにはガード付きの pyobjects を定義する必要があります。<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>だから私はできる：<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>そして私が電話するたびに<code>myVar</code> datetime オブジェクトを保持するため、次のようにラップする必要があります。<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>これで、GC を実行する必要があるときに gil をロックして、nimpy をオーバーライドできます。<code>PyObject</code> これでデストラクタ：<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>デストラクタ内で使用するロックは、<code>AsyncLock</code> それは高すぎるので、私たちは<em> しないでください</em> 失速の原因となるため、常にロックしてください。ギルをロックできない場合は、コレクションを遅らせ、それをクリアできるようになるまで生の Python ポインタを保持します。正直なところ、これが他の形式の問題を引き起こすかどうかはわかりませんが、うまくいくようです<em> 十分に</em>.<p>という名前の nim モジュールがあります。<code>pyutils.nim</code> これは、次のような一連の nim<>python 処理を行います。<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>これはかなりよく使われます：<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>これは、Python ジョブをスケジュールしたときに使用され、非同期で終了するのを待ちます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>適切な python async バインディングには、python スケジュールされたジョブの最後に python からの nim async future を完了する必要がありますが、python からの nim オブジェクトの処理について十分に調べていないため、これは行いません。<h2 id=ampification><a class=header-anchor href=#ampification> 増幅</a></h2><p>Google amp をサポートしているため、ある程度 amp に準拠した amp ページを生成します。 1 対 1 のサポートを目的としていません。実際、私たちは持っているすべての JavaScript を削除し、html/css のみを提供しています。それでも、カスタム属性を html タグに追加したり、カスタム html タグだけに追加したりしないように注意する必要があります。amp はそのように悪いです...自動 amp ページ変換では、<code>head</code> そしてその<code>body</code> 別の方法でタグ付けします。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>すべてのスタイルが 1 つのインライン スクリプトにマージされ、保持されるのは<code>link</code> lang のように、スタイル/jscript ではないタグ。のスクリプトタグ<code>ldljson</code>, <code>meta</code> タグ。 Verbatim はノードを処理します。<em> リテラル</em> 、それらをに変換する必要があります<code>XmlNode</code> （解析を意味します）正しく処理します。プロセス本体は似ています。いくつかのタグを保持し、他のタグを削除し、他の名前を変更します:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>NS<code>form</code> タグは<code>amp-form</code> 、アンプにはこれらのタグがたくさんあります...<p>インライン スタイルが正しい長さであることを確認する必要があります。<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>私たちのアンプ世代は完全なアンプ仕様をカバーしていませんが、私たちのコンテンツでは機能します (試行錯誤を通じて:S)。<h2 id=search><a class=header-anchor href=#search> 検索</a></h2><p>記事が公開されるたびに、ソニック データベースに取り込まれます。ソニック データベースは「コレクション」、「バケット」、および「オブジェクト」を処理します。コレクションを Web サイトとして定義するため、コンテンツ アグリゲーターを展開するすべての Web サイトには独自のコレクションがあります。使用しません<code>buckets</code> 、ただし、各トピックは検索を絞り込みすぎるバケットと見なすことができます。そのため、すべてのサイトには「デフォルト」のバケットが 1 つだけあり、バケットの各オブジェクトは記事 (異なるトピックの可能性があります) です。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>コンテンツを sonic にプッシュする場合、データをチャンクに分割する必要があります。チャンクの最大長は接続時に認識されます。一部の特定の文字を処理できないように見えるため、データの取り込みは時々バグがあるようです。ソニック サーバーが何らかの理由で壊れた場合に備えて、すべてのコンテンツを再取り込みする機能もあります。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> 翻訳</a></h2><p>翻訳はかなり厄介な話です。 PHP で記述した後、翻訳ラッパーの 4 回目 (!) の実装を行っています。<a href=https://github.com/untoreh/Translator.jl> ジュリア</a> 、これもnimで書かれています。 php/go の亜種は最近少し腐っていますが、このブログでは julia の亜種が積極的に使用されています。ただし、Web サーバーの低遅延を実現するために、julia での翻訳の実装方法はリアルタイム サービスにはあまり適していません (静的ファイルを翻訳します)。いずれにせよ、Python が既にある場合に julia を依存関係として追加するのは非常に困難です。要件。<p>そのため、nim に新しい翻訳モジュールを実装する必要がありました。実際、最初の nim 翻訳モジュールは、静的ファイルを翻訳していた julia の実装によく似ていました。<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> .その後、Web サーバーの準備が整い始めたとき、オンデマンドで karax ノードを変換するように切り替えました。これにより、リクエストに合わせて各 Web ページを翻訳することができます。<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>上記はメインの反復ループです<code>translateIter</code>:<ul><li><p><code>getTforms</code> 関数を html タグにマップし、ケースバイケースでミューテーションを実行できるようにします。<li><p><code>rewriteUrl</code> lang パスを挿入します (.e.g<code>/en/</code> ) を URL パスに追加します。<li><p><code>translateVbtm</code> 解析が必要な逐語的なノードを処理します。</ul><p>翻訳はすべてのテキスト ノードと<code>alt</code> と<code>title</code> 属性。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>各テキスト ノードを個別に翻訳する必要があるため (そうしないと、html をレンダリングし直すことができません)、すべてのノードの翻訳は個別の作業になります。ジョブはネットの翻訳サービスを照会できるため、非同期で実行する必要があります。 API呼び出しを節約するために翻訳クエリの分割とマージを行いますが、翻訳エンジンの内部は重要ではありません。注意すべき唯一のことは、最初は<a href=https://github.com/nidhaloff/deep-translator> python ラッパー</a> （スクレイピングされたコンテンツの翻訳にまだ使用しています）外部APIの自己管理ラッパーは面倒ですが、多くの同時翻訳を処理するときにpythonがかなりのボトルネックになるため、nimで自己ラップされたgoogleおよびyandex翻訳サービスに切り替えました.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>実際、当初、コンテンツ アグリゲーターは静的ファイルを生成するだけでした。<code>caddy</code> ただし、生成するページの量 (n_lang(20) x amp(2) x ページのマトリックス) のため、遅延レンダリングの方が適切なオプションでした。</table><h2 id=stats><a class=header-anchor href=#stats> 統計</a></h2><p>トピックと記事のページは、ヒット数で追跡されます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>ヒット カウントを使用して、カウントの低いページを定期的にクリーンアップします。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> データベース</a></h2><p>を使用しております<code>libmdbx</code> 終えた<a href=https://github.com/snej/nimdbx> このライブラリ</a> .おそらくやり過ぎであり、leveldb を使用すれば十分だったでしょう。タイプがあります<code>LRUTrans</code> 最初のアイデアは、データベースを LRU キャッシュとしてセットアップすることでしたが、かなり遅くなりました。実装を見つけることができます<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> ここ</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>このタイプは、次の 4 つの別個のデータベースに使用されます。<ul><li><p>翻訳<li><p>ページキャッシュ<li><p>画像キャッシュ<li><p>統計</ul><p>データベース タイプは getter と setter で実装され、読み取り/書き込み時に自動解凍/圧縮を行います。このため、画像には使用しないでください...しかし、残念ながら...小さなマイクロキャッシュもたくさんあります:<ul><li><p>vbtm: 解析された (逐語的な) コンテンツ用<li><p>検索: 検索クエリ用<li><p>フィード: トピック フィードの VNode<li><p>rxcache: 正規表現用。コンパイル時の静的正規表現がまだ標準化されていないため (また、nim には複数の正規表現ライブラリがあるため)</ul><p>これらは次のように実装されます<a href=https://github.com/jackhftang/lrucache.nim> lru キャッシュ</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> 、より正確には「ロックされた」lruキャッシュとして、すべての取得および設定操作が（スレッド）ロックにラップされます。このロックは、yield ステートメントなしで取得および解放されるため、非同期ランタイムでストールを引き起こすことはありません。したがって、その意味ではアトミックですが、さまざまなタスクにスレッドを使用するため、依然として有用です。<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>でも<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> ニムシチュー</a> は、lru キャッシュのより単純な実装を備えています。</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> バックグラウンド ジョブ</a></h1><p>私たちが使用するいくつかのタスクは CPU を大量に消費するため、別のスレッドを使用します。<ul><li><p>lsh: 局所性に依存するハッシュは多くの計算を行います<li><p>images: 画像のサイズ変更には画像のデコード/エンコードが必要なため、コストがかかります</ul><p>アセット ファイルのリストと広告を更新するために、さらに 2 つのスレッドが使用されます。CPU を大量に消費するわけではありませんが、ファイル ウォッチャーによる停止を回避するためにスレッドが必要です。<p>また、次のような非同期の長時間実行タスクもあります。<ul><li><p>翻訳<li><p>http リクエスト</ul><p>Lsh、画像、翻訳、および http 要求のジョブは、プロデューサー/コンシューマーのセットアップを使用して処理されます。チャネルはブロックされ、スレッドセーフでもあるチャネルの非同期実装がないため、チャネルを使用しないことを除いて。の非同期実装を使用しました<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> これ</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> .イベントバスのような非同期テーブル<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>nim サーバーは、次の 3 つの非同期タスクも処理します。<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>docker (またはカーネル) はプロセスをすぐに強制終了せず、この期間中にサーバーが応答しなくなる可能性があるため、コンテナー化されたプロセスと docker の間の OOM の問題を回避するために、mem の使用状況を監視するタスクがあると便利です。すぐに手動で再起動することをお勧めします。<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>ただし、プレーン チャネルを非同期ルーチンでラップする方がおそらく優れています...悲しいかな</table><h1 id=images><a class=header-anchor href=#images> 画像</a></h1><p>私たちは活用します<a href=https://github.com/imazen/imageflow/releases> イメージフロー</a> 画像のサイズを変更してローカルにキャッシュします。バインディングはシンプルですが、プロセスは少し複雑です。と<code>getImg</code> リモート URL から画像データをフェッチします。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>次に、それをイメージフロー コンテキストに追加する必要があります。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>画像を追加できない場合は、imageflow がデータを有効な画像として認識できなかったことを意味します。データを送信したら、コンテキストにクエリを送信し、応答を読み取り、出力を取得する必要があります。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>Web サーバーの応答で転送される応答から MIME タイプを取得します。サーバー側からは、url パスから画像フローへの変換は次のように処理されます。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>画像の URL は、zstd 圧縮形式でパラメーターとして送信されます。圧縮により URL が短縮されます (ほとんどの場合)。これは、クエリに URL エンコードされた圧縮データが含まれる URL を処理できないという Google Chrome のバグを見つけた方法でもあります。代わりに Firefox は問題ありませんでした。<h2 id=ld-json><a class=header-anchor href=#ld-json> LD-JSON</a></h2><p>各 Web ページに ldjson スクリプトを追加します。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>翻訳されたページの場合:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> オープングラフ</a></h2><p>ldjson と同様に、opengraph メタ タグも提供します。<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>Nim マクロとテンプレートは、定型文の重いコードをすべて処理するときに役立ちます。<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> サーバー側の http リクエスト</a></h2><p>Web サーバー側からのすべての http 要求 (画像、スクリプトなどを取得するため) を処理する別のタスクがあります。クロノス httpclient を使用します。<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>追加しなければなりませんでした<a href=https://github.com/untoreh/nim-chronos/tree/update> httpsおよびsocks5プロキシのサポート</a> 翻訳を効果的に使用できるように httpclient に送信します。<h1 id=config><a class=header-anchor href=#config> 設定</a></h1><p>コード全体で変数が大文字になっていることに気付いたかもしれません。これらはすべて、Web サイトごとにカスタマイズできるファイルで定義される構成変数です。<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> 結論</a></h1><p>悪魔は詳細にあるので、私が言及していないことがたくさんあります...しかし、これはコードベース全体の大まかなツアーであり、次のようになります。<ul><li><p>~12k 行の nim<li><p>~400 行の js<li><p>~1000 行の scss<li><p>~3500 行の Python<li><p>74 lines of rust (for bindings :P)</ul><p>どうすればいいですか？<ul><li><p>おそらく全体を錆で書き直します.nimは現在メモリの安全性を適切に処理していません.クラッシュを修正するためにgdbに頼らなければならなかった時間は長すぎました.クラッシュをすべて修正することさえできませんでした.エコシステムの半分が GC に依存し、残りの半分が ORC に依存している場合 (または orc ではなく ARC のみ)、これは大きな問題です。非同期とスレッドを混在させることも苦痛であり、非同期スタックトレースは悪夢です (ただし、この点で錆が優れているかどうかはわかりません)。<li><p>ターゲット<a href=https://en.wikipedia.org/wiki/Progressive_web_app> PWA</a> はじめから。プロジェクトはかなり厄介なスタートを切りました。最初は、Web サーバーによって提供される静的ページであると想定されていましたが、その後、Web サーバー自体になりました。インタラクティブ性は後から付け足したものなので、レンダリングされた html と js/css を組み合わせたものになります。これにより、構造がまったくないまま (完全に<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> 落ち着かない</a> ）。書き換えでは、UI フレームワークを使用します。<a href=https://preactjs.com/> 予言する</a> AMP を完全にサポートしている、または<a href=https://www.solidjs.com/> solidjs</a>.<li><p>一般的なプラットフォーム用のアドホック パーサーを追加します。現在最も人気のあるプラットフォームが提供するコンテンツが非常に少なく、多くのビデオや画像が提供されている場合、プレーン記事の解析はうまく機能しません (またはまったく機能しません)。スクレーパー アーキテクチャを計画する際に考慮すると、APP が提供するコンテンツと情報は不均衡になります。</ul><div id=post-tags-list>投稿タグ： <span class=post-tag><a href=https://www.unto.re/tag/apps> アプリ</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> プログラミング</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> ソフトウェア</a></span></div><div class=page-foot><div class=copyright>2022 年 12 月 11 日</div></div></div><div class=page__footer><footer><div class=page__footer-copyright>©untoreh-Poweredby<a href=https://github.com/tlienart/Franklin.jl> フランクリン</a></div><div class=page__footer-links>- <ul><li><a href=/ja/sitemapxml> サイトマップ</a></li> | <li><a href=/ja/tag> タグ</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> RSS</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li></ul></footer></div>