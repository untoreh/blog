<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"dir=rtl lang=ur><meta charset=UTF-8><meta content=width=device-width,initial-scale=1 name=viewport><link href=https://www.unto.re/ur/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link title="untoreh کی سائٹ"href=https://www.unto.re/feed.xml rel=alternate type=application/rss+xml><link href=https://www.unto.re/amp/ur/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2023,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><link href=/libs/highlight/github.min.css rel=stylesheet><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><link href=/css/bundle.css media=print onload=this.onload=null;this.removeAttribute('media'); rel=stylesheet><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> تفریح ​​اور منافع کے لیے مواد جمع کرنے والا بنانا؟</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/ur/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/ur/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2023-05-22T16:28:20.316","inLanguage":"ur","name":"","mainEntityOfPage":{"@id":"/ur/posts/Content-Aggregator/","@type":"Article"}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/ur/></a><div class=author__wrap><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><ul><li class=author__avatar onclick=toggleTheme()><img alt=" بے نور روشنی"class=flip-front src=/assets/appa.webp><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="ویب سائٹ تلاش کریں۔"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ur/posts/><i class="fas fa-pen menu-icons"></i> پوسٹس</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ur/media/><i class="fas fa-tv menu-icons"></i> میڈیا</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div><button name="Website Menu"class=ham type=button><i class="fas fa-bars ham-icon"></i></button><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="ویب سائٹ تلاش کریں۔"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/ur/posts/><i class="fas fa-pen menu-icons"></i> پوسٹس</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/ur/media/><i class="fas fa-tv menu-icons"></i> میڈیا</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div></nav></div></div></div><div><h1 id=title><a href=/ur/posts/Content-Aggregator> تفریح ​​اور منافع کے لیے مواد جمع کرنے والا بنانا؟</a></h1><blockquote id=page-description style=font-style:italic>ایک مکمل ایپ جو ویب پر ویب سے مواد کو سکریپ، پروسیس اور پیش کرتی ہے۔</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> کیوں؟</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> معلومات کا اوورلوڈ</a> ? ان دنوں یہ قدرے برا ہے، معلومات کے شور کے ذرائع کے لیے بہت کم سگنل، آپ کی "فیڈز" کو اس طرح کم کرنا کہ آپ مغلوب نہ ہوں، قدرے مشکل ہے۔ ایک ٹول جو معلومات کو فلٹر کرتا ہے اور اسے ایک ایسے فارمیٹ میں پیش کرتا ہے جو آسان اور جلدی ہضم ہو، بہت مفید ہوگا۔ یہی وجہ ہے کہ میں غور کرتا ہوں۔<em> مواد کی جمع</em> رکاوٹ کے لیے ایک سدا بہار میدان۔ یہ ہے اور ہمیشہ رہے گا (جب تک کہ انٹرنیٹ مفت ہے اور تقریر کی آزادی ہے) ایک اچھا کاروبار کا موقع ہے۔ یہ ان مثالوں میں سے ایک ہے جہاں یہ سب کچھ پھانسی کے بارے میں ہے (اور خیال کے بارے میں کوئی بھی نہیں)۔<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> توقعات کا انتظام</a></h1><p>یہ کہہ کر، آخر میں میری ایپ کوئی حقیقی فلٹرنگ نہیں کرتی ہے۔ حقیقت میں یہ صرف<em> مجموعی</em> ویب سے مواد. اس کی وجہ یہ ہے کہ میں نے اس میں صارفین کو نہیں بنایا، اور اگر اسے فی صارف کے مطابق نہیں بنایا جا سکتا تو فلٹرنگ کرنے پر بہت کم ترغیب دی جاتی ہے۔<h1 id=the_architecture><a class=header-anchor href=#the_architecture> فن تعمیر</a></h1><p>فن تعمیر کا خاکہ:<img alt=" مواد جمع کرنے والا خاکہ"src=/assets/posts/img/content-aggregator-diagram.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block>واقعی اس میں بہت سے حلقے ہیں!...آپ جانتے ہیں...مائیکرو...سروسز؟ میں نے جو ایپس بنائی ہیں وہ " سکریپر" اور "سرور" ہیں، جبکہ "پبلشر" سرور میں سرایت شدہ ایک معمول ہے۔ "تلاش" اور "پراکسیز" بیرونی ٹولز ہیں جو اپنا کام کرتے ہیں۔ "فرنٹ اینڈ" کچھ خاص نہیں ہے، ویب پیک کے ساتھ بنڈل js اور css کا مرکب۔<p>چونکہ مختلف حرکت پذیر حصے ہیں میں مواد کے بہاؤ کے مطابق جاؤں گا، اس وقت سے جب مواد پہلی بار دیکھا گیا ہے۔<h1 id=the_scraper><a class=header-anchor href=#the_scraper> کھرچنے والا</a></h1><p>سکریپنگ اس میں کی جاتی ہے... آپ نے اندازہ لگایا، ازگر۔ تاہم کوئی ایڈہاک "سکریپنگ" ماڈیول استعمال نہیں کیا جاتا ہے۔<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> آپ کیا کھرچتے ہیں؟</a></h2><p>یہ فیصلہ کرنا کہ کیا کھرچنا ہے مواد کے زمرے پر منحصر ہے۔ ہم زمروں کو "موضوعات" کہتے ہیں۔<ul><li><p>ہر موضوع میں مطلوبہ الفاظ کی فہرست ہوتی ہے۔<li><p>مطلوبہ الفاظ کی فہرست اگر گوگل ایڈورڈز سے ان کا استعمال کرتے ہوئے کھینچی جائے۔<a href=https://github.com/googleads/google-ads-python> python api</a><li><p>مطلوبہ الفاظ کو ایک سے زیادہ سرچ انجنوں پر وقفے وقفے سے راؤنڈ رابن ترتیب میں استفسار کیا جاتا ہے۔ اگر مثال میں متعدد عنوانات ہیں، تو کم دستیاب مواد والے عنوانات پہلے تلاش کیے جاتے ہیں۔ ان تلاشوں کو انجام دینے کے لیے جن پر ہم انحصار کرتے ہیں۔<a href=https://github.com/searxng/searxng> searx</a> پراکسیوں کے ساتھ. Searx بالکل لائبریری دوستانہ نہیں ہے، چونکہ اس کا بنیادی استعمال اس کے فرنٹ اینڈ کے لیے ہے اس لیے اسے سوالات کرنے کے لیے ماڈیول کو شروع کرنے کے لیے درست عمل کے ذریعے کھودنے کی ضرورت ہے۔ بیک وقت متعدد سوالات کرنے کے لیے تھریڈ پول کے استعمال کے ساتھ چیزوں کو تیز کرنے کے لیے، ہم پورے پروجیکٹ میں تھریڈ پول کو کثرت سے استعمال کریں گے۔<li><p>ہر مطلوبہ الفاظ کی تلاش ممکنہ مواد کے ذرائع (سرچ انجن کے نتائج) کی فہرست تیار کرتی ہے جو بعد میں پروسیسنگ کے لیے سٹوریج پر محفوظ کی جاتی ہے۔<li><p>جب ہم کسی مخصوص موضوع کے لیے نیا مواد تلاش کرنا چاہتے ہیں تو ہم پہلے یہ چیک کرتے ہیں کہ آیا وہاں ذرائع دستیاب ہیں، ورنہ ہم مطلوبہ الفاظ کی فہرست سے نئے ذرائع پیدا کرتے ہیں۔<img alt=" مواد پائپ لائن"src=/assets/posts/img/content-pipeline.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block><li><p>ذرائع پر دو لائبریریوں کے ذریعے کارروائی کی جاتی ہے۔<a href=https://github.com/adbar/trafilatura> trafilatura</a> اہم ہے، اگر یہ ناکام ہوجاتا ہے تو ہم بیک اپ کرتے ہیں۔<a href=https://github.com/goose3/goose3> ہنس</a> . ہم اضافی لنکس کے لیے فیڈز تلاش کرنے کی بھی کوشش کرتے ہیں (جو نئے ذرائع تصور کیے جائیں گے)۔ فیڈ کے لیے ہم استعمال کرتے ہیں۔<a href=https://github.com/dfm/feedfinder2> فیڈ فائنڈر</a> لیکن آر ایس ایس کے لیے ایچ ٹی ایم ایل کا ایک سادہ تجزیہ<code>link</code> ٹیگ بھی کافی ہوں گے۔<li><p>ہمارے مواد کی بنیادی قسم ایک ہے۔<code>Article</code> ، جو python کی طرف سے یہ صرف ایک dict ہے، nim کی طرف سے اسے بطور شے پارس کریں۔ چابیاں:<ul><li><p><code>title</code> : مضمون کا ہیڈر<li><p><code>content</code> : مضمون خود۔ اس بات کا تعین کرنے کے لیے کہ اچھا مضمون کیا ہے، ہم مختلف فلٹرنگ مراحل سے گزرتے ہیں:<ul><li><p>پہلے ہم چیک کرتے ہیں کہ آیا trafilatura یا ہنس میں متن ہے اور اگر یہ کافی لمبا ہے۔ ہمارا کم از کم سائز 300 الفاظ ہے۔ اگر سائز مماثل نہیں ہے، تو ہم ماخذ کو ضائع کر دیتے ہیں (کچھ بھی واپس نہیں کرتے)۔<li><p>پھر ہم عنوان لاتے ہیں، اور یو آر ایل اور وائٹ اسپیس کو ہٹا کر اسے صاف کرتے ہیں۔<li><p>اگر لینگ غیر ملکی ہے، تو ہم اس کا انگریزی میں ترجمہ کرتے ہیں (ہم انگریزی پر معمول بناتے ہیں) مواد اور عنوان دونوں۔<li><p>اس مقام پر ہم استعمال کرتے ہوئے گستاخیوں کی جانچ کرتے ہیں۔<a href=https://github.com/dimitrismistriotis/alt-profanity-check> بے حرمتی_چیک</a> . ایسا نہیں ہے کہ پچھلے ترجمہ کی بنیاد پر گستاخیوں کی جانچ انگریزی میں ضروری ہے۔ بصورت دیگر ہمیں تمام زبانوں کے لیے گستاخانہ ماڈل کی ضرورت ہوگی۔<li><p>گستاخانہ فلٹر کا استعمال کرتے ہوئے برے الفاظ کو تبدیل کرنے کے بعد، ہم مواد کو صاف کرنا جاری رکھتے ہیں۔ ہم چیک کرتے ہیں کہ آیا مضمون متعلقہ ہے۔ ایسے قوانین ہیں جو ہم استعمال کرتے ہیں:<ul><li><p>مواد کا آغاز حروفِ عددی حروف سے ہونا چاہیے، بصورت دیگر بہت زیادہ تبدیلی ہے کہ یہ ردی کی ٹوکری ہے۔<li><p>عنوان اور مواد دونوں "شور" نہیں ہو سکتے۔ شور کی تعریف ایک ریجیکس کے ذریعہ کی جاتی ہے جو کلیدی الفاظ جیسے "لاگ ان"، "سائن اپ"، "رسائی سے انکار"...وغیرہ کو پکڑتا ہے۔<li><p>عنوان میں کم از کم ایک لفظ جسم میں موجود ہونا چاہیے۔ بصورت دیگر یہ ممکن ہے کہ تجزیہ نے مواد کے لیے سورس پیج کے غلط حصوں کا انتخاب کیا ہو۔</ul><li><p>اگر مطابقت کے امتحانات گزر چکے ہیں، تو حتمی مرحلے کے طور پر ہم مواد کو بہت زیادہ بریکٹ، سفید جگہ، بار بار حروف اور خصوصی حروف کی موجودگی سے صاف کرتے ہیں۔<li><p>اگر صفائی نے سب کچھ حذف نہیں کیا ہے تو ہم مضمون پر کارروائی جاری رکھیں گے۔</ul><li><p><code>source</code> : وہ لنک جو اصل ماخذ کی طرف اشارہ کرتا ہے جسے ہم نے تجزیہ کیا ہے۔<li><p><code>lang</code> : مضمون کی زبان، ہم استعمال کرتے ہیں۔<a href=https://github.com/pemistahl/lingua-py> زبان</a> زبان کا پتہ لگانے کے لیے<li><p><code>desc</code> : خلاصہ، بصورت دیگر مواد سے ایک اقتباس<li><p><code>author</code> : مصنف، بصورت دیگر سورس لنک کے ہوم پیج کا عنوان<li><p><code>pubDate</code> : مضمون کی اشاعت کی تاریخ، یا اب<li><p><code>topic</code> : وہ موضوع جس سے یہ مضمون تعلق رکھتا ہے۔<li><p><code>tags</code> : کسی مضمون کے لیے متعلقہ مطلوبہ الفاظ، ہم تیز ترین kw نکالنے والے lib کا استعمال کرتے ہیں، جو کہ ہے۔<a href=https://github.com/csurfer/rake-nltk> ریک</a> ، متبادل غور کیا جاتا ہے۔<a href=https://github.com/kevinlu1248/pyate> pyate</a> (combobasic)،<a href=https://github.com/DerwenAI/pytextrank> متن کا درجہ</a> اور<a href=https://github.com/slanglab/phrasemachine> جملہ سازی</a><li><p><code>imageTitle</code> : تصویر کے لیے متبادل متن<li><p><code>imageOrigin</code> : اگر سورس پارسنگ (تصاویر کے لیے ہم استعمال کرتے ہیں۔<a href=https://github.com/michaelhelmick/lassie> لسی</a> ) کو کوئی تصویر نہیں ملی، ہم متعلقہ تصویر کے لیے سرچ انجنوں سے استفسار کرتے ہیں، لہذا imageOrigin اصل صفحہ کی طرف اشارہ کرتا ہے جس نے تصویر کی میزبانی کی، ورنہ یہ سورس url کے برابر ہے۔<li><p><code>imageUrl</code> : تصویر کا اصل لنک۔ ہم ڈپلیکیٹ امیجز کے لیے بلوم فلٹر چیک کا استعمال کرتے ہیں، کیونکہ ہمیں ڈپلیکیٹ پسند نہیں ہیں۔<li><p><code>icon</code> : سورس لنک کا فیویکن</ul><li><p>کلیدی لفظ پر کارروائی کرنے کے بعد، ہم اس کے پائے گئے مضامین اور فیڈز کو اسٹوریج پر محفوظ کر لیتے ہیں۔ وہ پبلشر کی طرف سے استعمال کیا جائے گا.</ul><p>سکریپنگ مسلسل ہوتی ہے، یہ ایک شیطان ہے۔ مرکزی لوپ سیڈو کوڈ اس طرح لگتا ہے، اور یہ ترتیب دیا گیا ہے۔<em> فی سائٹ</em>:<ul><li><p>پراکسیوں کو ہمیشہ کے لیے ہم آہنگ کریں۔<li><p>غیر مطبوعہ (مضامین) شمار (کم سے زیادہ) کے حساب سے ترتیب دیئے گئے ہر موضوع کے لیے درج ذیل کام کریں۔<ul><li><p>اگر آخری کام سے کم از کم وقفہ گزر گیا تو، موضوع کے لیے پارس جاب چلائیں۔ وقفہ کسی موضوع کے لیے ہمارے پاس جتنے زیادہ غیر مطبوعہ مضامین ہیں، بڑھتا ہے، اور اگر ہمارے پاس کوئی غیر مطبوعہ مضامین نہیں ہیں تو یہ ہمیشہ 0 ہوتا ہے۔<li><p>ایسا ہی کریں لیکن فیڈز کے لیے (جو ہم نے ذرائع سے جمع کیا ہے، اگر ہمارے پاس کوئی ہے)<li><p>اگر سائٹ کا مقصد نئے عنوانات بنانا ہے تو ایک بنائیں۔ (یہ صرف اس صورت میں معنی رکھتا ہے جب آپ سائٹ کی تخلیق پر عنوانات کی فہرست کا فیصلہ نہیں کرتے ہیں۔)<li><p>شائع شدہ مضامین میں سے ایک مضمون منتخب کریں اور ایک ٹویٹ بھیجیں (ہم روزانہ 3 ٹویٹس بھیجتے ہیں، استعمال کرتے ہوئے<a href=https://github.com/bear/python-twitter> python-twitter</a>)<li><p>شائع شدہ مضامین میں سے ایک مضمون منتخب کریں اور فیس بک پیج کو اپ ڈیٹ کریں (ہم روزانہ 1 اپ ڈیٹ کرتے ہیں، استعمال کرتے ہوئے<a href=https://github.com/jgorset/facepy> چہرے والا</a>)</ul><p>(ہم نے reddit کو بھی منسلک کیا، لیکن reddit کراس پوسٹنگ کی اجازت نہیں دیتا، لہذا یہ ایک ضائع کوشش تھی۔)</ul><h1 id=publishing><a class=header-anchor href=#publishing> اشاعت</a></h1><p>ایک بار جب ہمارے پاس شائع کرنے کے لیے مواد ہو جائے، تو ہمیں فیصلہ کرنا ہے کہ کیا شائع کرنا ہے اور کتنی بار۔ میں یہاں کوئی تدبیر نہیں لے کر آیا، کیونکہ جیسا کہ میں نے پہلے ذکر کیا ہے کہ کیا ڈسپلے کرنا ہے اس کا انتخاب صارف پر منحصر ہے۔ تو ہم صرف سے شائع کرتے ہیں۔<em> تازہ ترین سے قدیم ترین</em> ، اس استدلال کے ساتھ کہ ہم نے حال ہی میں کھرچنے والی چیز زیادہ متعلقہ ہے، یہ ایک ہے۔<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> LIFO</a> قطار. اشاعت اگرچہ python ٹولز پر کافی انحصار کرتی ہے، نم میں ہوتی ہے، کیونکہ یہ سرور سے ملحق چلتی ہے، جو کہ نم میں بھی ہے۔<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> اشاعت کی منطق</a></h2><p>اشاعت مسلسل ہوتی رہتی ہے، اور جیسے سکریپنگ میں وقفہ وقفہ ہوتا ہے، اسی طرح پبلشنگ بھی سکریپنگ کے الٹا کام کرتی ہے۔ جب ہم کھرچتے ہیں، تو ہم سست ہوجاتے ہیں جب ہمارے پاس ایک ہوتا ہے۔<em> کافی دیر تک</em> غیر مطبوعہ مضامین کا ذخیرہ، جب ہمارا ذخیرہ بہت زیادہ سکڑنا شروع ہوتا ہے تو ہم اشاعت کے ساتھ سست ہوجاتے ہیں۔ اس طرح، سکریپنگ کے ساتھ مل کر، ہمیشہ ہونا چاہئے<em> کچھ مواد</em> شائع کیا جائے<em> کچھ وقت</em> مستقبل میں. اصل اشاعت کی منطق:<ul><li><p>کیشے سے غیر مطبوعہ مضامین کا ایک بیچ حاصل کریں۔ (ہم فی رن 3 نئے مضامین شائع کرنے کا انتخاب کرتے ہیں۔)<li><p>چیک کریں کہ آیا وہ ڈپلیکیٹ ہیں۔ ڈوپ چیکنگ مقامی حساس ہیشنگ کے ذریعے کی جاتی ہے، ایک نم لیب کا فائدہ اٹھاتے ہوئے،<a href=https://github.com/Nim-NLP/minhash/> منہاش</a> . LSH کافی سی پی یو ہے (آپ کو معلوم ہے... ہیشنگ)، اور اس کے اپنے تھریڈ کی ضرورت ہوتی ہے، (کچھ اور کام ہیں جو ہم سنبھالتے ہیں جن کے لیے ان کے اپنے تھریڈز کی ضرورت ہوتی ہے)۔<li><p>صفحہ رینڈرنگ: اس کی ضرورت نہیں ہے، کیونکہ سرور پرواز کے دوران سوالات کو ہینڈل کرتا ہے، لیکن یہاں پیش کرنا پری کیشنگ کی ایک شکل ہے۔<li><p>صفحہ ہینڈلنگ. چونکہ ہم ایک سائٹ کے ساتھ کام کر رہے ہیں ہمیں یہ چننا ہے کہ فی صفحہ کتنے مضامین دکھائے جائیں، اور جب ہم مزید مضامین شائع کریں تو صفحات میں اضافہ کریں۔ ہم مضامین کو ~10 کے صفحات میں گروپ کرنے کا انتخاب کرتے ہیں۔ تازہ ترین صفحہ ہمیشہ 10 مضامین سے کم ہوتا ہے۔<li><p>شائع شدہ مضامین کی حالت کو محفوظ کریں، اس کا مطلب ہے کہ مضامین کو "غیر مطبوعہ" سے "شائع شدہ" کی حیثیت اور LSH ڈیٹا بیس میں منتقل کرنا ہے۔<li><p>نئے مضامین شائع کرنے کے بعد ہمیں باسی کیچز کو صاف کرنا ہوگا۔ ہمیں ہوم پیج، ٹاپک پیج اور سائٹ میپ اور آر ایس ایس فیڈ کو صاف کرنا ہوگا۔</ul><h1 id=serving><a class=header-anchor href=#serving> سرونگ</a></h1><p>ہم شائع شدہ مواد کو ختم کرنے کے لیے نوکریاں ترتیب دیتے ہیں، بس اس کی خدمت کرنا باقی رہ جاتا ہے۔<h2 id=the_web_server><a class=header-anchor href=#the_web_server> ویب سرور</a></h2><p>ہونے کے بعد<a href=https://github.com/dom96/jester> کوشش کی</a><a href=https://github.com/dom96/httpbeast> مختلف</a><a href=https://github.com/olliNiinivaara/GuildenStern/> ویب</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> سرورز</a>, مختلف کیڑوں کی وجہ سے میں نے حل کیا۔<a href=https://github.com/bung87/scorper> سکورپر</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> ایک درخواست کو سنبھالنا</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> راؤٹر</a></h3><p>ہم نم استعمال کرتے ہیں۔<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> پیٹرن کے ملاپ کے نفاذ</a> ریجیکس کیپچرز کی ایک بڑی تعداد سے ملنے کے لیے۔ یہ وہ ریجیکس ہے جو بالکل بھی آرام دہ نہیں ہے:<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> تمام ممکنہ نوڈس دکھاتا ہے جو راستے میں ہوسکتے ہیں۔ پھر ہماری روٹنگ اس طرح نظر آتی ہے:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>یہ خوبصورت نہیں ہے، لیکن کسی خاص روٹر پر بھروسہ نہ کرنے کی وجہ سے مجھے جانچ کے دوران بغیر کسی ہنگامے کے انڈرلنگ ویب سرور کو تبدیل کرنے کی اجازت دی گئی۔ کیا یہ پرفارمنس ہے؟ غیر واضح! کسی اور چیز سے اس کا موازنہ کرتے ہوئے کوئی معیار نہیں بنایا ہے۔ تاہم جو خوشبو آتی ہے وہ ریجیکس کی ہے جس میں کیڑے ہو سکتے ہیں، اور حقیقت یہ ہے کہ مقدمات کی ترتیب اہمیت رکھتی ہے۔<blockquote><p>ذرا رکو...</blockquote><p>بہت ساری چیزیں ہیں جو ہم صفحہ کی اصل روٹنگ سے پہلے ہر درخواست پر کرتے ہیں:<p>ابتدائی طور پر ہم کلین اپ کوڈ ترتیب دیتے ہیں (کے ساتھ<code>defer:</code> ) کونسا<em> چاہئے</em> اس بات کو یقینی بنائیں کہ کوئی لیک نہ ہو۔<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>ہم چیک کرتے ہیں کہ آیا تھریڈ شروع کیا گیا ہے:<pre><code class="nim hljs">initThread()</code></pre><p>یہ واقعی صرف ایک بار چلنا چاہئے (یہ چیک کرنے کے لئے شروعات کے بعد ایک عالمی سطح کا تعین کرتا ہے)، اور درخواست ہینڈلر سے باہر کیا جا سکتا ہے۔ لیکن اصل میں ابتدا کیا ہے؟ ٹھیک ہے ... بہت ساری چیزیں! بنیادی طور پر ہم (ab) عالمی مستقل استعمال کرتے ہیں جن کے لیے ابتداء کی ضرورت ہوتی ہے، ان میں سے کچھ واقعی تھریڈ سے متعلق نہیں ہیں، کیونکہ وہ ڈھیر پر میموری کو شروع کرتے ہیں اور دھاگے میں مشترکہ ہوتے ہیں۔<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>پھر ہم پیرامیٹرز کو پارس کرتے ہیں۔<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>ہم پیرامیٹرز کس کے لیے استعمال کرتے ہیں؟ دی<code>ParamKey</code> enum قسم اس کی وضاحت کرتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>ہم کرتے ہیں<em> مائیکرو کیچنگ</em> درخواستوں کے لئے لہذا ہر درخواست کو ٹیپل کے مطابق کیش کیا جاتا ہے۔<code>(path, query, accetEncoding)</code> ، انکوڈنگ کی ضرورت ہے کیونکہ ہم دونوں (غیر) کمپریسڈ باڈیز کی خدمت کر سکتے ہیں۔ درخواست کا سیاق و سباق اس طرح لگتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>کی<code>key</code> فیلڈ کا استعمال صحیح کیشڈ پیج (باڈی) سے حاصل کرنے کے لیے کیا جاتا ہے۔<code>pageCache</code>. اس بات کو یقینی بنانے کے لیے لاک کی ضرورت ہوتی ہے کہ ایک ہی وقت میں ہونے والی متعدد درخواستیں رینڈرنگ جابز کی نقل نہ بنائیں (اگر کوئی اور درخواست پہلے ہی صفحہ تیار کر رہی ہے، تو اس کے ختم ہونے کا انتظار کریں)۔ ہر بنیاد<code>HttpRequestRef</code> chronos httpserver سے میں محفوظ کیا جاتا ہے<code>rq</code> میدان دی<code>params</code> پہلے ہی پچھلے سے تجزیہ کر رہے ہیں۔<code>handleParams</code>.<li><p>ہم کے ذریعے مواد کو حذف کرنے کی حمایت کرتے ہیں۔<code>d</code> param، جو ہمیں ایک سادہ HTTP حاصل کرنے کی درخواست کے ساتھ آرٹیکلز کو نیوکلیئر کرنے کی اجازت دیتا ہے (فلٹرنگ ناکام ہونے کی صورت میں، لیکن اسے عملی طور پر کبھی بھی استعمال نہیں کرنا چاہیے، صرف ڈیبگنگ کے لیے)۔ کسے دوسرے HTTP طریقوں کی ضرورت ہے؟ میں نہیں.<li><p>ہم کیشے صاف کرنے کی بھی حمایت کرتے ہیں۔ ہم یا تو صفحہ حذف کر سکتے ہیں،<code>c=0</code> یا تمام صفحات<code>c=1</code> . پریشان کن بٹس یہ ہے کہ ہمیں یہ چیک کرنا ہوگا کہ آیا راستہ یا تو مضمون، صفحہ، تصویر یا اثاثہ ہے، اور مناسب کیش ڈھانچہ کو صاف کرنا ہے۔ روٹر کے ساتھ یہاں کچھ واضح منطق کی نقل ہے، لیکن چونکہ یہ پری روٹنگ کی جاتی ہے، اس لیے اسے ایڈہاک ہونا چاہیے، صرف کیش صاف کرنے کے لیے متعلقہ معاملات کو ہینڈل کرنا۔ یہ پری روٹنگ کی جاتی ہے کیونکہ کیشے کو روٹنگ کے بغیر بھی پیش کیا جاتا ہے، کیونکہ اگر درخواست پہلے ہی تیار ہو چکی ہے، تو ہم صرف باڈی کے ساتھ جواب دے سکتے ہیں۔<code>respBody</code> فیلڈ (اور<code>respHeaders</code>, <code>respCode</code>).<li><p>کیشے کی کارروائیوں کو سنبھالنے کے بعد، ہم راستے کو پارس کرتے ہیں۔<li><p>اس کے بعد ایک اور ہائی جیکنگ جاری ہے:</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>یہ بھی روٹنگ سے پہلے کیوں کیا جاتا ہے؟ بطور ڈیفالٹ ہم جزوی طور پر ترجمہ شدہ صفحات پیش کرتے ہیں۔ ہم غریب ہیں :( اور ترجمے مفت خدمات پر مبنی ہیں، لیکن ہم غیر معمولی بوجھ کے اوقات کے متحمل نہیں ہو سکتے، اس لیے ہم ترجمے کو موخر کرتے ہوئے چلاتے ہیں جب کہ ہم ترجمہ شدہ صفحہ کو صرف ان ٹکڑوں کے ساتھ پیش کرتے ہیں جو ہمارے ترجمے کے ڈیٹا بیس میں محفوظ کیے گئے ہیں۔<p>اس مقام پر روٹنگ ہے، ایک استثناء میں لپٹی ہوئی ہے کہ اگر صحیح صفحہ پیش کرنا ناکام ہوجاتا ہے، تو ہم ایک جاری کرتے ہیں۔<code>503</code> . جاری کرنا a<code>503</code> اس کا مطلب یہ ہے کہ ہم نے ایک درست url کو روٹ کرنے کی کوشش کی لیکن ہم صفحہ نہیں بنا سکے۔ غلط یو آر ایل کے لیے ہم ایک جاری کرتے ہیں۔<code>301</code> ری ڈائریکٹ جس کا مطلب ہے کہ یو آر ایل درست نہیں ہے۔ ہم 11 مختلف قسم کے یو آر ایل پیش کرتے ہیں:<ul><li><p>ہوم پیج: تازہ ترین عنوانات سے مضامین کھینچتا ہے، تصادفی طور پر، ہم مقبولیت کی بنیاد پر کوئی چھانٹی نہیں کرتے ہیں۔<li><p>عام اثاثے (کے تحت<code>/assets/</code> path): ایک سرشار ڈائریکٹری میں براہ راست نقشہ بنایا گیا ہے۔<li><p>عام تصاویر (کے نیچے<code>/i/</code> pah): ہم اپنی ریسپانسیو ویب سائٹ کے مطابق سائز پیدا کرنے کے لیے بیرونی تصاویر کو پراکسی کرتے ہیں، جب تصاویر دستیاب نہ ہوں تو شفاف پکسل یا تصویری آئیکن بطور ڈیفالٹ پیش کیا جاتا ہے۔<li><p>robots.txt فائل<li><p>سائٹ کے نقشے (ہوم ​​پیج اور عنوانات اور صفحات کے لیے): ہوم پیج سائٹ میپ کی میزبانی کرتا ہے جو تمام عنوانات کے سائٹ کے نقشوں کی طرف اشارہ کرتا ہے، عنوانات کے سائٹ کے نقشے موضوع کے تمام صفحات کی طرف اشارہ کرتے ہیں، صفحات کا سائٹ کا نقشہ صفحہ کے تمام مضامین کی طرف اشارہ کرتا ہے۔<li><p>pwa manifest: pwa manifest کو ویب سائٹ کو pwa کے طور پر انسٹال کرنے کی اجازت دینی چاہیے (لیکن واضح طور پر اس کا تجربہ نہیں کیا ہے)<li><p>تلاشیں: تلاش کا فائدہ اٹھاتا ہے۔<a href=https://github.com/valeriansaliou/sonic> آواز</a> کے ساتہ<a href=https://github.com/alongwy/pysonic> pysonic</a> پابندیاں<li><p>تجاویز: تجاویز کو آواز کی لائبریریوں کے ذریعے بھی سنبھالا جاتا ہے۔ لیکن ان کی ضرورت ہے۔<li><p>فیڈز: سائٹ کے نقشوں کی طرح ہمارے پاس ہوم پیج اور مختلف عنوانات کے لیے مختلف فیڈز ہیں، حالانکہ واضح وجوہات کی بنا پر واحد صفحات کے لیے کوئی فیڈ نہیں ہے۔<li><p>موضوع کے صفحات: ہر عنوان کے لیے مختص صفحہ (مثلاً راستے کے ساتھ<code>domain.com/my-topic/</code> ) موضوع کے لیے شائع ہونے والے تازہ ترین مضامین کو کھینچتا ہے، جن کا تعلق ایک سے ہے۔<em> نامکمل</em> صفحہ<li><p>مضامین کے صفحات: مضمون کا صفحہ مضمون کا عنوان، تفصیل، ماخذ کا لنک، ٹیگز، اشاعت کا وقت (فوٹر میں) دکھاتا ہے اور نیچے ہم 3 متعلقہ مضامین کھینچتے ہیں۔ متعلقہ مضامین مضمون کے عنوان یا ٹیگز پر تلاش کے استفسار کا استعمال کرتے ہوئے حاصل کیے جاتے ہیں۔</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> رینڈرنگ کے بارے میں</a></h2><p>صفحہ رینڈرنگ کا استعمال کرتے ہوئے نیم طرف سے کارروائی کی جاتی ہے۔<a href=https://github.com/karaxnim/karax> کریکس</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> عام صفحہ کی ترتیب</a></h3><p>ویب سائٹ ایک ٹاپ فکسڈ بار پر مشتمل ہے جو ظاہر کرتی ہے:<ul><li><p>ہوم پیج یو آر ایل، لوگو ایس وی جی امیج کے ذریعے۔<li><p>لائٹ/ڈارک تھیم بٹن<li><p>موجودہ راستے کا استعمال کرتے ہوئے موجودہ یو آر ایل<em> ٹکڑے</em> بطور لنک متن<li><p>تازہ ترین ~10 عنوانات کے یو آر ایل<li><p>سرچ بار (سرچ بٹن کے ساتھ)، جہاں ٹائپ کرنے پر تجاویز پاپ اپ ہوجاتی ہیں۔<li><p>زبانوں کا بٹن، جہاں کلک کرنے پر، زبانوں کی فہرست اوپر آجاتی ہے۔</ul><p>چونکہ یہ ایک ریسپانسیو ڈیزائن ہے، جب ویو پورٹ چھوٹا ہوتا ہے، تو ٹاپ بار صرف سرچ باکس کو رکھتا ہے جبکہ باقی ٹوگل ایبل سائڈبار میں ظاہر ہوتا ہے۔<ul><li><p>فوٹر، سائٹ کا نقشہ، آر ایس ایس، سماجی، قانونی کے لیے لنکس رکھتا ہے۔<li><p>مختلف مقامات پر اشتہارات کی حمایت کی جاتی ہے۔</ul><h2 id=rss><a class=header-anchor href=#rss> آر ایس ایس</a></h2><p>یہ ایک مثالی فنکشن ہے، یہ ظاہر کرتا ہے کہ جب فیڈ کو اپ ڈیٹ کرنے کے لیے کوئی نئی پوسٹ شائع کی جاتی ہے تو ہم کیا کرتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> سائٹ کے نقشے</a></h2><p>یہ سائٹ کے نقشوں میں یو آر ایل کو شامل کرنے کا مرکز ہے:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> ٹیمپلیٹس</a></h2><p>ہم ٹیمپلیٹ انجن کا استعمال نہیں کرتے ہیں کیونکہ زیادہ تر رینڈرنگ کریکس کے ساتھ کی جاتی ہے، لیکن ToS جیسے صفحات کے لیے ہم فائل ٹیمپلیٹس کا استعمال کرتے ہیں، جہاں ہم صرف متغیرات کے ایک گروپ کو تبدیل کرتے ہیں، جیسے کہ<code>envsubst</code> کمانڈ.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> مضامین کے صفحات</a></h2><p>جب ہم ہوم/موضوعات اور نمبر والے صفحات جیسے صفحات پیش کرتے ہیں تو ہمیں مضامین کی فہرست دکھانی ہوتی ہے، اس فنکشن کو ایک لوپ میں کہا جاتا ہے کہ ہم کتنے مضامین دکھانا چاہتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>نوٹ کریں کہ کس طرح کچھ لائنوں میں "اشتہارات" X میں رینگتے ہیں)<h2 id=topics_list><a class=header-anchor href=#topics_list> عنوانات کی فہرست</a></h2><p>ٹاپ بار میں ہم عنوانات کی فہرست دکھاتے ہیں، یہ وہی ہے جو اسے پرنٹ کرتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>یہاں کچھ بدبودار سخت کوڈ شدہ میٹریل ڈیزائن کلاسز ہیں۔ سچ کہوں تو گوگل میٹریل ڈیزائن کے اجزاء چوستے ہیں۔<h2 id=post_footer><a class=header-anchor href=#post_footer> فوٹر پوسٹ کریں۔</a></h2><p>پوسٹ کا فوٹر مضمون کے صفحے کے نیچے دائیں طرف ظاہر ہوتا ہے (ltr میں) اور یہ واقعی صرف شائع شدہ تاریخ کو پرنٹ کرتا ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> اقتباسات</a></h2><p>مضمون کے اندراجات بناتے وقت ہمیں اقتباسات کی ضرورت پڑسکتی ہے اگر کوئی خلاصہ دستیاب نہ ہو۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>ڈبلیو ٹی ایف ہے۔<code>parseHtml</code> یہاں کر رہے ہو؟ یہ معاملہ ہے کہ ہم آرٹیکل کے مواد کے اندر html کی اجازت دیتے ہیں (لیکن صرف کچھ ٹیگز)، یہ python ماڈیول trafilatura کا ایک آپشن ہے، جسے ہم فعال رکھتے ہیں کیونکہ یہ مضمون کی شکل کو متاثر کر سکتا ہے۔ ہمیں utf-8 سٹرنگز کو چننے کے بارے میں بھی محتاط رہنا ہوگا...<h2 id=minification><a class=header-anchor href=#minification> Minification</a></h2><p>کریکس بنانے کے بعد آخری کام<code>VNode</code> درخت بائٹس کو پھینکنا ہے۔ درخت اگر HTML ہیڈر کے ساتھ سابقہ ​​لگا ہوا ہے، اور اختیاری طور پر چھوٹا ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>minification کی طرف سے سنبھالا ہے<a href=https://github.com/wilsonzlin/minify-html> minify-html</a> جسے ہم استعمال کرنے کے پابند ہیں۔<a href=https://github.com/nim-lang/c2nim> c2nim</a> بائنڈنگ فائل پر مشتمل ہے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>لیکن عمارت کے لیے ہمیں جامد لائبریریاں فراہم کرنی پڑتی ہیں، اس لائن کو اپنے میں شامل کرنا<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>میرا مطلب ہے... یہ میرا راستہ ہے جب میں نے منی فائی لائبریری بنائی تھی جو<em> btw</em> اصل میں ایک بیرونی c فنکشن نہیں ہے جو nim استعمال کر سکتا ہے، لہذا ہمیں اسے خود لکھنا پڑا۔<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> نمپی اور کریش فری کوڑے کو ڈیلیٹ کرنے کی جستجو</a></h1><p><a href=https://github.com/yglukhov/nimpy/> نم کے لیے ازگر کی پابندیاں</a> ازگر کی اشیاء کو آزادانہ طور پر ضائع کرنا ہوگا۔ مسئلہ یہ ہے کہ ہمیں کنٹرول کرنا پڑتا ہے جب نم جی سی کرتا ہے۔ nimpy لائبریری فرض کرتی ہے کہ GIL ہمیشہ بند رہتا ہے (یہ اسے شروع میں لاک کر دیتا ہے)، جب بھی ازگر کو کال کرنے کے لیے یہ آزاد ہے۔ لیکن ہم گل کو غیر مقفل کرتے ہیں تاکہ ایک ازگر کے تھریڈ پول کو کوڈ چلانے کی اجازت دی جا سکے جبکہ نم دوسری چیزیں چلاتا ہے۔ اگر python GIL کو ہمیشہ nim کے ذریعے لاک کیا جاتا ہے تو تھریڈ پول زیادہ تر وقت بیکار رہے گا۔<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>یہ اجازت دیتا ہے کہ جی آئی ایل کو پکڑے ہوئے ازگر کوڈ کو کیسے عمل میں لایا جائے، لیکن صرف موجودہ تھریڈ پر۔ مختلف نم دھاگوں پر GIL کو حاصل کرنے/جاری کرنے کے نفاذ کے لیے مختلف python C abi فنکشنز کو کال کرنے کی ضرورت ہوتی ہے، کیونکہ GIL ایک mutex ہے۔ پھر ہم اس ٹیمپلیٹ کا استعمال کرتے ہوئے python کو کال کرتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>ہم نم لاک اور گارڈز کی خصوصیت کا استعمال کرتے ہیں، اس بات کو یقینی بنانے کے لیے کہ ازگر کی اقسام تک رسائی صرف اس وقت ہوتی ہے جب GIL منعقد ہو۔ تاہم اس کے لیے گارڈ کے ساتھ پائی آبجیکٹ کی وضاحت کی ضرورت ہے:<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>تو میں کر سکتا ہوں:<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>اور جب بھی فون کرتا ہوں۔<code>myVar</code> جس میں ڈیٹ ٹائم آبجیکٹ ہے ، مجھے اسے اس طرح لپیٹنا ہوگا:<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>اب ہم گل کو لاک کر سکتے ہیں جب ہمیں جی سی چلانا ہے، نمپی کو اوور رائیڈ کر کے<code>PyObject</code> اس کے ساتھ تباہ کن:<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>ڈسٹرکٹر کے اندر جو تالا ہم استعمال کرتے ہیں وہ نہیں ہے۔<code>AsyncLock</code> جیسا کہ یہ بہت مہنگا ہوگا، اور ہم<em> مت کرو</em> ہمیشہ تالا لگا دیں، کیونکہ اس سے اسٹال لگ جائیں گے! اگر ہم گل کو لاک نہیں کر سکتے ہیں، تو ہم جمع کرنے میں تاخیر کرتے ہیں، اور کچے ازگر کے پوائنٹر کو اس وقت تک رکھتے ہیں جب ہم اسے صاف کر سکیں گے۔ سچ میں میں نہیں جانتا کہ آیا اس سے دیگر قسم کے مسائل پیدا ہوتے ہیں، لیکن ایسا لگتا ہے کہ یہ کام کرتا ہے۔<em> بہت بہتر</em>.<p>ہمارے پاس ایک نم ماڈیول ہے جسے کہتے ہیں۔<code>pyutils.nim</code> جو nim<>python کی چیزوں کا ایک گروپ کرتا ہے، مثال کے طور پر:<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>یہ ایک بہت زیادہ استعمال کیا جاتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>یہ اس وقت استعمال ہوتا ہے جب ہم نے python کے کام کو شیڈول کیا ہے، اور ہم اس کے متضاد طور پر ختم ہونے کا انتظار کرنا چاہتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>مناسب python async بائنڈنگ کے لئے python سے طے شدہ کام کے اختتام پر python سے nim async مستقبل کو مکمل کرنے کی ضرورت ہوگی، جو ہم نہیں کرتے کیونکہ ہم نے python سے نم اشیاء کو سنبھالنے میں کافی گہرائی سے نہیں دیکھا ہے۔<h2 id=ampification><a class=header-anchor href=#ampification> ایمپیفیکیشن</a></h2><p>ہم google amp کو سپورٹ کرتے ہیں، اس لیے ہم کسی حد تک amp کے مطابق amp صفحات تیار کرتے ہیں۔ ہمارا مقصد 1:1 کی حمایت نہیں ہے۔ درحقیقت ہم اپنے پاس موجود تمام جاوا اسکرپٹ کو نیوک کرتے ہیں اور صرف html/css پیش کرتے ہیں۔ پھر بھی ہمیں محتاط رہنا ہوگا کہ HTML ٹیگز میں حسب ضرورت خصوصیات شامل نہ کریں، یا صرف حسب ضرورت html ٹیگز، amp اس طرح برا ہے... خودکار amp صفحہ کی تبدیلی کے لیے ہم<code>head</code> اور<code>body</code> مختلف طریقے سے ٹیگ کریں.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>تمام شیلیوں کو ایک ہی ان لائن اسکرپٹ میں ضم کر دیا گیا ہے، جو رکھا گیا ہے وہ ہے۔<code>link</code> ٹیگز جو سٹائل/jscript نہیں ہیں، جیسے lang۔ کے لیے اسکرپٹ ٹیگز<code>ldljson</code>, <code>meta</code> ٹیگز لفظی طور پر نوڈس کو ہینڈل کرتا ہے۔<em> لفظی</em> ، ہمیں انہیں میں تبدیل کرنا ہوگا۔<code>XmlNode</code> (جس کا مطلب ہے تجزیہ کرنا) اور اسے صحیح طریقے سے ہینڈل کریں۔ پروسیس باڈی ایک جیسی ہے، ہم کچھ ٹیگ رکھتے ہیں، دوسروں کو ہٹاتے ہیں، دوسروں کا نام تبدیل کرتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>کی<code>form</code> ٹیگ کے ساتھ تبدیل کیا جاتا ہے<code>amp-form</code> ، amp میں ان میں سے بہت سے ٹیگ ہیں...<p>ہمیں اس بات کو یقینی بنانا ہوگا کہ ان لائن اسٹائل درست لمبائی کے اندر ہوں:<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>ہماری amp جنریشن مکمل amp اسپیک کا احاطہ نہیں کرتی ہے، لیکن یہ ہمارے مواد کے لیے کام کرتی ہے (آزمائشی اور غلطی کے ذریعے: S)۔<h2 id=search><a class=header-anchor href=#search> تلاش کریں۔</a></h2><p>جب بھی کوئی مضمون شائع ہوتا ہے، اسے سونک ڈیٹا بیس میں داخل کیا جاتا ہے، سونک ڈیٹا بیس "مجموعہ"، "بالٹیاں" اور "آبجیکٹس" کو ہینڈل کرتا ہے۔ ہم ایک مجموعہ کو ایک ویب سائٹ کے طور پر بیان کرتے ہیں، لہذا ہر وہ ویب سائٹ جو مواد جمع کرنے والے کو تعینات کرنا چاہتی ہے اس کا اپنا مجموعہ ہوتا ہے۔ ہم استعمال نہیں کرتے<code>buckets</code> اگرچہ ہم ہر موضوع کو ایک بالٹی سمجھ سکتے ہیں جو تلاش کو بہت زیادہ تنگ کر دے گا، اس لیے ہر سائٹ میں صرف ایک بالٹی "ڈیفالٹ" ہوتی ہے، اور بالٹی کا ہر شے ایک مضمون ہے (جو مختلف عنوانات کا ہو سکتا ہے)۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>مواد کو آواز میں دھکیلتے وقت ہمیں ڈیٹا کو ٹکڑوں میں تقسیم کرنا پڑتا ہے، جس کی زیادہ سے زیادہ لمبائی کنکشن پر معلوم ہوتی ہے۔ ڈیٹا کو ہضم کرنا بعض اوقات چھوٹی سی لگتی ہے، کیونکہ ایسا لگتا ہے کہ یہ کچھ مخصوص حروف کو ہینڈل کرنے کے قابل نہیں ہے۔ اگر سونک سرور کسی طرح ٹوٹ جاتا ہے، تو ہمارے پاس تمام مواد کو دوبارہ جوڑنے کا فنکشن بھی ہے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> ترجمہ</a></h2><p>ترجمہ کافی گندی کہانی ہے۔ میں ترجمہ ریپر کے اپنے چوتھے (!) نفاذ پر ہوں، php میں لکھنے کے بعد، جاؤ اور<a href=https://github.com/untoreh/Translator.jl> جولیا</a> یہ بھی نم میں لکھا ہے۔ پی ایچ پی/گو ویریئنٹس آج کل تھوڑا سا بوسیدہ ہیں، جب کہ جولیا ویرینٹ اس بلاگ کے لیے فعال طور پر استعمال ہوتا ہے۔ تاہم ویب سرور کے لیے کم تاخیر کو حاصل کرنے کے لیے، جولیا میں جس طرح سے ترجمہ کو لاگو کیا گیا ہے وہ حقیقی وقت کی خدمت کے لیے موزوں نہیں ہے (یہ جامد فائلوں کا ترجمہ کرتا ہے)، اور ویسے بھی جولیا کو انحصار کے طور پر شامل کرنا ایک بار جب ہمارے پاس پہلے سے ہی ازگر ہو جائے گا تو یہ بہت بڑا ہوگا۔ ضرورت<p>لہذا مجھے نم میں ایک نیا ترجمہ ماڈیول نافذ کرنا پڑا۔ سچ میں، ابتدائی نِم ترجمہ ماڈیول کافی حد تک جولیا کے نفاذ کی طرح لگتا تھا، جہاں ہم جامد فائلوں کا ترجمہ کر رہے تھے۔<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . اس کے بعد، جب ویب سرور نے شکل اختیار کرنا شروع کی، تو میں نے مطالبہ پر کریکس نوڈس کا ترجمہ کرنے کے لیے اسے تبدیل کیا۔ یہ ہر ویب صفحہ کو درخواست کے وقت پر ترجمہ کرنے کی اجازت دیتا ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>اوپر مرکزی تکرار لوپ ہے۔<code>translateIter</code>:<ul><li><p><code>getTforms</code> نقشہ جات کو ایچ ٹی ایم ایل ٹیگز پر بناتا ہے، جس سے کیس کی بنیاد پر اتپریورتنوں کو انجام دینے کی اجازت ملتی ہے۔<li><p><code>rewriteUrl</code> lang پاتھ داخل کرتا ہے (جیسے<code>/en/</code> ) یو آر ایل کے راستے میں۔<li><p><code>translateVbtm</code> لفظی نوڈس کو ہینڈل کریں جن کو پارس کرنے کی ضرورت ہوتی ہے۔</ul><p>ترجمہ تمام ٹیکسٹ نوڈس اور پر لاگو ہوتا ہے۔<code>alt</code> اور<code>title</code> صفات<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>کیونکہ ہمیں ہر ٹیکسٹ نوڈ کا الگ الگ ترجمہ کرنا ہوتا ہے (ورنہ ہم HTML کو واپس نہیں کر سکتے) ہر نوڈ کا ترجمہ الگ الگ کام ہے۔ چونکہ جابز نیٹ کی ترجمے کی خدمات سے استفسار کر سکتی ہیں، اس لیے انہیں متضاد طور پر کرنا پڑتا ہے۔ ہم اے پی آئی کالز کو بچانے کے لیے ترجمے کے سوالات کی تقسیم اور انضمام کرتے ہیں، لیکن ترجمے کے انجن کے اندرونی حصوں کو جاننا اہم نہیں ہے۔ نوٹ کرنے کی بات صرف یہ ہے کہ شروع میں میں استعمال کر رہا تھا۔<a href=https://github.com/nidhaloff/deep-translator> ازگر کی چادر</a> (جسے میں اب بھی سکریپڈ مواد کا ترجمہ کرنے کے لیے استعمال کرتا ہوں) کیونکہ بیرونی ایپس کے لیے ریپرز کا خود انتظام کرنا ایک تکلیف دہ ہے، لیکن پھر نم میں سیلف ریپڈ گوگل اور یانڈیکس ٹرانسلیشن سروس میں تبدیل ہو گیا، کیونکہ python بہت سے ہم آہنگ تراجم کو سنبھالتے وقت کافی حد تک رکاوٹ بن جاتا ہے۔<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>درحقیقت اصل میں مواد جمع کرنے والے کو صرف جامد فائلیں تیار کرنی تھیں۔<code>caddy</code> پیش کرنے کے لیے، لیکن چونکہ صفحات کی مقدار جنریٹ کرنے کے لیے ہے (جو کہ n_lang(20) x amp(2) x صفحہ کا میٹرکس ہے)، سست رینڈرنگ بہتر آپشن تھا۔</table><h2 id=stats><a class=header-anchor href=#stats> اعدادوشمار</a></h2><p>موضوع اور مضمون کے صفحات کو ہٹ شمار کے لیے ٹریک کیا جاتا ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>ہم وقتاً فوقتاً کم گنتی والے صفحات کو صاف کرنے کے لیے ہٹ کاؤنٹ استعمال کرتے ہیں۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> ڈیٹا بیس</a></h2><p>ہم استعمال کرتے ہیں<code>libmdbx</code> کے ذریعے<a href=https://github.com/snej/nimdbx> یہ lib</a> . شاید زیادہ کِل ہے، اور لیول ڈی بی کا استعمال کافی ہوتا۔ ہمارے پاس ایک قسم ہے۔<code>LRUTrans</code> جہاں ابتدائی خیال ڈیٹا بیس کو LRU کیشے کے طور پر ترتیب دینا تھا، لیکن یہ کافی سست تھا۔ عمل درآمد پایا جا سکتا ہے۔<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> یہاں</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>یہ قسم چار الگ الگ ڈیٹا بیس کے لیے استعمال ہوتی ہے۔<ul><li><p>ترجمے<li><p>صفحہ کیشے<li><p>تصاویر کیشے<li><p>اعدادوشمار</ul><p>ڈیٹا بیس کی قسم کو گیٹرز اور سیٹرز کے ساتھ لاگو کیا جاتا ہے پھر پڑھنے/لکھنے پر خودکار ڈی/کمپریشن کرتے ہیں۔ اس وجہ سے اسے تصاویر کے لیے استعمال نہیں کیا جانا چاہیے...لیکن افسوس... چھوٹے مائیکرو کیشز کا ایک گروپ بھی ہے:<ul><li><p>vbtm: تجزیہ شدہ (لفظی) مواد کے لیے<li><p>تلاش کریں: تلاش کے سوالات کے لیے<li><p>فیڈز: ٹاپک فیڈز VNodes کے لیے<li><p>rxcache: regex کے لیے، کیونکہ کمپائل ٹائم سٹیٹک ریجیکس ابھی تک معیاری نہیں ہوئے ہیں (اس لیے بھی کہ نم میں متعدد ریجیکس لائبریریاں موجود ہیں)</ul><p>یہ اس طرح لاگو ہوتے ہیں۔<a href=https://github.com/jackhftang/lrucache.nim> lru caches</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> ، زیادہ واضح طور پر "لاک" ایل آر یو کیچز کے طور پر، جہاں ہر گیٹ اور سیٹ آپریشن کو (تھریڈ) لاک کے گرد لپیٹا جاتا ہے۔ یہ تالے async رن ٹائم کے ساتھ اسٹالز کا سبب نہیں بن سکتے کیونکہ لاک کو حاصل کیا جاتا ہے اور بغیر کسی پیداوار کے بیان کے جاری کیا جاتا ہے، اس لیے وہ اس لحاظ سے ایٹم ہیں، تاہم یہ اب بھی کارآمد ہیں کیونکہ ہم مختلف کاموں کے لیے تھریڈز کا استعمال کرتے ہیں۔<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>البتہ<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> نیم کا سٹو</a> lru کیشے کے لئے ایک آسان عمل درآمد ہے جسے میں اگر جلد مل جاتا تو استعمال کرتا۔</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> پس منظر کی نوکریاں</a></h1><p>کچھ کام جو ہم استعمال کرتے ہیں وہ CPU بھوکے ہیں، لہذا ہم ان کے لیے ایک مختلف تھریڈ استعمال کرتے ہیں:<ul><li><p>lsh: locality sensitive hashing بہت زیادہ حساب کتاب کرتا ہے۔<li><p>امیجز: امیج ریائز کرنے کے لیے تصاویر کو ڈی کوڈنگ/انکوڈنگ کی ضرورت ہوتی ہے لہذا یہ مہنگا ہے۔</ul><p>اثاثوں کی فائلوں کی فہرست اور اشتہارات کو اپ ڈیٹ کرنے کے لیے دو مزید تھریڈز استعمال کیے جاتے ہیں، حالانکہ سی پی یو بھوکا نہیں ہے، فائل واچر کی وجہ سے اسٹالز سے بچنے کے لیے ایک تھریڈ کی ضرورت ہوتی ہے۔<p>ہمارے پاس async طویل چلنے والے کام بھی ہیں:<ul><li><p>ترجمے<li><p>HTTP درخواستیں۔</ul><p>Lsh، تصاویر، ترجمہ اور HTTP درخواستوں کی نوکریوں کو پروڈیوسر/کنزیومر سیٹ اپ کا استعمال کرتے ہوئے ہینڈل کیا جاتا ہے۔ سوائے اس کے کہ ہم چینلز کا استعمال نہیں کرتے ہیں، کیونکہ چینلز بلاک ہوتے ہیں اور ہمارے پاس ان کا کوئی async نفاذ نہیں ہے جو تھریڈ سیف بھی ہے۔ ہم نے async کے نفاذ کا استعمال کیا۔<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> یہ</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . اور ایک async ٹیبل، جو ایک ایونٹ بس کی طرح ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>نم سرور تین async کاموں کو بھی سنبھالتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>کنٹینرائزڈ پروسیس اور ڈوکر کے درمیان OOM کے مسائل سے بچنے کے لیے میم کے استعمال پر نظر رکھنے والا کام اچھا ہے، کیونکہ ڈوکر (یا کرنل) اس عمل کو فوری طور پر ختم نہیں کرتا، اور اس مدت میں سرور غیر جوابدہ ہو سکتا ہے، لہذا فوری طور پر دستی طور پر دوبارہ شروع کرنا بہتر ہے۔<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>اگرچہ async معمولات میں ایک سادہ چینل کو لپیٹنا شاید بہتر ہے...افسوس</table><h1 id=images><a class=header-anchor href=#images> امیجز</a></h1><p>ہم فائدہ اٹھاتے ہیں۔<a href=https://github.com/imazen/imageflow/releases> امیج فلو</a> مقامی طور پر تصاویر کا سائز تبدیل کرنے اور کیش کرنے کے لیے۔ پابندیاں آسان ہیں، لیکن عمل تھوڑا سا شامل ہے۔ کے ساتھ<code>getImg</code> ہم ریموٹ یو آر ایل سے تصویری ڈیٹا لاتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>پھر ہمیں اسے امیج فلو سیاق و سباق میں شامل کرنا ہوگا:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>اگر تصویر کو شامل نہیں کیا جا سکتا، تو اس کا مطلب ہے کہ امیج فلو ڈیٹا کو درست تصویر کے طور پر تسلیم کرنے میں ناکام رہا۔ ڈیٹا بھیجنے کے بعد، ہمیں سیاق و سباق میں ایک سوال بھیجنا ہوگا، پھر جواب پڑھنا ہوگا، اور آؤٹ پٹ حاصل کرنا ہوگا:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>ہمیں جواب سے mime کی قسم ملتی ہے، جو ویب سرور کے جواب میں آگے بھیجی جائے گی۔ سرور کی طرف سے یو آر ایل پاتھ سے امیج فلو کا ترجمہ اس طرح کیا جاتا ہے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>تصویر کا url zstd کمپریسڈ شکل میں ایک پیرامیٹرز کے طور پر بھیجا جاتا ہے۔ کمپریشن یو آر ایل کو مختصر کرتا ہے (زیادہ تر اوقات)۔ اس طرح مجھے گوگل کروم میں ایک بگ ملا، جہاں یہ یو آر ایل کو ہینڈل نہیں کرسکتا تھا جہاں استفسار میں یو آر ایل انکوڈ شدہ کمپریسڈ ڈیٹا تھا۔ فائر فاکس اس کے بجائے ٹھیک تھا۔<h2 id=ld-json><a class=header-anchor href=#ld-json> LD-JSON</a></h2><p>ہم ہر ویب پیج پر ldjson اسکرپٹ شامل کرتے ہیں۔<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>اور ترجمہ شدہ صفحات کے لیے:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> اوپن گراف</a></h2><p>ldjson کی طرح، ہم اوپن گراف میٹا ٹیگز بھی فراہم کرتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>اس تمام بوائلر پلیٹ ہیوی کوڈ سے نمٹنے کے دوران نم میکرو اور ٹیمپلیٹس کام آتے ہیں۔<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> سرور سائیڈ HTTP درخواستیں۔</a></h2><p>ایک اور کام ہے، جو ویب سرور کی طرف سے تمام HTTP درخواستوں (تصاویر، اسکرپٹ وغیرہ لانے کے لیے) کو ہینڈل کرتا ہے۔ ہم chronos httpclient استعمال کرتے ہیں:<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>مجھے شامل کرنا پڑا<a href=https://github.com/untoreh/nim-chronos/tree/update> https اور socks5 پراکسیوں کے لیے سپورٹ</a> ترجمے کو مؤثر طریقے سے استعمال کرنے کے قابل ہونے کے لیے httpکلائنٹ کو۔<h1 id=config><a class=header-anchor href=#config> ترتیب</a></h1><p>آپ نے پورے کوڈ میں بڑے متغیرات کو دیکھا ہوگا۔ یہ سب کنفگ متغیر ہیں، جو ایک فائل میں بیان کیے گئے ہیں، جنہیں فی ویب سائٹ اپنی مرضی کے مطابق بنایا جا سکتا ہے۔<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> نتیجہ</a></h1><p>ایسی بہت سی چیزیں ہیں جن کا میں نے ذکر نہیں کیا ہے، چونکہ شیطان تفصیلات میں ہے... تاہم یہ پورے کوڈ بیس کا کچا دورہ ہے جس کی مقدار یہ ہے:<ul><li><p>~ 12k نم کی لائنیں۔<li><p>js کی ~400 لائنیں<li><p>scss کی 1000 لائنیں۔<li><p>ازگر کی ~ 3500 لائنیں۔<li><p>74 lines of rust (for bindings :P)</ul><p>میں مختلف طریقے سے کیا کروں گا؟<ul><li><p>شاید پوری چیز کو زنگ میں دوبارہ لکھیں، nim فی الحال میموری کی حفاظت کو اچھی طرح سے نہیں سنبھالتا ہے، اور کریشوں کو ٹھیک کرنے کے لیے مجھے gdb پر بھروسہ کرنے کا وقت بہت زیادہ تھا، اور میں ان سب کو ٹھیک کرنے میں بھی کامیاب نہیں ہوا۔ یہ ایک بڑا مسئلہ ہے جب آدھا ماحولیاتی نظام GC پر اور باقی آدھا ORC پر انحصار کرتا ہے (یا یہاں تک کہ orc اور صرف ARC نہیں)۔ async اور دھاگوں کا اختلاط بھی تکلیف دہ ہے اور async stacktraces ایک ڈراؤنا خواب ہے، (حالانکہ میں نہیں جانتا کہ اس سلسلے میں زنگ زیادہ بہتر ہے یا نہیں۔)<li><p>ہدف a<a href=https://en.wikipedia.org/wiki/Progressive_web_app> پی ڈبلیو اے</a> گیگو سے اس منصوبے کا آغاز کافی مشکل تھا۔ شروع میں یہ ایک ویب سرور کے ذریعہ پیش کردہ جامد صفحات ہونا چاہئے تھا، پھر یہ خود ایک ویب سرور بن گیا۔ انٹرایکٹیویٹی ایک سوچنے کے بعد آئی، لہذا یہ صرف پیش کردہ html پلس js/css کا مرکب بن گیا۔ اس نے مجھے API پر بہت سست بنا دیا، جو بغیر کسی ڈھانچے کے سامنے آیا (مکمل طور پر<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> بے چین</a> )۔ دوبارہ لکھنے میں میں ایک UI فریم ورک استعمال کروں گا۔<a href=https://preactjs.com/> preact</a> جس میں مکمل AMP سپورٹ ہے، یا<a href=https://www.solidjs.com/> solidjs</a>.<li><p>مقبول پلیٹ فارمز کے لیے مزید ایڈہاک پارسر شامل کریں۔ سادہ آرٹیکل پارس کرنا اچھی طرح سے کام نہیں کرتا (یا بالکل بھی) جب آج کل سب سے زیادہ مقبول پلیٹ فارم بہت کم مواد، اور بہت ساری ویڈیوز اور تصاویر پیش کرتے ہیں، اس لیے سکریپنگ کو صرف ٹیکسٹ کے بجائے بھرپور میڈیا کو زیادہ نشانہ بنایا جانا چاہیے، اگر ایسا نہیں ہے۔ سکریپر آرکیٹیکچر کی منصوبہ بندی کرتے وقت اس کا حساب لیا جاتا ہے، APP جو مواد اور معلومات پیش کرے گی وہ غیر متوازن ہو گی۔</ul><div id=post-tags-list>پوسٹ ٹیگز: <span class=post-tag><a href=https://www.unto.re/tag/apps> ایپس</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> پروگرامنگ</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> سافٹ ویئر</a></span></div><div class=page-foot><div class=copyright>11 دسمبر 2022</div><script async crossorigin=anonymous issue-term=pathname label=Comment repo=untoreh/untoreh.github.io src=https://utteranc.es/client.js></script></div></div><div class=page__footer><footer><div class=page__footer-copyright>© untoreh - کی طرف سے طاقت<a href=https://github.com/tlienart/Franklin.jl> فرینکلن</a></div><div class=page__footer-links>- <ul><li><a href=/ur/sitemapxml> سائٹ کا نقشہ</a></li> | <li><a href=/ur/tag> ٹیگز۔</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> آر ایس ایس</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></footer></div><script crossorigin=anonymous defer id=fa integrity=sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH src=https://use.fontawesome.com/releases/v5.8.2/js/all.js></script><script src=/libs/colors.js></script><script src=/libs/menu.js></script><script defer src=/libs/lunr/lunr.min.js></script>