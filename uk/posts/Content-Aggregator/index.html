<!doctypehtml><html prefix="og: https://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"lang=uk><meta charset=UTF-8><meta content=width=device-width,initial-scale=1 name=viewport><link href=https://www.unto.re/uk/posts/Content-Aggregator/ rel=canonical><link href=https://www.unto.re/de/posts/Content-Aggregator hreflang=de rel=alternate><link href=https://www.unto.re/it/posts/Content-Aggregator hreflang=it rel=alternate><link href=https://www.unto.re/zh/posts/Content-Aggregator hreflang=zh rel=alternate><link href=https://www.unto.re/es/posts/Content-Aggregator hreflang=es rel=alternate><link href=https://www.unto.re/hi/posts/Content-Aggregator hreflang=hi rel=alternate><link href=https://www.unto.re/ar/posts/Content-Aggregator hreflang=ar rel=alternate><link href=https://www.unto.re/pt/posts/Content-Aggregator hreflang=pt rel=alternate><link href=https://www.unto.re/bn/posts/Content-Aggregator hreflang=bn rel=alternate><link href=https://www.unto.re/ru/posts/Content-Aggregator hreflang=ru rel=alternate><link href=https://www.unto.re/ja/posts/Content-Aggregator hreflang=ja rel=alternate><link href=https://www.unto.re/pa/posts/Content-Aggregator hreflang=pa rel=alternate><link href=https://www.unto.re/jw/posts/Content-Aggregator hreflang=jw rel=alternate><link href=https://www.unto.re/vi/posts/Content-Aggregator hreflang=vi rel=alternate><link href=https://www.unto.re/fr/posts/Content-Aggregator hreflang=fr rel=alternate><link href=https://www.unto.re/ur/posts/Content-Aggregator hreflang=ur rel=alternate><link href=https://www.unto.re/tr/posts/Content-Aggregator hreflang=tr rel=alternate><link href=https://www.unto.re/pl/posts/Content-Aggregator hreflang=pl rel=alternate><link href=https://www.unto.re/uk/posts/Content-Aggregator hreflang=uk rel=alternate><link href=https://www.unto.re/nl/posts/Content-Aggregator hreflang=nl rel=alternate><link href=https://www.unto.re/el/posts/Content-Aggregator hreflang=el rel=alternate><link href=https://www.unto.re/sv/posts/Content-Aggregator hreflang=sv rel=alternate><link href=https://www.unto.re/zu/posts/Content-Aggregator hreflang=zu rel=alternate><link href=https://www.unto.re/ro/posts/Content-Aggregator hreflang=ro rel=alternate><link href=https://www.unto.re/ms/posts/Content-Aggregator hreflang=ms rel=alternate><link href=https://www.unto.re/ko/posts/Content-Aggregator hreflang=ko rel=alternate><link href=https://www.unto.re/th/posts/Content-Aggregator hreflang=th rel=alternate><link href=https://www.unto.re/tl/posts/Content-Aggregator hreflang=tl rel=alternate><link title="сайт undoreh"href=https://www.unto.re/feed.xml rel=alternate type=application/rss+xml><link href=https://www.unto.re/amp/uk/posts/Content-Aggregator/ rel=amphtml><meta content="Building a content aggregator for fun and profits?"property=og:title><meta content=article property=og:type><meta content=https://www.unto.re/posts/Content-Aggregator property=og:url><meta content=https://www.unto.re/assets/appa.webp property=og:image><meta content="A full app that scrapes, processes and presents content from the web...on the web."property=og:description><meta content="untoreh's site"property=og:site_name><meta content=en_US property=og:locale><meta content=summary name=twitter:card><meta content=@untoreh name=twitter:creator><script type=application/ld+json>{"copyrightHolder":"untoreh","@id":"https://www.unto.re","url":"https://www.unto.re","copyrightYear":2023,"@context":"https://schema.org/","image":"/assets/appa.webp","@type":"WebSite"}</script><script id=ldj-webpage type=application/ld+json>{"audience":"cool people","url":"https://www.unto.re/posts/Content-Aggregator/index.html","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"accessibilitySummary":"Visual elements are tentatively described.","description":"A full app that scrapes, processes and presents content from the web...on the web.","author":{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"},"mentions":[],"@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"2022-12-11","dateCreated":"December 11, 2022","@id":"https://www.unto.re/posts/Content-Aggregator/index.html","dateModified":"2022-12-11","availableLanguage":[{"name":"English","@type":"Language"},{"name":"German","@type":"Language"},{"name":"Italian","@type":"Language"},{"name":"Mandarin Chinese","@type":"Language"},{"name":"Spanish","@type":"Language"},{"name":"Hindi","@type":"Language"},{"name":"Arabic","@type":"Language"},{"name":"Portuguese","@type":"Language"},{"name":"Bengali","@type":"Language"},{"name":"Russian","@type":"Language"},{"name":"Japanese","@type":"Language"},{"name":"Punjabi","@type":"Language"},{"name":"Javanese","@type":"Language"},{"name":"Vietnamese","@type":"Language"},{"name":"French","@type":"Language"},{"name":"Urdu","@type":"Language"},{"name":"Turkish","@type":"Language"},{"name":"Polish","@type":"Language"},{"name":"Ukranian","@type":"Language"},{"name":"Dutch","@type":"Language"},{"name":"Greek","@type":"Language"},{"name":"Swedish","@type":"Language"},{"name":"Zulu","@type":"Language"},{"name":"Romanian","@type":"Language"},{"name":"Malay","@type":"Language"},{"name":"Korean","@type":"Language"},{"name":"Thai","@type":"Language"},{"name":"Filipino","@type":"Language"}],"keywords":["apps","programming","software"],"creativeWorkStatus":"Published","publisher":{"url":"https://www.unto.re","sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"contactPoint":{"contactType":"info","email":"contact@unto.re","@type":"ContactPoint","telephone":""},"logo":"/assets/appa-60px.png","name":"untoreh's site","@type":"Organization"},"datePublished":"2022-12-11","inLanguage":"English","image":"/assets/appa.webp","name":"","mainEntityOfPage":{"@id":"https://www.unto.re/posts/Content-Aggregator/index.html","@type":"Article"}}</script><script id=ldj-breadcrumbs type=application/ld+json>{"itemListElement":[{"position":1,"item":"https://www.unto.re","name":"Home","@type":"ListItem"},{"position":2,"item":"/posts/","name":"Posts List","@type":"ListItem"},{"position":3,"item":"https://www.unto.re/posts/Content-Aggregator","name":"Building a content aggregator for fun and profits?","@type":"ListItem"}],"@type":"BreadcrumbList"}</script><link href=/libs/highlight/github.min.css rel=stylesheet><style>:root{--block-background:var(--accent2);--small:14px;--normal:19px;--text-color:hsv(0, 0%, 20%)}.franklin-content{position:relative;padding-left:12.5%;padding-right:12.5%;line-height:1.35em}@media (min-width:940px){.franklin-content{width:705px;margin-left:auto;margin-right:auto}}@media (max-width:480px){.franklin-content{padding-left:6%;padding-right:6%}}.franklin-content h2{font-size:22px}h2{text-align:left}.franklin-content h2{padding-bottom:.3em;border-bottom:1px solid #d3d3d3;margin-top:2em;margin-bottom:1em}.franklin-content h2 a{color:inherit}.franklin-content a{color:var(--alt2);text-decoration:none}body{counter-reset:eqnum}code{background-color:var(--block-background);padding:.1em .2em;border-radius:2px;font-size:var(--small);overflow:auto}@media (prefers-color-scheme:light){body{--accent:#3152ff;--accent2:#5a61ae;--accent3:#651b00;--alt:#ae6600;--alt2:#9e6c47;--alt3:#7f4200;--background-color:#ffebee;--foreground-color:#1c0005;--block-background:#423833;--red:#e42a2f;--yellow:#917329;--green:#29892d}}@media (prefers-color-scheme:dark){body{--accent:#72e200;--accent2:#add3a0;--accent3:#7a9eff;--alt:#8abeff;--alt2:#836bd1;--alt3:#a090de;--background-color:#001d49;--foreground-color:#dae2ff;--block-background:#011627;--red:#e42a2f;--yellow:#917329;--green:#29892d}}body{background:var(--background-color);font-style:var(--accent);font-family:Helvetica;padding:0 .5rem;line-height:2rem;color:var(--accent3);max-width:1280px;min-height:720px;margin:auto;min-width:320px}a{color:var(--accent)}a:visited{color:var(--accent2)}.franklin-content{color:var(--foreground-color)}.franklin-content .header-anchor{padding:.5rem!important;line-height:100%}.franklin-content a{outline-style:outset;outline-width:1px;padding:0 .1rem;margin:0 .1rem;outline-color:var(--alt2)}body>div>h1{text-align:center;color:var(--accent2)}body>div #page-description,body>div #title{text-align:center}.masthead__menu{height:4rem;line-height:4rem;padding:10px 0;position:relative}.site-title{float:left;font-weight:700;width:15rem;font-size:1.5rem;text-decoration:none;color:var(--accent)}.site-title:visited{color:var(--accent)}#site-nav{float:right;font-size:1.5rem;font-family:Courier New;font-weight:700;position:absolute;right:0}#site-nav .horiz ul{list-style-type:none;line-height:4rem;height:4rem;margin:0}#site-nav .horiz ul>li{padding:0 .5rem;box-shadow:.25rem -.025rem .05rem var(--alt)}#site-nav .horiz ul>li{float:left;border-top:0;border-bottom:0;border-left:0;border-radius:50% 25% 25% 50%}#site-nav ul>li>a,#site-nav ul>li>button{color:var(--alt);display:inline-block}#site-nav .menu-icons{position:relative;padding:0 .2rem}#site-nav{display:block;width:auto;height:auto}.author__avatar>img{width:4em;height:4em;border-radius:50%;-o-object-fit:cover;object-fit:cover;border-width:.1rem;border-color:var(--accent3);border-style:solid;box-shadow:.1rem .06rem var(--accent3),-.05rem -.025rem .2rem var(--accent3)}#site-nav a:link{text-decoration:none}#site-nav .ham,#site-nav .vert{display:none}.author__avatar{-o-object-fit:contain;object-fit:contain;float:left}.author__wrap>ul{float:left;height:inherit;margin:0;padding:0 10px}.author__wrap>ul>li{position:relative;float:left;list-style-type:none;font-size:1rem;padding:0 .2rem;text-align:center}ul>li.author__urls{font-size:2rem}ul>li.author__urls a:visited{color:var(--accent)}.author__wrap .author__avatar{float:left}.langs-dropdown-content{display:none;text-align:left}.langs-dropdown-content a{display:block}.menu-lang-btn:before{border-radius:25% 25% 25% 50%!important}.lang-link .flag{position:absolute;left:1rem;margin-top:.65rem}#site-nav .langs-dropdown-menu{left:1.5rem;position:relative;top:1rem}#site-nav .langs-dropdown-menu .lang-list{font-size:1rem;line-height:2rem;overflow-x:hidden;height:20rem;position:absolute;overflow-y:scroll;right:1rem;scrollbar-width:thin;border:solid;border-radius:25%;border-width:0 0 0 .25rem;padding-left:3rem}.lang-list{background-color:var(--background-color)}#site-nav ul>li>button{background:inherit;border:inherit;font-size:inherit;font-family:inherit;font-weight:inherit;padding:inherit;margin:inherit;list-style-type:inherit;line-height:inherit;height:inherit}.franklin-content{padding:0 0 2rem;z-index:0}.franklin-content{padding-top:1rem}.lunrSearchForm{margin-right:-.4rem;font-size:0;overflow:hidden}.lunrSearchForm .search-input{background:var(--background-color);color:var(--alt);border-width:.2rem;border:none;outline:0;border-radius:50% 25% 25% 50%;line-height:1.75rem;padding:.5rem 0 .5rem 2.25rem;width:7rem;position:relative;top:.5rem;font-family:Courier New;font-weight:700;font-size:1.5rem}.lunrSearchForm .search-button{color:var(--alt);background:0 0;border:none;font-size:1.5rem;padding:.2rem .2rem .2rem 0;position:absolute;top:1rem;left:.75rem;z-index:1}@media (min-width:680px) and (max-width:1300px){.lunrSearchForm .search-input{font-size:1rem;padding-left:2.75rem;width:4.5rem;border-radius:50% 100% 100% 50%}body{max-width:640px;min-height:320px}#site-nav{position:relative;z-index:1}#site-nav .ham{outline:0}#site-nav .ham,#site-nav .ham-icon{display:block;height:3rem;line-height:3rem;position:absolute;right:0;top:0;text-align:right;background:0 0;border:none;font-size:3rem;color:var(--accent)}#site-nav .horiz{display:none}#site-nav .vert{display:block;float:none;position:absolute;right:0;top:3rem;width:9rem;padding-left:1rem;max-height:0;overflow:hidden;filter:blur(1rem)}#site-nav .vert ul{margin:0;padding:10px 0}#site-nav .vert ul>li{width:100%;text-align:center;border-radius:25% 50% 50% 25%;padding:.5rem 1rem;box-shadow:-.25rem 0 .05rem var(--alt)}}@media (max-width:680px){.lang-link{height:3rem}.lunrSearchForm{display:block;width:28rem}.lunrSearch{position:absolute;top:-4rem;display:block;left:0;width:calc(2rem + 90%)}.lunrSearch .search-input{width:26rem}.masthead,.masthead__menu{display:block}.site-title{float:none;width:100%;display:block;text-align:center}.author__wrap{float:none;display:block;width:100%;height:4.4rem;text-align:center}.author__wrap ul{width:auto;float:none;padding:0;display:inline-block}#site-nav{float:none;padding:10px 0;position:relative;top:4rem}#site-nav ul li{float:none}.horiz{text-align:center}#site-nav ul{display:inline-block;padding:0}.masthead{height:14rem}}.lunrSearchForm{margin-top:1em}@media (max-width:480px){.lunrSearchForm .search-input{width:18rem;left:-4rem}.masthead{height:34rem}#site-nav{top:5rem}#site-nav .horiz ul{width:100%}#site-nav .horiz ul>li{width:calc(100% - 2rem);float:none}}@media (min-width:480px) and (max-width:680px){.masthead{height:20rem}}@media (max-width:680px){body{overflow-x:hidden}#site-nav{z-index:1}#site-nav .horiz ul>li{float:none;top:-4rem;position:relative;margin-top:1rem;margin-bottom:0}}@-webkit-keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@keyframes chars{0%,1.8105942029%{content:"u"}1.8115942029%,3.6221884058%{content:"un"}3.6231884058%,5.4337826087%{content:"unt"}5.4347826087%,7.2453768116%{content:"unto"}7.2463768116%,9.0569710145%{content:"untor"}10.8685652174%,9.0579710145%{content:"untore"}10.8695652174%,12.6801594203%{content:"untoreh"}12.6811594203%,14.4917536232%{content:"untoreh'"}14.4927536232%,16.3033478261%{content:"untoreh's"}16.3043478261%,18.114942029%{content:"untoreh's "}18.115942029%,19.9265362319%{content:"untoreh's s"}19.9275362319%,21.7381304348%{content:"untoreh's si"}21.7391304348%,23.5497246377%{content:"untoreh's sit"}23.5507246377%,to{content:"untoreh's site"}}@-webkit-keyframes cursor{75%{border-color:transparent}}@keyframes cursor{75%{border-color:transparent}}.site-title{-webkit-backface-visibility:hidden;backface-visibility:hidden;font-size:1.5rem;font-family:VT323,monospace,sans-serif;color:var(--accent2);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.site-title:after{content:"​";position:relative;padding-right:.5em;border-right:.5em solid var(--accent);white-space:nowrap;-webkit-animation:5.52s linear 1s forwards chars,1s 3 cursor;animation:5.52s linear 1s forwards chars,1s 3 cursor}.franklin-content a{display:inline-block;vertical-align:middle;text-decoration:none;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative;overflow:hidden}.franklin-content a:before{content:"";position:absolute;z-index:-1;left:51%;right:51%;bottom:0;background:var(--accent);height:4px}.hvr-outline-in{display:inline-block;vertical-align:middle;transform:perspective(1px) translateZ(0);box-shadow:0 0 1px var(--alt2);position:relative}.horiz .hvr-outline-in:before{border-radius:50% 25% 25% 50%;right:-.25rem}.vert .hvr-outline-in:before{border-radius:25% 50% 50% 25%;left:-.25rem}.hvr-outline-in:before{content:"";position:absolute;border:var(--alt) solid .25rem;top:0;bottom:0;left:0;opacity:0}#site-nav .vert:before{background-color:var(--background-color);filter:blur(.25rem);content:"";height:100%;width:100%;position:absolute}.author__avatar{background-color:transparent;perspective:1000px}.masthead__menu ul li.author__avatar img{transform-style:preserve-3d}.flag{display:inline-block;position:relative;width:16px;height:11px;background:url(/assets/flags.png) no-repeat}.flag.flag-th{background-position:-16px -143px}.flag.flag-tr{background-position:-144px -143px}.flag.flag-fr{background-position:-80px -44px}.flag.flag-nl{background-position:-240px -99px}.flag.flag-ms{background-position:-16px -99px}.flag.flag-es{background-position:-224px -33px}.flag.flag-vn{background-position:-128px -154px}.flag.flag-za{background-position:-256px -154px}.flag.flag-ph{background-position:-144px -110px}.flag.flag-ru{background-position:-96px -121px}.flag.flag-pl{background-position:-176px -110px}.flag.flag-gb{background-position:-112px -44px}.flag.flag-ro{background-position:-64px -121px}.flag.flag-pt{background-position:-256px -110px}.flag.flag-in{background-position:-64px -66px}.flag.flag-kr{background-position:-80px -77px}.flag.flag-ua{background-position:-224px -143px}.flag.flag-jp{background-position:-224px -66px}.flag.flag-de{background-position:-32px -33px}.flag.flag-se{background-position:-208px -121px}.flag.flag-gr{background-position:-48px -55px}.flag.flag-id{background-position:-256px -55px}.flag.flag-pk{background-position:-160px -110px}.flag.flag-bd{background-position:-16px -11px}.flag.flag-it{background-position:-144px -66px}.flag.flag-sa{background-position:-128px -121px}.flag.flag-cn{background-position:-176px -22px}</style><link as=style href=/css/bundle.css rel=preload><link href=/css/bundle.css media=print onload=this.onload=null;this.removeAttribute('media'); rel=stylesheet><noscript><link href=/css/bundle.css rel=stylesheet></noscript><link href=/assets/favicon.png rel=icon type=image/x-icon><link href=/assets/favicon.svg rel=icon type=image/svg+xml><title> Створюєте агрегатор вмісту для задоволення та прибутку?</title><meta content="A full app that scrapes, processes and presents content from the web...on the web."name=description><script src=/libs/load.js></script><script type=application/ld+json>{"url":"/uk/posts/Content-Aggregator/","mainContentOfPage":{"@type":"WebPageElement","cssSelector":".franklin-content"},"accessMode":["textual","visual"],"mentions":null,"description":"","@context":"https://schema.org","accessModeSufficient":{"itemListElement":["textual","visual"],"@type":"itemList"},"@type":"https://schema.org/WebPage","lastReviewed":"","dateCreated":"","@id":"/uk/posts/Content-Aggregator/","dateModified":"","keywords":[],"creativeWorkStatus":"Published","translator":{"url":"http://google.translate.com","name":"Google Translate","@type":"https://schema.org/Organization"},"translationOfWork":{"@id":"https://www.unto.re/posts/Content-Aggregator/"},"datePublished":"2023-03-01T15:33:47.571","inLanguage":"uk","name":"","mainEntityOfPage":{"@id":"/uk/posts/Content-Aggregator/","@type":"Article"}}</script><body><div class=masthead><div class=masthead__menu__inner-wrap><div class=masthead__menu><a title="untoreh's site"class=site-title href=/uk/></a><div class=author__wrap><script type=application/ld+json>{"sameAs":["https://github.com/untoreh","https://twitter.com/untoreh"],"email":"contact@unto.re","name":"untoreh","@type":"https://schema.org/Person","image":"/assets/appa.webp"}</script><ul><li class=author__avatar onclick=toggleTheme()><img alt=" unsoreh-light"class=flip-front src=/assets/appa.webp><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></div><nav id=site-nav><div class=horiz><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="Пошук на веб-сайті"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/uk/posts/><i class="fas fa-pen menu-icons"></i> дописів</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/uk/media/><i class="fas fa-tv menu-icons"></i> ЗМІ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div><button name="Website Menu"class=ham type=button><i class="fas fa-bars ham-icon"></i></button><div class=vert><ul><li class="lunrSearch masthead__menu-item hvr-outline-in"><form class=lunrSearchForm name=lunrSearchForm><button title="Пошук на веб-сайті"class=search-button formaction=/search/index.html value=Search><i class="fas fa-search menu-icons"></i></button><input class=search-input name=q placeholder=Search…></form><li class="masthead__menu-item hvr-outline-in"><a title="All the articles that I have written"href=/uk/posts/><i class="fas fa-pen menu-icons"></i> дописів</a><li class="masthead__menu-item hvr-outline-in"><a title="Video and audio content from streaming websites."href=/uk/media/><i class="fas fa-tv menu-icons"></i> ЗМІ</a><li class="masthead__menu-item hvr-outline-in menu-lang-btn" title="Change website's language"><button title="Languages Menu"class=langs-dropdown-wrapper type=button><i class="fas fa-language menu-icons"></i> Lang <div class="langs-dropdown-content langs-dropdown-menu"><ul class=lang-list><a class="lang-link lang-ar"href=/ar/posts/Content-Aggregator><span class="flag flag-sa"></span>Arabic</a><a class="lang-link lang-bn"href=/bn/posts/Content-Aggregator><span class="flag flag-bd"></span>Bengali</a><a class="lang-link lang-nl"href=/nl/posts/Content-Aggregator><span class="flag flag-nl"></span>Dutch</a><a class="lang-link lang-en"href=/posts/Content-Aggregator><span class="flag flag-gb"></span>English</a><a class="lang-link lang-tl"href=/tl/posts/Content-Aggregator><span class="flag flag-ph"></span>Filipino</a><a class="lang-link lang-fr"href=/fr/posts/Content-Aggregator><span class="flag flag-fr"></span>French</a><a class="lang-link lang-de"href=/de/posts/Content-Aggregator><span class="flag flag-de"></span>German</a><a class="lang-link lang-el"href=/el/posts/Content-Aggregator><span class="flag flag-gr"></span>Greek</a><a class="lang-link lang-hi"href=/hi/posts/Content-Aggregator><span class="flag flag-in"></span>Hindi</a><a class="lang-link lang-it"href=/it/posts/Content-Aggregator><span class="flag flag-it"></span>Italian</a><a class="lang-link lang-ja"href=/ja/posts/Content-Aggregator><span class="flag flag-jp"></span>Japanese</a><a class="lang-link lang-jw"href=/jw/posts/Content-Aggregator><span class="flag flag-id"></span>Javanese</a><a class="lang-link lang-ko"href=/ko/posts/Content-Aggregator><span class="flag flag-kr"></span>Korean</a><a class="lang-link lang-ms"href=/ms/posts/Content-Aggregator><span class="flag flag-ms"></span>Malay</a><a class="lang-link lang-zh"href=/zh/posts/Content-Aggregator><span class="flag flag-cn"></span>Mandarin Chinese</a><a class="lang-link lang-pl"href=/pl/posts/Content-Aggregator><span class="flag flag-pl"></span>Polish</a><a class="lang-link lang-pt"href=/pt/posts/Content-Aggregator><span class="flag flag-pt"></span>Portuguese</a><a class="lang-link lang-pa"href=/pa/posts/Content-Aggregator><span class="flag flag-in"></span>Punjabi</a><a class="lang-link lang-ro"href=/ro/posts/Content-Aggregator><span class="flag flag-ro"></span>Romanian</a><a class="lang-link lang-ru"href=/ru/posts/Content-Aggregator><span class="flag flag-ru"></span>Russian</a><a class="lang-link lang-es"href=/es/posts/Content-Aggregator><span class="flag flag-es"></span>Spanish</a><a class="lang-link lang-sv"href=/sv/posts/Content-Aggregator><span class="flag flag-se"></span>Swedish</a><a class="lang-link lang-th"href=/th/posts/Content-Aggregator><span class="flag flag-th"></span>Thai</a><a class="lang-link lang-tr"href=/tr/posts/Content-Aggregator><span class="flag flag-tr"></span>Turkish</a><a class="lang-link lang-uk"href=/uk/posts/Content-Aggregator><span class="flag flag-ua"></span>Ukranian</a><a class="lang-link lang-ur"href=/ur/posts/Content-Aggregator><span class="flag flag-pk"></span>Urdu</a><a class="lang-link lang-vi"href=/vi/posts/Content-Aggregator><span class="flag flag-vn"></span>Vietnamese</a><a class="lang-link lang-zu"href=/zu/posts/Content-Aggregator><span class="flag flag-za"></span>Zulu</a></ul></div></button></ul></div></nav></div></div></div><div><h1 id=title><a href=/uk/posts/Content-Aggregator> Створюєте агрегатор вмісту для задоволення та прибутку?</a></h1><blockquote id=page-description style=font-style:italic>Повноцінна програма, яка збирає, обробляє та представляє вміст з Інтернету... в Інтернеті.</blockquote></div><div class=franklin-content><h1 id=why><a class=header-anchor href=#why> чому</a></h1><p><a href=https://en.wikipedia.org/wiki/Information_overload> Перевантаження інформацією</a> ? У наші дні це погано, багато джерел інформації з низьким рівнем сигнал/шум, звузити ваші «канали» так, щоб ви не були перевантажені, досить важко. Дуже корисним був би інструмент, який фільтрує інформацію та представляє її у форматі, який легко та швидко сприймається. Ось чому я вважаю<em> агрегація контенту</em> вічнозелене поле для зриву. Це є і завжди буде (поки Інтернет вільний і є свобода слова) хороша можливість для бізнесу. Це один із тих випадків, коли все залежить від виконання (і зовсім не від ідеї).<h1 id=managing_expectations><a class=header-anchor href=#managing_expectations> Управління очікуваннями</a></h1><p>Зрештою, моя програма не виконує жодної фактичної фільтрації. Насправді це просто<em> агрегати</em> вміст з Інтернету. Це тому, що я не вбудовував користувачів у це, і є мало стимулів виконувати фільтрацію, якщо її не можна адаптувати для кожного користувача.<h1 id=the_architecture><a class=header-anchor href=#the_architecture> Архітектура</a></h1><p>Схема архітектури:<img alt=" діаграма-агрегатора вмісту"src=/assets/posts/img/content-aggregator-diagram.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block>У ньому справді багато гуртків!...знаєте...мікро...послуги? Програми, які я створив, — це «скребок» і «сервер», тоді як «видавець» — це лише програма, вбудована в сервер. «Пошук» і «проксі» — це зовнішні інструменти, які виконують свою роботу. «Frontend» — це нічого особливого, суміш js і css у комплекті з webpack.<p>Оскільки є різні рухомі частини, я буду йти відповідно до потоку вмісту, починаючи з того моменту, коли вміст буде показано вперше.<h1 id=the_scraper><a class=header-anchor href=#the_scraper> Скребок</a></h1><p>Збирання виконується в... як ви здогадалися, пітоні. Однак не використовуються спеціальні модулі "збирання".<h2 id=what_do_you_scrape><a class=header-anchor href=#what_do_you_scrape> Що ви вишкрябуєте?</a></h2><p>Рішення про те, що копіювати, залежить від категорії вмісту. Ми називаємо категорії «темами».<ul><li><p>Кожна тема має список ключових слів.<li><p>Список ключових слів, отриманих із google adwords за допомогою їх<a href=https://github.com/googleads/google-ads-python> python api</a><li><p>Ключові слова періодично запитуються в кількох пошукових системах у циклічному порядку. Якщо екземпляр має кілька тем, спочатку шукаються теми з менш доступним вмістом. Для виконання пошуків, на які ми покладаємося<a href=https://github.com/searxng/searxng> searx</a> з довіреними особами. Searx не зовсім дружній до бібліотеки, оскільки він використовується в основному для інтерфейсу, тому для ініціалізації модуля для виконання запитів потрібно було прокопатися в правильному процесі. Щоб пришвидшити роботу з використанням пулу потоків для виконання кількох запитів одночасно, ми будемо часто використовувати пул потоків протягом усього проекту.<li><p>Кожен пошук за ключовим словом створює список потенційних джерел вмісту (результати пошукових систем), які зберігаються в пам’яті для подальшої обробки.<li><p>Коли ми хочемо знайти новий вміст для певної теми, ми спочатку перевіряємо, чи є доступні джерела, інакше ми створюємо нові джерела зі списку ключових слів.<img alt=" контент-конвеєр"src=/assets/posts/img/content-pipeline.png style=float:none;padding:.5rem;margin-left:auto;margin-right:auto;display:block><li><p>Джерела обробляються через дві бібліотеки<a href=https://github.com/adbar/trafilatura> трафілатура</a> є основним, якщо він не працює, ми виконуємо резервне копіювання<a href=https://github.com/goose3/goose3> гусак</a> . Ми також намагаємося знайти канали для додаткових посилань (які вважатимуться новими джерелами). Для кормів використовуємо<a href=https://github.com/dfm/feedfinder2> кормошукач</a> але простий розбір html для rss<code>link</code> тегів також буде достатньо.<li><p>Наш основний тип вмісту – an<code>Article</code> , що з боку python – це просто dict, з боку nim – із розбором його як об’єкта. Ключі:<ul><li><p><code>title</code> : заголовок статті<li><p><code>content</code> : сама стаття. Щоб визначити, яка стаття хороша, ми проходимо різні етапи фільтрації:<ul><li><p>Спочатку ми перевіряємо, чи трафілатура чи гусак мають текст і чи достатньо він довгий. Наш мінімальний розмір – 300 слів. Якщо розмір не збігається, ми відкидаємо джерело (нічого не повертаємо).<li><p>Потім ми отримуємо заголовок і очищаємо його, видаляючи URL-адреси та пробіли<li><p>Якщо мова іноземна, ми перекладаємо її назад на англійську (ми нормалізуємо англійську) і зміст, і назву.<li><p>На цьому етапі ми перевіряємо використання ненормативної лексики<a href=https://github.com/dimitrismistriotis/alt-profanity-check> перевірка ненормативної лексики</a> . Не те, щоб перевірка ненормативної лексики англійською мовою базувалася на попередньому перекладі. Інакше нам знадобилася б модель ненормативної лексики для всіх мов.<li><p>Після того, як ми замінили нецензурні слова на фільтр ненормативної лексики, ми продовжуємо очищення вмісту. Перевіряємо чи актуальна стаття. Ми використовуємо такі правила:<ul><li><p>Вміст має починатися з буквено-цифрових символів, інакше це буде сміттям.<li><p>І назва, і зміст не можуть бути «шумовими». Шум визначається регулярним виразом, який фіксує такі ключові слова, як «вхід», «реєстрація», «доступ заборонено» тощо.<li><p>Принаймні одне слово в назві має бути присутнім у тілі. Інакше можливо, що аналіз вибрав неправильні частини вихідної сторінки для вмісту.</ul><li><p>Якщо тести на релевантність пройшли, на останньому етапі ми очищаємо вміст від надто великої кількості дужок, пробілів, повторюваних символів і спеціальних символів.<li><p>Якщо очищення не видалило все, ми продовжуємо обробку статті.</ul><li><p><code>source</code> : посилання, що вказує на першоджерело, яке ми проаналізували<li><p><code>lang</code> : мова статті, ми використовуємо<a href=https://github.com/pemistahl/lingua-py> лінгва</a> щоб виявити мову<li><p><code>desc</code> : короткий зміст, інакше уривок зі змісту<li><p><code>author</code> : автор, інакше заголовок домашньої сторінки вихідного посилання<li><p><code>pubDate</code> : дата публікації статті або зараз<li><p><code>topic</code> : тема, до якої належить ця стаття<li><p><code>tags</code> : відповідні ключові слова для статті, ми використовуємо найшвидшу бібліотеку для вилучення kw, яка є<a href=https://github.com/csurfer/rake-nltk> граблі</a> , розглядаються альтернативи<a href=https://github.com/kevinlu1248/pyate> pyate</a> (combobasic),<a href=https://github.com/DerwenAI/pytextrank> textrank</a> та<a href=https://github.com/slanglab/phrasemachine> фразомашина</a><li><p><code>imageTitle</code> : альтернативний текст для зображення<li><p><code>imageOrigin</code> : якщо розбір джерела (для зображень, які ми використовуємо<a href=https://github.com/michaelhelmick/lassie> дівчина</a> ) не знайшов зображення, ми запитуємо пошукові системи щодо відповідного зображення, тому imageOrigin вказує на оригінальну сторінку, на якій розміщено зображення, інакше воно дорівнює URL-адресі джерела.<li><p><code>imageUrl</code> : фактичне посилання на зображення. Ми використовуємо перевірку фільтра Блюм для дублікатів зображень, тому що ми не любимо дублікатів.<li><p><code>icon</code> : фавікон посилання на джерело</ul><li><p>Після того, як ми обробили ключове слово, ми зберігаємо його знайдені статті та канали в сховищі. Їх використовуватиме видавництво.</ul><p>Зішкріб відбувається безперервно, це демон. Псевдокод основного циклу виглядає так, і він налаштований<em> на сайт</em>:<ul><li><p>синхронізувати проксі назавжди<li><p>для кожної теми, відсортованої за кількістю неопублікованих (статей) (від низького до високого), виконайте наступне<ul><li><p>якщо пройдено мінімальний інтервал від останнього завдання, запустіть завдання аналізу для теми. Інтервал збільшується, чим більше неопублікованих статей ми маємо для теми, і завжди дорівнює 0, якщо у нас немає неопублікованих статей.<li><p>Зробіть те саме, але для каналів (які ми зібрали з джерел, якщо такі є)<li><p>Якщо сайт призначений для створення нових тем, створіть їх. (Це має сенс, лише якщо ви не визначаєте список тем під час створення сайту.)<li><p>Виберіть статтю з опублікованих і надішліть твіт (ми надсилаємо 3 твіти на день, використовуючи<a href=https://github.com/bear/python-twitter> python-твіттер</a>)<li><p>Виберіть статтю з опублікованих і оновіть сторінку в facebook (ми робимо 1 оновлення в день, використовуючи<a href=https://github.com/jgorset/facepy> facepy</a>)</ul><p>(Ми також підключили Reddit, але Reddit не дозволяє публікувати перехресні публікації, тому це було марно.)</ul><h1 id=publishing><a class=header-anchor href=#publishing> Видавництво</a></h1><p>Коли у нас є вміст для публікації, ми повинні вирішити, що публікувати та як часто. Я не придумав тут жодних хитрощів, оскільки, як я вже згадував раніше, вибір того, що відображати, залежить від користувача. Тому ми просто публікуємо з<em> від найновішого до найстарішого</em> , з міркуванням, що те, що ми нещодавно зібрали, є більш актуальним, це a<a href=https://en.wikipedia.org/wiki/Stack_(abstract_data_type)> ЛІФО</a> чергу. Публікація, незважаючи на те, що вона досить залежить від інструментів Python, відбувається в nim, оскільки вона працює поруч із сервером, який також є в nim.<h2 id=the_publishing_logic><a class=header-anchor href=#the_publishing_logic> Видавнича логіка</a></h2><p>Публікація відбувається безперервно, і, подібно до збирання, має інтервали простою, публікація робить це, навпаки, до збирання. Коли ми скребемо, ми сповільнюємося, коли маємо a<em> достатньо довго</em> кеш неопублікованих статей, публікація сповільнюється, коли наш кеш починає надто скорочуватися. Таким способом укупі зі вишкрібанням має бути завжди<em> деякий вміст</em> буде опубліковано<em> деякий час</em> у майбутньому. Реальна логіка публікації:<ul><li><p>Отримати пакет неопублікованих статей із кешу. (Ми вирішуємо публікувати 3 нові статті за один випуск.)<li><p>Перевірте, чи є вони дублікатами. Перевірка дублікатів виконується через хешування, чутливе до локальності, за допомогою бібліотеки nim,<a href=https://github.com/Nim-NLP/minhash/> minhash</a> . LSH досить інтенсивно використовує ЦП (ви знаєте... хешування) і потребує власного потоку (є кілька інших завдань, які ми вирішуємо, для яких потрібні власні потоки).<li><p>Візуалізація сторінки: це не обов’язково, оскільки сервер обробляє запити на льоту, але рендеринг тут є формою попереднього кешування.<li><p>Обробка сторінки. Оскільки ми маємо справу з сайтом, ми повинні вибрати, скільки статей відображати на сторінці, і збільшувати сторінки, коли ми публікуємо більше статей. Ми вирішили групувати статті на сторінках по ~10. На останній сторінці завжди менше 10 статей.<li><p>Зберігайте стан опублікованих статей, це означає переміщення статей зі статусу «неопубліковані» в «опубліковані», а також базу даних LSH.<li><p>Після публікації нових статей ми повинні очистити застарілі кеші. Ми повинні очистити домашню сторінку, сторінку теми, карту сайту та канал RSS.</ul><h1 id=serving><a class=header-anchor href=#serving> Подача</a></h1><p>Ми встановлюємо завдання для збирання опублікованого вмісту, все, що залишилося, це його обслуговування.<h2 id=the_web_server><a class=header-anchor href=#the_web_server> Веб-сервер</a></h2><p>Після наявності<a href=https://github.com/dom96/jester> пробував</a><a href=https://github.com/dom96/httpbeast> інший</a><a href=https://github.com/olliNiinivaara/GuildenStern/> Інтернет</a><a href=https://github.com/status-im/nim-chronos/blob/master/chronos/apps/http/httpserver.nim> серверів</a>, через різні помилки, з якими я погодився<a href=https://github.com/bung87/scorper> скорпер</a>.<h2 id=handling_a_request><a class=header-anchor href=#handling_a_request> Обробка запиту</a></h2><h3 id=the_router><a class=header-anchor href=#the_router> Маршрутизатор</a></h3><p>Ми використовуємо nim<a href=https://nim-lang.github.io/fusion/src/fusion/matching.html> реалізація відповідності шаблону</a> щоб відповідати кортежу регулярних виразів. Це регулярний вираз, який взагалі не є RESTful:<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  rxend = <span class=hljs-string>"(?=/+|(?=[?].*)|$)"</span>
  rxAmp = <span class=hljs-string>fmt"(/+amp{rxend})"</span>
  rxLang = <span class=hljs-string>"(/[a-z]{2}(?:-[A-Z]{2})?"</span> & <span class=hljs-string>fmt"{rxend})"</span> <span class=hljs-comment># split to avoid formatting regex `{}` usage</span>
  rxTopic = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPage = <span class=hljs-string>fmt"(/+(?:[0-9]+|s|g|feed\.xml|sitemap\.xml){rxend})"</span>
  rxArt = <span class=hljs-string>fmt"(/+.*?{rxend})"</span>
  rxPath = <span class=hljs-string>fmt"{rxAmp}?{rxLang}?{rxTopic}?{rxPage}?{rxArt}?"</span></code></pre><p><code>rxPath</code> показує всі можливі вузли, які може мати шлях. Тоді наш маршрут виглядає так:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> capts = uriTuple(reqCtx.url.path)
<span class=hljs-keyword>case</span> capts:
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>""</span>): <span class=hljs-comment># homepage...</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"assets"</span>): <span class=hljs-comment># assets</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"i"</span>): <span class=hljs-comment># images</span>
  <span class=hljs-keyword>of</span> (topic: <span class=hljs-string>"robots.txt"</span>): <span class=hljs-comment># robots.txt</span>
  <span class=hljs-keyword>of</span> (page: <span class=hljs-string>"sitemap.xml"</span>): <span class=hljs-comment># sitemap for topics</span>
  <span class=hljs-keyword>of</span> (art: <span class=hljs-string>"index.xml"</span>): <span class=hljs-comment># sitemap index for topic pages</span>
  etc...</code></pre><p>Це не дуже гарно, але відсутність залежності від якогось конкретного маршрутизатора дозволило мені поміняти базовий веб-сервер без зайвих суєт під час тестування. Це продуктивно? незрозуміло! Не проводив жодних тестів, щоб порівняти це з чимось іншим. Однак те, що пахне, це регулярний вираз, який може мати помилки, і той факт, що порядок випадків має значення.<blockquote><p>Почекай хвилинку...</blockquote><p>Існує купа речей, які ми виконуємо для кожного запиту перед фактичною маршрутизацією сторінки:<p>спочатку ми встановлюємо код очищення (з<code>defer:</code> ) який<em> слід</em> переконайтеся, що немає витоків.<pre><code class="nim hljs">defer:
  <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> is this cleanup required?</span>
  <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>let</span> resp =
    <span class=hljs-keyword>if</span> ctx.response.issome: ctx.response.get
    <span class=hljs-keyword>else</span>: <span class=hljs-keyword>nil</span>
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> resp.connection.isnil:
    futs.add resp.connection.closeWait()
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.isnil:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> ctx.connection.isnil:
      futs.add ctx.connection.closeWait()
    futs.add ctx.closeWait()
  await allFutures(futs)</code></pre><p>Ми перевіряємо, чи ініціалізовано потік:<pre><code class="nim hljs">initThread()</code></pre><p>Це справді має виконуватися лише один раз (після ініціалізації встановлюється глобальний логічний параметр для перевірки), і це можна зробити поза обробником запитів. Але що насправді ініціалізовано? Ну...досить багато чого! В основному ми (зло) використовуємо глобальні константи, які вимагають ініціалізації, також деякі з них насправді не пов’язані з потоками, оскільки вони ініціалізують пам’ять у купі та спільно використовуються між потоками<pre><code class="nim hljs"><span class=hljs-keyword>if</span> threadInitialized:
  debug <span class=hljs-string>"thread: already initialized"</span>
  <span class=hljs-keyword>return</span>
debug <span class=hljs-string>"thread: base"</span>
initThreadBase()
debug <span class=hljs-string>"thread: sonic"</span>
initSonic() <span class=hljs-comment># Must be on top</span>
debug <span class=hljs-string>"thread: http"</span>
initHttp()
debug <span class=hljs-string>"thread: html"</span>
initHtml()
debug <span class=hljs-string>"thread: ldj"</span>
initLDJ()
debug <span class=hljs-string>"thread: feed"</span>
initFeed()
debug <span class=hljs-string>"thread: img"</span>
startImgFlow()
debug <span class=hljs-string>"thread: lsh"</span>
startLsh()
debug <span class=hljs-string>"thread: mimes"</span>
initMimes()
<span class=hljs-comment># ... and other stuff</span></code></pre><p>Потім розбираємо параметри<pre><code class="nim hljs"><span class=hljs-keyword>var</span>
  relpath = ctx.rawPath
  page: <span class=hljs-type>string</span>
  rqlocked: <span class=hljs-type>bool</span>
relpath.removeSuffix('/')
debug <span class=hljs-string>"handling: {relpath:.120}"</span>

handleParams()</code></pre><p>Для чого ми використовуємо параметри? The<code>ParamKey</code> тип enum описує це:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>ParamKey</span> = <span class=hljs-keyword>enum</span>
    none,
    q, p, <span class=hljs-comment># sonic</span>
    c, <span class=hljs-comment># cache</span>
    d, <span class=hljs-comment># delete</span>
    t,  <span class=hljs-comment># translations</span>
    u <span class=hljs-comment># imgUrls</span></code></pre><p>Ми робимо<em> мікрокешування</em> для запитів, тому кожен запит кешується відповідно до кортежу<code>(path, query, accetEncoding)</code> , потрібне кодування, оскільки ми можемо обслуговувати обидва (не)стиснуті тіла. Контекст запиту виглядає так:<pre><code class="nim hljs"><span class=hljs-keyword>let</span> reqCtx = reqCtxCache.lcheckOrPut(reqCacheKey):
  <span class=hljs-keyword>let</span> reqCtx <span class=hljs-meta>{.gensym.}</span> = new(<span class=hljs-type>ReqContext</span>)
  <span class=hljs-keyword>block</span>:
    <span class=hljs-keyword>let</span> l = newAsyncLock()
    checkNil(l):
      reqCtx.lock = l
  reqCtx.url = move url
  reqCtx.params = params
  reqCtx.file = reqCtx.url.path.fp
  reqCtx.key = hash(reqCtx.file)
  reqCtx.rq = initTable[<span class=hljs-type>ReqId</span>, <span class=hljs-type>HttpRequestRef</span>]()
  new(reqCtx.respBody)
  reqCtx</code></pre><ul><li><p>Файл<code>key</code> поле використовується для отримання правильної кешованої сторінки (основного вмісту).<code>pageCache</code>. Блокування потрібне, щоб гарантувати, що кілька запитів, що виконуються одночасно, не дублюють завдання візуалізації (якщо інший запит уже генерує сторінку, зачекайте, поки він завершиться). Кожна база<code>HttpRequestRef</code> з сервера chronos https зберігається в<code>rq</code> поле. The<code>params</code> уже відібрані від попереднього<code>handleParams</code>.<li><p>Ми підтримуємо видалення вмісту через<code>d</code> param, який дозволяє нам викидати статті (якщо фільтрування не вдалось, але його ніколи не слід використовувати на практиці, лише для налагодження) за допомогою простого запиту http get. Кому потрібні інші методи http? Не я.<li><p>Ми також підтримуємо очищення кешу. Ми можемо або видалити сторінку,<code>c=0</code> або всі сторінки<code>c=1</code> . Дратує те, що нам потрібно перевірити, чи є шлях статтею, сторінкою, зображенням чи активами, і очистити відповідну структуру кешу. Існує деяке очевидне дублювання логіки з маршрутизатором, але оскільки це робиться до маршрутизації, це має бути ad-hoc, обробляючи лише випадки, що стосуються очищення кешу. Це робиться до маршрутизації, тому що також кеш обслуговується без маршрутизації, оскільки, якщо запит уже було згенеровано, ми можемо просто відповісти тілом, яке зберігається в<code>respBody</code> поле (і<code>respHeaders</code>, <code>respCode</code>).<li><p>Після обробки кеш-операцій ми аналізуємо шлях.<li><p>Після цього відбувається ще одне викрадення:</ul><pre><code class="nim hljs"><span class=hljs-keyword>if</span> handleTranslation():
  <span class=hljs-keyword>return</span></code></pre><p>Чому це також робиться перед маршрутизацією? За умовчанням ми обслуговуємо частково перекладені сторінки. Ми бідні :( і переклади базуються на безкоштовних службах, але ми не можемо дозволити собі жахливий час завантаження, тому ми виконуємо відкладений переклад, поки ми обслуговуємо сторінку, перекладену лише з фрагментами, які були кешовані в нашій базі даних перекладів.<p>На цьому етапі існує маршрутизація, загорнута у виняток, так що якщо обслуговування правильної сторінки не вдається, ми видаємо<code>503</code> . Видача а<code>503</code> означає, що ми намагалися спрямувати дійсну URL-адресу, але не змогли створити сторінку. Для недійсних URL-адрес ми видаємо a<code>301</code> переспрямування, яке означає, що URL-адреса недійсна. Ми обслуговуємо 11 різних видів URL-адрес:<ul><li><p>домашня сторінка: витягує статті з останніх тем, псевдовипадково, ми не робимо сортування за популярністю.<li><p>загальні активи (під<code>/assets/</code> шлях): безпосередньо відображаються у виділеному каталозі<li><p>загальні зображення (під<code>/i/</code> тьфу): ми проксі-сервер зовнішніх зображень для генерації розмірів, які відповідають нашому адаптивному веб-сайту, коли зображення недоступні, або прозорий піксель, або піктограма зображення подається за умовчанням.<li><p>файл robots.txt<li><p>карти сайту (для домашньої сторінки, тем і сторінок): домашня сторінка містить індекс карти сайту, що вказує на всі карти сайту тем, карти сайту тем вказують на всі сторінки теми, карта сайту сторінок вказує на всі статті сторінки.<li><p>маніфест pwa: маніфест pwa повинен дозволяти встановлення веб-сайту як pwa (але, чесно кажучи, я не перевіряв це)<li><p>пошуки: пошук використовує<a href=https://github.com/valeriansaliou/sonic> звуковий</a> з<a href=https://github.com/alongwy/pysonic> pysonic</a> палітурки.<li><p>пропозиції: пропозиції також обробляються через звукові бібліотеки. Але вони вимагають<li><p>канали: як і карти сайту, ми маємо різні канали для домашньої сторінки та для різних тем, хоча зі зрозумілих причин немає каналів для окремих сторінок.<li><p>сторінки тем: сторінка, присвячена кожній темі (наприклад, із шляхом<code>domain.com/my-topic/</code> ) Витягує останні статті, опубліковані за темою, які належать до<em> незакінчений</em> сторінки.<li><p>Сторінки статей: на сторінці статті показано назву статті, опис, посилання на джерело, теги, час публікації (у нижньому колонтитулі), а внизу ми витягуємо 3 пов’язані статті. Пов’язані статті вибираються за допомогою пошукового запиту за назвою або тегами статті.</ul><h2 id=about_the_rendering><a class=header-anchor href=#about_the_rendering> Про візуалізацію</a></h2><p>Візуалізація сторінки обробляється з боку nim за допомогою<a href=https://github.com/karaxnim/karax> karax</a><h3 id=general_page_layout><a class=header-anchor href=#general_page_layout> Загальний макет сторінки</a></h3><p>Веб-сайт складається з верхньої фіксованої панелі, яка показує:<ul><li><p>URL-адресу домашньої сторінки через зображення логотипу svg.<li><p>кнопку світлої/темної теми<li><p>поточна URL-адреса з використанням поточного шляху<em> крихти</em> як текст посилання<li><p>URL-адреси останніх ~10 тем<li><p>Панель пошуку (з кнопкою пошуку), де під час введення з’являються пропозиції<li><p>кнопку мов, після натискання якої з’являється список мов</ul><p>Оскільки це адаптивний дизайн, коли область перегляду менша, верхня панель містить лише поле пошуку, а решта відображається на бічній панелі, яку можна перемикати.<ul><li><p>Нижній колонтитул, містить посилання для карти сайту, rss, соцмережі, юридичні<li><p>Підтримуються оголошення в різних місцях</ul><h2 id=rss><a class=header-anchor href=#rss> RSS</a></h2><p>Це приклад функції, яка показує, що ми робимо, коли публікується нова публікація, щоб оновити канал:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> update*(tfeed: <span class=hljs-type>Feed</span>, topic: <span class=hljs-type>string</span>, newArts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], dowrite = <span class=hljs-literal>false</span>) =
    <span class=hljs-comment>## Load existing feed for given topic and update the feed (in-memory)</span>
    <span class=hljs-comment>## with the new articles provided, it does not write to storage.</span>
    checkNil tfeed
    <span class=hljs-keyword>let</span>
        chann = tfeed.findel(<span class=hljs-string>"channel"</span>)
        itms = chann.drainChannel
        arl = itms.len
        narl = newArts.len

    debug <span class=hljs-string>"rss: newArts: {narl}, previous: {arl}"</span>
    <span class=hljs-keyword>let</span>
        fill = <span class=hljs-type>RSS_N_ITEMS</span> - arl
        rem = max(<span class=hljs-number>0</span>, narl - fill)
        shrinked = <span class=hljs-keyword>if</span> (rem > <span class=hljs-number>0</span> <span class=hljs-keyword>and</span> arl > <span class=hljs-number>0</span>):
                       itms[<span class=hljs-number>0</span>..<(max(<span class=hljs-number>0</span>, arl-rem))]
                   <span class=hljs-keyword>else</span>: itms
    debug <span class=hljs-string>"rss: articles tail len {len(shrinked)}, newarts: {len(newArts)}"</span>
    assert shrinked.len + narl <= <span class=hljs-type>RSS_N_ITEMS</span>, <span class=hljs-string>fmt"shrinked: {shrinked.len}, newarticles: {narl}"</span>
    <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> newArts:
        chann.add articleItem(a)
    <span class=hljs-keyword>for</span> itm <span class=hljs-keyword>in</span> shrinked:
        chann.add itm
    <span class=hljs-keyword>if</span> dowrite:
   
        pageCache[][topic.feedKey] = tfeed.toXmlString</code></pre><h2 id=sitemaps><a class=header-anchor href=#sitemaps> Карти сайту</a></h2><p>Це суть додавання URL-адрес до карт сайту:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> addUrlToFeed(getLoc, getLocLang) =
  <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
      warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
      <span class=hljs-keyword>break</span>
  <span class=hljs-keyword>let</span>
      url = newElement(<span class=hljs-string>"url"</span>)
      loc = newElement(<span class=hljs-string>"loc"</span>)
  loc.add getLoc().escape.newText
  url.add loc
  addLangs(url, getLocLang)
  <span class=hljs-built_in>result</span>.add url

<span class=hljs-keyword>proc</span> buildTopicPagesSitemap*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initSitemapIndex()
    await syncTopics()
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>template</span> langUrl(lang): untyped <span class=hljs-meta>{.dirty.}</span> = $(<span class=hljs-type>WEBSITE_URL</span> / lang / topic / pages[n])
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>let</span> pages = pybi[].list(done.keys()).to(<span class=hljs-type>seq</span>[<span class=hljs-type>string</span>])
        <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> countDown(pages.len - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
          <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (await isEmptyPage(topic, pages[n].parseInt, <span class=hljs-literal>false</span>)):
            <span class=hljs-keyword>discard</span> sitemapUrl(topic, pages[n]).sitemapEl

<span class=hljs-keyword>template</span> addArticleToFeed() =
  <span class=hljs-keyword>template</span> baseUrl(): untyped =
    getArticleUrl(a, topic)

  <span class=hljs-keyword>template</span> langUrl(lang): untyped =
    getArticleUrl(a, topic, lang)

  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a.isValidArticlePy:
      <span class=hljs-keyword>continue</span>

  addUrlToFeed(baseUrl, langUrl)

<span class=hljs-keyword>proc</span> buildTopicSitemap(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.async.}</span> =
    initUrlSet()
    await syncTopics()
    <span class=hljs-keyword>let</span> done = await topicDonePages(topic)
    <span class=hljs-keyword>var</span> nEntries = <span class=hljs-number>0</span>
    withPyLock:
        <span class=hljs-comment># add the most recent articles first (pages with higher idx)</span>
        <span class=hljs-keyword>for</span> pagenum <span class=hljs-keyword>in</span> countDown(len(done) - <span class=hljs-number>1</span>, <span class=hljs-number>0</span>):
            <span class=hljs-keyword>if</span> unlikely(nEntries > maxEntries):
                warn <span class=hljs-string>"Number of URLs for sitemap of topic: {topic} exceeds limit! {nEntries}/{maxEntries}"</span>
                <span class=hljs-keyword>break</span>
            checkTrue pagenum <span class=hljs-keyword>in</span> done, <span class=hljs-string>"Mismatching number of pages"</span>
            <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> done[pagenum]:
                addArticleToFeed()</code></pre><h2 id=templates><a class=header-anchor href=#templates> Шаблони</a></h2><p>Ми не використовуємо механізм шаблонів, оскільки більша частина візуалізації виконується за допомогою karax, але для таких сторінок, як ToS, ми використовуємо шаблони файлів, де ми просто замінюємо купу змінних, наприклад<code>envsubst</code> команда.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pageFromTemplate*(tpl, lang, amp: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> txt = await readfileAsync(<span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"templates"</span> / tpl & <span class=hljs-string>".html"</span>)
  <span class=hljs-keyword>let</span> (vars, title, desc) =
    <span class=hljs-keyword>case</span> tpl:
      <span class=hljs-keyword>of</span> <span class=hljs-string>"dmca"</span>: (tplRep, <span class=hljs-string>"DMCA"</span>, <span class=hljs-string>fmt"dmca compliance for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"tos"</span>: (ppRep, <span class=hljs-string>"Terms of Service"</span>,
          <span class=hljs-string>fmt"Terms of Service for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>of</span> <span class=hljs-string>"privacy-policy"</span>: (ppRep, <span class=hljs-string>"Privacy Policy"</span>,
          <span class=hljs-string>fmt"Privacy Policy for {WEBSITE_DOMAIN}"</span>)
      <span class=hljs-keyword>else</span>: (tplRep, tpl, <span class=hljs-string>""</span>)
  txt = multiReplace(txt, vars)
  <span class=hljs-keyword>let</span>
    slug = slugify(title)
    page = await buildPage(title = title, content = txt, wrap = <span class=hljs-literal>true</span>)
  checkNil(page):
    <span class=hljs-keyword>let</span> processed = await processPage(lang, amp, page, relpath = tpl)
    checkNil(processed, <span class=hljs-string>fmt"failed to process template {tpl}, {lang}, {amp}"</span>):
      <span class=hljs-keyword>return</span> processed.asHtml(minify_css = (amp == <span class=hljs-string>""</span>))</code></pre><h2 id=articles_pages><a class=header-anchor href=#articles_pages> Сторінки статей</a></h2><p>Коли ми візуалізуємо сторінки, такі як домашня сторінка/теми та пронумеровані сторінки, нам потрібно показати список статей, ця функція викликається в циклі для визначення кількості статей, які ми хочемо показати:<pre><code class="nim hljs"><span class=hljs-keyword>import</span> htmlparser
<span class=hljs-keyword>proc</span> articleEntry(ar: <span class=hljs-type>Article</span>, topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> ar.topic == <span class=hljs-string>""</span> <span class=hljs-keyword>and</span> topic != <span class=hljs-string>""</span>:
    ar.topic = topic
  <span class=hljs-keyword>let</span> relpath = getArticlePath(ar)
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>return</span> buildHtml(article(class = <span class=hljs-string>"entry"</span>)):
      h2(class = <span class=hljs-string>"entry-title"</span>, id = ar.slug):
        a(href = relpath):
          text ar.title
      tdiv(class = <span class=hljs-string>"entry-info"</span>):
        span(class = <span class=hljs-string>"entry-author"</span>):
          text ar.getAuthor & <span class=hljs-string>", "</span>
        time(class = <span class=hljs-string>"entry-date"</span>, datetime = ($ar.pubDate)):
          italic:
            text format(ar.pubDate, <span class=hljs-string>"dd/MMM"</span>)
      tdiv(class = <span class=hljs-string>"entry-tags"</span>):
        <span class=hljs-keyword>if</span> ar.tags.len == <span class=hljs-number>0</span>:
          span(class = <span class=hljs-string>"entry-tag-name"</span>):
            a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
              icon(<span class=hljs-string>"i-mdi-tag"</span>)
              text <span class=hljs-string>"none"</span>
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> ar.tags:
            <span class=hljs-keyword>if</span> likely(t.isSomething):
              span(class = <span class=hljs-string>"entry-tag-name"</span>):
                a(href = (await nextAdsLink()), target = <span class=hljs-string>"_blank"</span>):
                  icon(<span class=hljs-string>"i-mdi-tag"</span>)
                  text t
      buildImgUrl(ar)
      tdiv(class = <span class=hljs-string>"entry-content"</span>):
        verbatim(articleExcerpt(ar))
        a(class = <span class=hljs-string>"entry-more"</span>, href = relpath):
          text <span class=hljs-string>"[continue]"</span>
      hr()
  <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span> <span class=hljs-keyword>as</span> e:
    logexc()
    warn <span class=hljs-string>"articles: entry creation failed."</span>
    <span class=hljs-keyword>raise</span> e

<span class=hljs-keyword>proc</span> buildShortPosts*(arts: <span class=hljs-type>seq</span>[<span class=hljs-type>Article</span>], topic = <span class=hljs-string>""</span>): <span class=hljs-type>Future</span>[
    <span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>for</span> a <span class=hljs-keyword>in</span> arts:
    <span class=hljs-built_in>result</span>.add $(await articleEntry(a, topic))</code></pre><p>Зверніть увагу, як у деяких рядках "реклама" вкрадається в X)<h2 id=topics_list><a class=header-anchor href=#topics_list> Список тем</a></h2><p>У верхній панелі ми показуємо список тем, ось що його друкує:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> topicsList*(ucls: <span class=hljs-type>string</span>; icls: <span class=hljs-type>string</span>; small: <span class=hljs-keyword>static</span>[
    <span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>VNode</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-built_in>result</span> = newVNode(<span class=hljs-type>VNodeKind</span>.ul)
  <span class=hljs-built_in>result</span>.setAttr(<span class=hljs-string>"class"</span>, ucls)
  <span class=hljs-keyword>let</span> topics = await loadTopics(-<span class=hljs-type>MENU_TOPICS</span>) <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the sign is negative, we load the most recent N topics</span>
  <span class=hljs-built_in>result</span>.add buildHtml(tdiv(class = <span class=hljs-string>"topics-shadow"</span>))
  <span class=hljs-keyword>var</span> topic_slug, topic_name: <span class=hljs-type>string</span>
  <span class=hljs-keyword>var</span> isEmpty: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>for</span> i <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTtopics.len:
    withPyLock:
      (topic_slug, topic_name) = ($topics[i][<span class=hljs-number>0</span>], $topics[i][<span class=hljs-number>1</span>])
      isEmpty = isEmptyTopic(topic_slug)
    <span class=hljs-keyword>if</span> isEmpty:
      <span class=hljs-keyword>continue</span>
    <span class=hljs-keyword>let</span> liNode = buildHtml(li(class = <span class=hljs-string>fmt"{icls}"</span>)):
      <span class=hljs-comment># tdiv(class = "mdc-icon-button__ripple") # not used without material icons</span>
      a(href = ($(<span class=hljs-type>WEBSITE_URL</span> / topic_slug)), title = topic_name,
          class = <span class=hljs-string>"mdc-ripple-button"</span>):
        tdiv(class = <span class=hljs-string>"mdc-ripple-surface  mdc-ripple-upgraded"</span>)
        <span class=hljs-keyword>when</span> small:
          <span class=hljs-comment># only use the first letter</span>
          text $topic_name.runeAt(<span class=hljs-number>0</span>).toUpper <span class=hljs-comment># loadTopics iterator returns pyobjects</span>
        <span class=hljs-keyword>else</span>:
          text topic_name
      <span class=hljs-keyword>when</span> small:
        br()
      <span class=hljs-keyword>else</span>:
        span(class = <span class=hljs-string>"separator"</span>)
    <span class=hljs-built_in>result</span>.add liNode</code></pre><p>Тут є кілька смердючих жорстко закодованих уроків матеріального дизайну. Відверто кажучи, компоненти матеріального дизайну Google відстій.<h2 id=post_footer><a class=header-anchor href=#post_footer> Нижній колонтитул повідомлення</a></h2><p>Нижній колонтитул допису з’являється у нижньому правому куті сторінки статті (в ltr), і насправді друкує лише дату публікації.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> postFooter(pubdate: <span class=hljs-type>Time</span>): <span class=hljs-type>VNode</span> =
  <span class=hljs-keyword>let</span> dt = inZone(pubdate, utc())
  buildHtml(tdiv(class = <span class=hljs-string>"post-footer"</span>)):
    time(datetime = ($dt)):
      text <span class=hljs-string>"Published date: "</span>
      italic:
        text format(dt, <span class=hljs-string>"dd MMM yyyy"</span>)</code></pre><h2 id=excerpts><a class=header-anchor href=#excerpts> Уривки</a></h2><p>Під час створення записів про статті нам можуть знадобитися витяги, якщо немає резюме.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> articleExcerpt(a: <span class=hljs-type>Article</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> alen = len(a.content) - <span class=hljs-number>1</span>
  <span class=hljs-keyword>let</span> maxlen = min(alen, <span class=hljs-type>ARTICLE_EXCERPT_SIZE</span>)
  <span class=hljs-keyword>if</span> maxlen == alen:
    <span class=hljs-keyword>return</span> a.content
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>let</span> runesize = runeLenAt(a.content, maxlen)
    <span class=hljs-comment># If article contains html tags, the excerpt might have broken html</span>
    <span class=hljs-keyword>return</span> parseHtml(a.content[<span class=hljs-number>0</span>..maxlen+runesize]).innerText & <span class=hljs-string>"..."</span></code></pre><p>Wtf є<code>parseHtml</code> робити тут? Це випадок, коли ми дозволяємо html усередині вмісту статті (але лише деякі теги), це опція з модуля python trafilatura, яку ми залишаємо ввімкненою, оскільки вона може вплинути на формат статті. Ми також маємо бути обережними щодо поділу рядків utf-8...<h2 id=minification><a class=header-anchor href=#minification> Мініфікація</a></h2><p>Останнє завдання після побудови каракса<code>VNode</code> дерево для скидання байтів. Дерево має префікс HTML-заголовка та, за бажанням, зменшене.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> asHtml*(data: <span class=hljs-type>string</span> ; minify: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>; minify_css: <span class=hljs-type>bool</span> = <span class=hljs-literal>true</span>): <span class=hljs-type>string</span> =
  <span class=hljs-keyword>let</span> html = <span class=hljs-string>"&LT!DOCTYPE html>"</span> & <span class=hljs-string>"\n"</span> & data
  sdebug <span class=hljs-string>"html: raw size {len(html)}"</span>
  <span class=hljs-built_in>result</span> = <span class=hljs-keyword>when</span> minify:
             html.minifyHtml(minify_css = <span class=hljs-literal>false</span>,
                             minify_js = <span class=hljs-literal>false</span>,
                             keep_closing_tags = <span class=hljs-literal>true</span>,
                             do_not_minify_doctype = <span class=hljs-literal>true</span>,
                             keep_spaces_between_attributes = <span class=hljs-literal>true</span>,
                             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>true</span>)
           <span class=hljs-keyword>else</span>:
             html
  sdebug <span class=hljs-string>"html: minified size {len(result)}"</span></code></pre><p>Мініфікація обробляється<a href=https://github.com/wilsonzlin/minify-html> зменшити-html</a> які ми зобов’язали використовувати<a href=https://github.com/nim-lang/c2nim> c2nim</a> , файл прив’язки містить:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> minify*(code: <span class=hljs-type>cstring</span>,
             do_not_minify_doctype = <span class=hljs-literal>false</span>,
             ensure_spec_compliant_unquoted_attribute_values = <span class=hljs-literal>false</span>,
             keep_closing_tags = <span class=hljs-literal>true</span>,
             keep_comments = <span class=hljs-literal>false</span>,
             keep_html_and_head_opening_tags = <span class=hljs-literal>true</span>,
             keep_spaces_between_attributes = <span class=hljs-literal>false</span>,
             minify_css = <span class=hljs-literal>true</span>,
             minify_js = <span class=hljs-literal>true</span>,
             remove_bangs = <span class=hljs-literal>false</span>,
             remove_processing_instructions = <span class=hljs-literal>true</span>): <span class=hljs-type>cstring</span> <span class=hljs-meta>{.importc: "minify".}</span>

<span class=hljs-keyword>proc</span> minifyHtml*(tree: <span class=hljs-type>VNode</span>): <span class=hljs-type>string</span> = $minify(($tree).<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>proc</span> minifyHtml*(data: <span class=hljs-type>string</span>): <span class=hljs-type>string</span> = $minify(data.<span class=hljs-type>cstring</span>)
<span class=hljs-keyword>template</span> minifyHtml*(data: <span class=hljs-type>string</span>, args: <span class=hljs-type>varargs</span>[untyped]): <span class=hljs-type>string</span> =
    $minify(data.<span class=hljs-type>cstring</span>, args)</code></pre><p>Але для створення ми повинні надати статичні бібліотеки, додавши цей рядок у наш<code>nim.cfg</code><pre><code class="toml hljs">--passL:"$PROJECT_DIR/src/rust/target/release/libminify_html_c.a"</code></pre><p>Я маю на увазі... це мій шлях, коли я створив мінімізовану бібліотеку, яка<em> до речі</em> насправді не має функції extern c, яку nim може використовувати, тому нам довелося написати її самостійно.<pre><code class="rust hljs"><span class=hljs-keyword>use</span> minify_html::{Cfg, minify <span class=hljs-keyword>as</span> minify_html_native};
<span class=hljs-keyword>use</span> std::ffi::CStr;
<span class=hljs-keyword>use</span> std::ffi::CString;
<span class=hljs-keyword>use</span> std::os::raw::c_char;

<span class=hljs-meta>#[no_mangle]</span>
<span class=hljs-keyword>pub</span> <span class=hljs-keyword>extern</span> <span class=hljs-string>"C"</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">minify</span>(
    code: *<span class=hljs-keyword>const</span> c_char,
    do_not_minify_doctype: <span class=hljs-type>bool</span>,
    ensure_spec_compliant_unquoted_attribute_values: <span class=hljs-type>bool</span>,
    keep_closing_tags: <span class=hljs-type>bool</span>,
    keep_comments: <span class=hljs-type>bool</span>,
    keep_html_and_head_opening_tags: <span class=hljs-type>bool</span>,
    keep_spaces_between_attributes: <span class=hljs-type>bool</span>,
    minify_css: <span class=hljs-type>bool</span>,
    minify_js: <span class=hljs-type>bool</span>,
    remove_bangs: <span class=hljs-type>bool</span>,
    remove_processing_instructions: <span class=hljs-type>bool</span>,
) <span class=hljs-punctuation>-></span> *<span class=hljs-keyword>const</span> c_char {

    <span class=hljs-keyword>let</span> <span class=hljs-variable>code</span> = <span class=hljs-keyword>unsafe</span> { CStr::<span class="hljs-title function_ invoke__">from_ptr</span>(code) };
    <span class=hljs-keyword>let</span> <span class=hljs-variable>code_vec</span> = code.<span class="hljs-title function_ invoke__">to_bytes</span>();

    <span class=hljs-keyword>let</span> <span class=hljs-variable>cfg</span> = Cfg {
        do_not_minify_doctype,
        ensure_spec_compliant_unquoted_attribute_values,
        keep_closing_tags,
        keep_comments,
        keep_html_and_head_opening_tags,
        keep_spaces_between_attributes,
        minify_css,
        minify_js,
        remove_bangs,
        remove_processing_instructions,
    };

    <span class=hljs-keyword>let</span> <span class=hljs-variable>minified</span> = <span class="hljs-title function_ invoke__">minify_html_native</span>(code_vec, &cfg);

    <span class=hljs-keyword>let</span> <span class=hljs-variable>s</span> = <span class=hljs-keyword>unsafe</span> { CString::<span class="hljs-title function_ invoke__">from_vec_unchecked</span>(minified).<span class="hljs-title function_ invoke__">into_raw</span>() };
    <span class=hljs-keyword>return</span> s;
}</code></pre><h1 id=nimpy_and_the_quest_for_crash_free_garbage_deletion><a class=header-anchor href=#nimpy_and_the_quest_for_crash_free_garbage_deletion> Nimpy і квест безаварійного видалення сміття</a></h1><p><a href=https://github.com/yglukhov/nimpy/> Прив’язки Python для nim</a> потрібно звільнити відкидання об’єктів python. Проблема полягає в тому, що ми повинні контролювати, коли nim виконує GC. Бібліотека nimpy припускає, що GIL завжди заблоковано (вона блокує його на початку), тому вона може вільно звертатися до python будь-коли. Але ми розблоковуємо gil, щоб дозволити пулу потоків python запускати код, тоді як nim запускає інші речі. Якби GIL python завжди блокувався nim, пул потоків був би неактивним більшу частину часу.<pre><code class="nim hljs"><span class=hljs-keyword>when</span> defined(pyAsync):
  <span class=hljs-keyword>type</span>
    <span class=hljs-type>PyGilObj</span> = <span class=hljs-keyword>object</span>
      lock: <span class=hljs-type>ThreadLock</span>
      currentLockHolder: <span class=hljs-type>int</span>
      state: <span class=hljs-type>PyGILState_STATE</span>
    <span class=hljs-type>PyGil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>PyGilObj</span>

  <span class=hljs-keyword>var</span> pyGil*: <span class=hljs-type>PyGil</span>
  <span class=hljs-keyword>var</span> pyGilLock*: <span class=hljs-type>ThreadLock</span>
  <span class=hljs-keyword>var</span> pyMainThread: <span class=hljs-type>PyThreadState</span>
  <span class=hljs-keyword>proc</span> initPyGil*() =
    assert <span class=hljs-type>PyGILState_Check</span>()
    pyGil = create(<span class=hljs-type>PyGilObj</span>)
    pyGil.currentLockHolder = getThreadID()
    pyGil.lock = newThreadLock()
    pyGilLock = pyGil.lock
    pyMainThread = <span class=hljs-type>PyEval_SaveThread</span>()

  <span class=hljs-keyword>proc</span> acquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.async.}</span> =
    await gil.lock.acquire
    <span class=hljs-keyword>let</span> id = getThreadId()
    gil.currentLockHolder = id
    gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()

  <span class=hljs-keyword>proc</span> tryAcquire*(gil: <span class=hljs-type>PyGil</span>): <span class=hljs-type>bool</span> =
    <span class=hljs-keyword>if</span> gil.lock.tryAcquire():
      <span class=hljs-keyword>let</span> id = getThreadId()
      gil.currentLockHolder = id
      gil.state = <span class=hljs-type>Py_GILState_Ensure</span>()
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

  <span class=hljs-keyword>proc</span> release*(gil: <span class=hljs-type>PyGil</span>) <span class=hljs-meta>{.inline.}</span> =
    doassert gil.currentLockHolder == getThreadId(), <span class=hljs-string>"Can't release gil lock from a different thread."</span>
    doassert gilLocked()
    <span class=hljs-type>Py_GILState_Release</span>(gil.state)
    gil.lock.release</code></pre><p>Це дозволяє виконувати код python, утримуючи GIL, але лише в поточному потоці. Реалізація для отримання/випуску GIL у різних потоках nim вимагає виклику різних функцій python C abi, оскільки GIL є м’ютексом. Потім ми викликаємо python за допомогою цього шаблону:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> withPyLock*(code): untyped =
  <span class=hljs-meta>{.locks: [pyGil].}</span>:
    <span class=hljs-keyword>try</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(), " -- ", procName()</span>
      await pygil.acquire()
      code
    <span class=hljs-keyword>except</span>:
      <span class=hljs-keyword>raise</span> getCurrentException()
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-comment># echo getThreadId(), " -- ", getCurrentProcessId(),  " -- unlocked"</span>
      pygil.release()</code></pre><p>Ми використовуємо функцію nim locks і guards, щоб забезпечити доступ до типів python лише тоді, коли утримується GIL. Однак для цього потрібно визначити pyobjects за допомогою guard:<pre><code class="nim hljs"><span class=hljs-keyword>macro</span> pyObjPtr*(defs: <span class=hljs-type>varargs</span>[untyped]): untyped =
  <span class=hljs-built_in>result</span> = newNimNode(nnkStmtList)
  <span class=hljs-keyword>for</span> d <span class=hljs-keyword>in</span> defs:
    <span class=hljs-keyword>let</span>
      name = d[<span class=hljs-number>0</span>]
      def = d[<span class=hljs-number>1</span>]
    <span class=hljs-built_in>result</span>.add quote <span class=hljs-keyword>do</span>:
      <span class=hljs-keyword>let</span> `name` <span class=hljs-meta>{.guard: pyGil.}</span> = create(<span class=hljs-type>PyObject</span>)
      `name`[] = `def`</code></pre><p>Тож я можу зробити:<pre><code class="nim hljs">pyObjPtr(myVar, pyimport(<span class=hljs-string>"datetime"</span>).datetime))</code></pre><p>І щоразу, коли дзвоню<code>myVar</code> який містить об’єкт datetime, я маю обгорнути його так:<pre><code class="nim hljs">withPyLock():
  myVar.fromunixtimestamp(<span class=hljs-number>1</span>)</code></pre><p>Тепер ми можемо заблокувати gil, коли нам потрібно запустити GC, перевизначивши nimpy<code>PyObject</code> деструктор з цим:<pre><code class="nim hljs"><span class=hljs-keyword>var</span> garbage: <span class=hljs-type>seq</span>[<span class=hljs-type>PPyObject</span>]

<span class=hljs-keyword>proc</span> `=destroy`*(p: <span class=hljs-keyword>var</span> <span class=hljs-type>PyObject</span>) =
  <span class=hljs-keyword>if</span> pygil.tryAcquire:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      decRef p.rawPyObj
      p.rawPyObj = <span class=hljs-keyword>nil</span>
    <span class=hljs-keyword>while</span> garbage.len > <span class=hljs-number>1</span>:
      <span class=hljs-keyword>var</span> pp = garbage.pop() <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Does this leak a pointer?</span>
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pp.isnil:
        decRef pp
      pp = <span class=hljs-keyword>nil</span>
    pygil.release
  <span class=hljs-keyword>else</span>:
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> p.rawPyObj.isnil:
      garbage.add p.rawPyObj</code></pre><p>Блокування, яке ми використовуємо всередині деструктора, не є<code>AsyncLock</code> оскільки це було б занадто дорого, і ми<em> не треба</em> завжди замикайте, оскільки це призведе до зупинок! Якщо ми не можемо заблокувати gil, ми відкладаємо збір і зберігаємо необроблений вказівник python, поки ми зможемо його очистити. Чесно кажучи, я не знаю, чи це викликає інші форми проблем, але, здається, це працює<em> досить добре</em>.<p>У нас є модуль nim під назвою<code>pyutils.nim</code> який виконує купу речей nim<>python, наприклад:<pre><code class="nim hljs"><span class=hljs-keyword>from</span> utils <span class=hljs-keyword>import</span> withLocks
<span class=hljs-keyword>proc</span> pyhasAttr*(o: <span class=hljs-type>PyObject</span>; a: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> = pybi[].hasattr(
    o, a).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyclass(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>PyObject</span> <span class=hljs-meta>{.inline, withLocks: [pyGil].}</span> =
  pybi[].<span class=hljs-keyword>type</span>(py)

<span class=hljs-keyword>proc</span> pytype*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>string</span> =
  py.pyclass.getattr(<span class=hljs-string>"__name__"</span>).to(<span class=hljs-type>string</span>)

<span class=hljs-keyword>proc</span> pyisbool*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> pybi[].isinstance(py, <span class=hljs-type>PyBoolClass</span>[]).to(<span class=hljs-type>bool</span>)

<span class=hljs-keyword>proc</span> pyisnone*(py: <span class=hljs-type>PyObject</span>): <span class=hljs-type>bool</span> <span class=hljs-meta>{.gcsafe, withLocks: [pyGil].}</span> =
  <span class=hljs-keyword>return</span> py.isnil <span class=hljs-keyword>or</span> pybi[].isinstance(py, <span class=hljs-type>PyNoneClass</span>[]).to(<span class=hljs-type>bool</span>)</code></pre><p>Цей використовується досить часто:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pyget*[T](py: <span class=hljs-type>PyObject</span>; k: <span class=hljs-type>string</span>; def: T = <span class=hljs-string>""</span>): T =
  <span class=hljs-keyword>try</span>:
    <span class=hljs-keyword>let</span> v = py.callMethod(<span class=hljs-string>"get"</span>, k)
    <span class=hljs-keyword>if</span> pyisnone(v):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> v.to(T)
  <span class=hljs-keyword>except</span>:
    pyErrClear()
    <span class=hljs-keyword>if</span> pyisnone(py):
      <span class=hljs-keyword>return</span> def
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>return</span> py.to(T)</code></pre><p>Цей використовується, коли ми запланували завдання python і хочемо дочекатися його завершення асинхронно:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pywait*(j: <span class=hljs-type>PyObject</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>PyObject</span>] <span class=hljs-meta>{.async, gcsafe.}</span> =
  <span class=hljs-keyword>var</span> rdy: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>var</span> res: <span class=hljs-type>PyObject</span>
  <span class=hljs-keyword>while</span> <span class=hljs-literal>true</span>:
    withPyLock:
      checkNil(j)
      rdy = j.callMethod(<span class=hljs-string>"ready"</span>).to(<span class=hljs-type>bool</span>)
    <span class=hljs-keyword>if</span> rdy:
      withPyLock:
        checkNil(j)
        res = j.callMethod(<span class=hljs-string>"get"</span>)
      <span class=hljs-keyword>break</span>
    await sleepAsync(<span class=hljs-number>250</span>.milliseconds)
  withPyLock:
    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>not</span> res.isnil) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyisnone(res)) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> pyErrOccurred()):
      <span class=hljs-keyword>return</span> res
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>"Python job failed."</span>)</code></pre><p>Належне асинхронне прив’язування python вимагало б завершення nim async future з python наприкінці запланованого завдання python, чого ми не робимо, тому що ми недостатньо глибоко вивчали обробку об’єктів nim з python.<h2 id=ampification><a class=header-anchor href=#ampification> Амфікація</a></h2><p>Ми підтримуємо google amp, тому ми створюємо певною мірою сумісні сторінки amp. Ми не ставимо за мету підтримку 1:1. Насправді ми обробляємо весь JavaScript, який маємо, і обслуговуємо лише html/css. Навіть тоді ми маємо бути обережними, щоб не додавати користувацькі атрибути до тегів html або просто користувальницькі теги html, amp поганий такий... Для автоматичного перетворення сторінок amp ми обробляємо<code>head</code> і<code>body</code> позначати по-різному.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processHead(inHead: <span class=hljs-type>VNode</span>, outHead: <span class=hljs-type>VNode</span>, level = <span class=hljs-number>0</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> canonicalUnset = level == <span class=hljs-number>0</span>
  debug <span class=hljs-string>"iterating over {inHead.kind}"</span>
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> inHead.preorder(withStyles = <span class=hljs-literal>true</span>):
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.text, skipNodes:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
        <span class=hljs-keyword>if</span> el.len > <span class=hljs-number>0</span>:
          el[<span class=hljs-number>0</span>].text.maybeStyle
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
        <span class=hljs-keyword>if</span> canonicalUnset <span class=hljs-keyword>and</span> el.isLink(canonical):
          outHead.add el
          canonicalUnset = <span class=hljs-literal>false</span>
        <span class=hljs-keyword>elif</span> el.isLink(stylesheet) <span class=hljs-keyword>and</span> (<span class=hljs-keyword>not</span> (<span class=hljs-string>"flags-sprite"</span> <span class=hljs-keyword>in</span> el.getattr(<span class=hljs-string>"href"</span>))):
          await el.fetchStyle()
        <span class=hljs-keyword>elif</span> el.isLink(preload) <span class=hljs-keyword>and</span> el.getattr(<span class=hljs-string>"as"</span>) == <span class=hljs-string>"style"</span>:
          await el.fetchStyle()
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
        <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.meta:
        <span class=hljs-keyword>if</span> (el.getAttr(<span class=hljs-string>"name"</span>) == <span class=hljs-string>"viewport"</span>) <span class=hljs-keyword>or</span> (el.getAttr(<span class=hljs-string>"charset"</span>) != <span class=hljs-string>""</span>):
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>else</span>:
          outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.verbatim:
        <span class=hljs-keyword>let</span> data = el.toXmlNode
        <span class=hljs-keyword>if</span> data.kind == xnElement:
          <span class=hljs-keyword>if</span> data.tag == <span class=hljs-string>"noscript"</span>:
            processNoScript()
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"script"</span>:
            <span class=hljs-keyword>continue</span>
          <span class=hljs-keyword>elif</span> data.tag == <span class=hljs-string>"style"</span>:
            <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
              data[<span class=hljs-number>0</span>].text.maybeStyle
          <span class=hljs-keyword>else</span>:
            outHead.add el
      <span class=hljs-keyword>of</span> <span class=hljs-type>VNodekind</span>.noscript:
        processNoScript()
      <span class=hljs-keyword>else</span>:
        debug <span class=hljs-string>"amphead: adding element {el.kind} to outHead."</span>
        outHead.add el</code></pre><p>Усі стилі об’єднано в єдиний вбудований сценарій, те, що зберігається<code>link</code> теги, які не є style/jscript, наприклад lang. Теги сценарію для<code>ldljson</code>, <code>meta</code> теги. Verbatim обробляє вузли, які є<em> буквальний</em> , ми повинні перетворити їх на<code>XmlNode</code> (що означає синтаксичний аналіз) і обробляти його правильно. Тіло процесу схоже, ми зберігаємо одні теги, видаляємо інші, перейменовуємо треті:<pre><code class="nim hljs"><span class=hljs-keyword>template</span> process(el: <span class=hljs-type>VNode</span>, after: untyped): <span class=hljs-type>bool</span> =
  <span class=hljs-keyword>var</span> isprocessed = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>case</span> el.kind:
    <span class=hljs-keyword>of</span> skipNodes: <span class=hljs-keyword>discard</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.link:
      <span class=hljs-keyword>if</span> el.isLink(stylesheet):
        await el.fetchStyle()
      <span class=hljs-keyword>else</span>:
        outBody.add el
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.style:
      el.text.maybeStyle
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.script:
      <span class=hljs-keyword>if</span> el.getAttr(<span class=hljs-string>"type"</span>) == $ldjson:
        outHead.add el
      el.text = <span class=hljs-string>""</span>
    <span class=hljs-keyword>of</span> <span class=hljs-type>VNodeKind</span>.form:
      el.setAttr(<span class=hljs-string>"amp-form"</span>, <span class=hljs-string>""</span>)
    <span class=hljs-keyword>else</span>:
      isprocessed = <span class=hljs-literal>false</span>
  <span class=hljs-keyword>if</span> isprocessed:
    after
  isprocessed</code></pre><p>Файл<code>form</code> тег замінено на<code>amp-form</code> , amp має багато таких тегів...<p>Ми повинні переконатися, що вбудовані стилі мають правильну довжину:<pre><code class="nim hljs">styleStr = styleStr
  <span class=hljs-comment># .join("\n")</span>
  <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> the replacement should be ordered from most frequent to rarest</span>
  <span class=hljs-comment># # remove troublesome animations</span>
  .replace(<span class=hljs-string>pre"""\s*?@(\-[a-zA-Z]+-)?keyframes\s+?.+?{\s*?.+?({.+?})+?\s*?}"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># # remove !important hints</span>
  .replace(<span class=hljs-string>pre"""!important"""</span>, <span class=hljs-string>""</span>)
  <span class=hljs-comment># remove charset since not allowed</span>
  .replace(<span class=hljs-string>pre"""@charset\s+\"</span>utf-<span class=hljs-number>8</span>\<span class=hljs-string>"\s*;?/i"</span><span class=hljs-string>""</span>, <span class=hljs-string>""</span>)

<span class=hljs-keyword>if</span> unlikely(styleStr.len > <span class=hljs-type>CSS_MAX_SIZE</span>):
  <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>ValueError</span>, <span class=hljs-string>fmt"Style size above limit for amp pages. {styleStr.len}"</span>)</code></pre><p>Наше покоління підсилювачів не охоплює повну специфікацію підсилювача, але воно працює для нашого вмісту (методом проб і помилок :S).<h2 id=search><a class=header-anchor href=#search> Пошук</a></h2><p>Кожного разу, коли стаття публікується, вона потрапляє в звукову базу даних, звукова база даних обробляє «колекції», «відра» та «об’єкти»; Ми визначаємо колекцію як веб-сайт, тому кожен веб-сайт, який хоче розгорнути агрегатор вмісту, має власну колекцію. Ми не використовуємо<code>buckets</code> , хоча ми могли б вважати кожну тему сегментом, що надто звузило б пошук, тому кожен сайт має лише одне сегмент «за замовчуванням», і кожен об’єкт сегмента є статтею (яка може мати різні теми).<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> push*(capts: <span class=hljs-type>UriCaptures</span>, content: <span class=hljs-type>string</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment>## Push the contents of an article page to the search database</span>
  <span class=hljs-comment>## <span class=hljs-doctag>NOTE:</span> NOT thread safe</span>
  <span class=hljs-keyword>var</span> ofs = <span class=hljs-number>0</span>
  <span class=hljs-keyword>while</span> ofs <= content.len:
    <span class=hljs-keyword>let</span> view = content[ofs..^<span class=hljs-number>1</span>]
    <span class=hljs-keyword>let</span> key = join([capts.topic, capts.page, capts.art], <span class=hljs-string>"/"</span>)
    <span class=hljs-keyword>let</span> cnt = runeSubStr(view, <span class=hljs-number>0</span>, min(view.len, bufsize - key.len))
    ofs += cnt.len
    <span class=hljs-keyword>if</span> cnt.len == <span class=hljs-number>0</span>:
      <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>try</span>:
      <span class=hljs-keyword>let</span> lang = await capts.lang.toISO3
      <span class=hljs-keyword>var</span> pushed: <span class=hljs-type>bool</span>
      <span class=hljs-keyword>var</span> j: <span class=hljs-type>PyObject</span>
      withPyLock:
        j = pySched[].apply(
          pySonic[].push,
          <span class=hljs-type>WEBSITE_DOMAIN</span>,
          <span class=hljs-string>"default"</span>, <span class=hljs-comment># <span class=hljs-doctag>TODO:</span> Should we restrict search to `capts.topic`?</span>
          key,
          cnt,
          lang = <span class=hljs-keyword>if</span> capts.lang != <span class=hljs-string>"en"</span>: lang <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>
          )
      j = await j.pywait()
      withPyLock:
        pushed = <span class=hljs-keyword>not</span> pyisnone(j) <span class=hljs-keyword>and</span> j.to(<span class=hljs-type>bool</span>)
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> pushed:
          capts.addToBackLog()
          <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      logexc()
      debug <span class=hljs-string>"sonic: couldn't push content, \n {capts} \n {key} \n {cnt}"</span>
      <span class=hljs-keyword>when</span> <span class=hljs-keyword>not</span> defined(release):
        capts.addToBackLog()
        <span class=hljs-keyword>block</span>:
          <span class=hljs-keyword>var</span> f: <span class=hljs-type>File</span>
          <span class=hljs-keyword>try</span>:
            await pushLock[].acquire
            f = open(<span class=hljs-string>"/tmp/sonic_debug.log"</span>, fmWrite)
            write(f, cnt)
          <span class=hljs-keyword>finally</span>:
            pushLock[].release
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> f.isnil:
              f.close()
      <span class=hljs-keyword>break</span></code></pre><p>Під час надсилання вмісту в Sonic ми повинні розділити дані на частини, максимальна довжина яких відома після підключення. Здається, інколи надсилання даних має помилки, оскільки воно не може обробляти певні символи. Якщо звуковий сервер якимось чином зламався, ми також маємо функцію повторного прийому всього вмісту:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> pushAllSonic*() <span class=hljs-meta>{.async.}</span> =
  await syncTopics()
  <span class=hljs-keyword>var</span> total, c, pagenum: <span class=hljs-type>int</span>
  <span class=hljs-keyword>let</span> pushLog = await readPushLog()
  <span class=hljs-keyword>if</span> pushLog.len == <span class=hljs-number>0</span>:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].flush(<span class=hljs-type>WEBSITE_DOMAIN</span>)
  defer:
    withPyLock:
      <span class=hljs-keyword>discard</span> pySonic[].consolidate()
  <span class=hljs-keyword>for</span> (topic, state) <span class=hljs-keyword>in</span> topicsCache:
    <span class=hljs-keyword>if</span> topic <span class=hljs-keyword>notin</span> pushLog:
      pushLog[topic] = %<span class=hljs-number>0</span>
    await pygil.acquire
    defer: pygil.release
    <span class=hljs-keyword>let</span> done = state.group[][<span class=hljs-string>"done"</span>]
    <span class=hljs-keyword>for</span> page <span class=hljs-keyword>in</span> done:
      pagenum = ($page).parseint
      c = len(done[page])
      <span class=hljs-keyword>if</span> pushLog[topic].to(<span class=hljs-type>int</span>) >= pagenum:
        <span class=hljs-keyword>continue</span>
      <span class=hljs-keyword>var</span> futs: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
      <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..&LTc:
        <span class=hljs-keyword>let</span> ar = done[page][n]
        <span class=hljs-keyword>if</span> ar.isValidArticlePy:
          <span class=hljs-keyword>var</span> relpath = getArticlePath(ar, topic)
          relpath.removeSuffix(<span class=hljs-string>"/"</span>)
          <span class=hljs-keyword>let</span>
            capts = uriTuple(relpath)
            content = ar.pyget(<span class=hljs-string>"content"</span>).sanitize
          echo <span class=hljs-string>"pushing "</span>, relpath
          futs.add push(capts, content)
          total.inc
      pygil.release
      await allFutures(futs)
      pushLog[topic] = %pagenum
      await writePushLog(pushLog)
      await pygil.acquire
  info <span class=hljs-string>"Indexed search for {WEBSITE_DOMAIN} with {total} objects."</span></code></pre><h2 id=translation><a class=header-anchor href=#translation> Переклад</a></h2><p>Переклад – це досить заплутана історія. Я перебуваю на своїй четвертій (!) реалізації оболонки перекладу, після того, як написав у php, go and<a href=https://github.com/untoreh/Translator.jl> юлія</a> , це теж написано нім. Варіанти php/go зараз трохи загнили, тоді як варіант julia активно використовується для цього блогу. Однак, щоб досягти низької затримки для веб-сервера, спосіб перекладу, реалізований у julia, не підходить для обслуговування в режимі реального часу (він перекладає статичні файли), і в будь-якому разі додавання julia як залежності, коли ми вже маємо python, було б надто великим. вимога.<p>Тому мені довелося реалізувати новий модуль перекладу в nim. По правді кажучи, початковий модуль перекладу nim виглядав дуже схожим на реалізацію julia, де ми перекладали статичні файли<sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . Згодом, коли веб-сервер почав формуватися, я перемкнув його на переклад вузлів karax на вимогу. Це дозволяє перекладати кожну веб-сторінку саме вчасно для запиту.<pre><code class="nim hljs"><span class=hljs-keyword>template</span> translateVbtm(node: <span class=hljs-type>VNode</span>, q: <span class=hljs-type>QueueDom</span>) =
  assert node.kind == <span class=hljs-type>VNodeKind</span>.verbatim
  <span class=hljs-keyword>let</span> tree = ($node).parseHtml() <span class=hljs-comment># <span class=hljs-doctag>FIXME:</span> this should be a conversion, but the conversion doesn't preserve whitespace??</span>
  <span class=hljs-keyword>if</span> tree.kind == xnElement <span class=hljs-keyword>and</span> tree.tag == <span class=hljs-string>"document"</span>:
    tree.tag = <span class=hljs-string>"div"</span>
  takeOverFields(tree.toVNode, node)
  translateIter(node, vbtm = <span class=hljs-literal>false</span>)

<span class=hljs-keyword>template</span> translateIter(otree; vbtm: <span class=hljs-keyword>static</span>[<span class=hljs-type>bool</span>] = <span class=hljs-literal>true</span>) =
  <span class=hljs-keyword>for</span> el <span class=hljs-keyword>in</span> otree.preorder():
    <span class=hljs-keyword>case</span> el.kind:
      <span class=hljs-keyword>of</span> vdom.<span class=hljs-type>VNodeKind</span>.text:
        <span class=hljs-keyword>if</span> el.text.isEmptyOrWhitespace:
          <span class=hljs-keyword>continue</span>
        <span class=hljs-keyword>if</span> isTranslatable(el):
          translate(q.<span class=hljs-keyword>addr</span>, el, srv)
      <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>let</span> t = el.kind
        <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> tformsTags:
          getTForms(dom)[t](el, file_path, url_path, pair)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.a:
          <span class=hljs-keyword>if</span> el.hasAttr(<span class=hljs-string>"href"</span>):
            rewriteUrl(el, rewrite_path, hostname)
        <span class=hljs-keyword>if</span> t == <span class=hljs-type>VNodeKind</span>.verbatim:
          <span class=hljs-keyword>when</span> vbtm:
            debug <span class=hljs-string>"dom: translating verbatim"</span>, <span class=hljs-literal>false</span>
            translateVbtm(el, q)
        <span class=hljs-keyword>else</span>:
          <span class=hljs-keyword>if</span>(el.hasAttr(<span class=hljs-string>"alt"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"alt"</span>)) <span class=hljs-keyword>or</span>
            (el.hasAttr(<span class=hljs-string>"title"</span>) <span class=hljs-keyword>and</span> el.isTranslatable(<span class=hljs-string>"title"</span>)):
            translate(q.<span class=hljs-keyword>addr</span>, el, srv)</code></pre><p>Вище наведено основний ітераційний цикл<code>translateIter</code>:<ul><li><p><code>getTforms</code> зіставляє функції з тегами html, дозволяючи виконувати мутації в кожному окремому випадку.<li><p><code>rewriteUrl</code> вставляє мовний шлях (наприклад,<code>/en/</code> ) у URL-шляху.<li><p><code>translateVbtm</code> обробляти дослівні вузли, які потребують аналізу.</ul><p>Переклад застосовується до всіх текстових вузлів і до<code>alt</code> та<code>title</code> атрибути.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service) =
  <span class=hljs-keyword>if</span> q.isnil:
    warn <span class=hljs-string>"translate: queue can't be nil"</span>
    <span class=hljs-keyword>return</span>
  <span class=hljs-keyword>let</span> (success, length) = setFromDB(q[].pair, el)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
    <span class=hljs-keyword>if</span> length > q[].bufsize:
      debug <span class=hljs-string>"Translating element singularly since it is big"</span>
      elUpdate(q[], el, srv)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-keyword>if</span> reachedBufSize(length, q[]):
        q[].push()
      q[].bucket.add(el)
      q[].sz += length

<span class=hljs-keyword>proc</span> translate*[T](q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], el: T, srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish:
    <span class=hljs-keyword>if</span> q.isnil:
      <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>
    <span class=hljs-keyword>let</span> (success, _) = setFromDB(q[].pair, el)
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> success:
      addJob(@[el], q[], el.getText)
      debug <span class=hljs-string>"translate: waiting for pair: {q[].pair}"</span>
      await doTrans()
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>

<span class=hljs-keyword>proc</span> translate*(q: <span class=hljs-keyword>ptr</span>[<span class=hljs-type>QueueXml</span> | <span class=hljs-type>QueueDom</span>], srv: service,
    finish: <span class=hljs-type>bool</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>bool</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>if</span> finish <span class=hljs-keyword>and</span> q[].sz > <span class=hljs-number>0</span>:
    q[].push()
    await doTrans()
    saveToDB(force = <span class=hljs-literal>true</span>)
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Оскільки ми маємо перекладати кожен текстовий вузол окремо (інакше ми не зможемо відтворити html), переклад кожного вузла є окремою роботою. Оскільки завдання можуть запитувати служби перекладу в мережі, їх потрібно виконувати асинхронно. Ми робимо поділ і об’єднання запитів на переклад, щоб заощадити виклики API, але не важливо знати внутрішні особливості механізму перекладу. Єдине, що слід зазначити, що спочатку я використовував a<a href=https://github.com/nidhaloff/deep-translator> обгортка python</a> (який я досі використовую для перекладу скопійованого вмісту), оскільки самокеровані обгортки для зовнішнього apis — це біль, але потім перейшов на службу перекладу google і yandex із самозагортанням у nim, оскільки python стає значним вузьким місцем під час обробки багатьох одночасних перекладів.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>Насправді спочатку агрегатор вмісту мав лише генерувати статичні файли для<code>caddy</code> щоб обслуговувати, але оскільки кількість сторінок для генерації (яка є матрицею n_lang(20) x amp(2) x page), відкладене рендеринг було кращим варіантом.</table><h2 id=stats><a class=header-anchor href=#stats> статистика</a></h2><p>Сторінки тем і статей відстежуються за кількістю звернень.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> updateHits*(capts: <span class=hljs-type>UriCaptures</span>) =
  <span class=hljs-keyword>let</span> ak = join([capts.topic, capts.art])
  <span class=hljs-keyword>let</span> tk = capts.topic
  <span class=hljs-keyword>var</span>
    artCount: <span class=hljs-type>int32</span> = statsDB[ak]
    topicCount: <span class=hljs-type>int32</span> = statsDB[tk]
  artCount += <span class=hljs-number>1</span>
  topicCount += <span class=hljs-number>1</span>
  statsDB[ak] = artCount
  statsDB[tk] = topicCount</code></pre><p>Ми використовуємо підрахунок відвідувань, щоб періодично очищати сторінки з низькою кількістю.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> deleteLowTrafficArts*(topic: <span class=hljs-type>string</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>void</span>] <span class=hljs-meta>{.gcsafe, async.}</span> =
  <span class=hljs-keyword>let</span> now = getTime()
  <span class=hljs-keyword>var</span>
    pagenum: <span class=hljs-type>int</span>
    pagesToReset: <span class=hljs-type>seq</span>[<span class=hljs-type>int</span>]
    pubTime: <span class=hljs-type>Time</span>
    pubTimeTs: <span class=hljs-type>int</span>
  <span class=hljs-keyword>var</span> capts = mUriCaptures()
  capts.topic = topic
  <span class=hljs-keyword>for</span> (art, _) <span class=hljs-keyword>in</span> (await publishedArticles[<span class=hljs-type>string</span>](topic, <span class=hljs-string>""</span>)):
    withPyLock:
      <span class=hljs-keyword>if</span> pyisnone(art):
        <span class=hljs-keyword>continue</span>
      capts.art = pyget[<span class=hljs-type>string</span>](art, <span class=hljs-string>"slug"</span>)
      pagenum = pyget(art, <span class=hljs-string>"page"</span>, <span class=hljs-number>0</span>)
    capts.page = pagenum.intToStr
    <span class=hljs-keyword>try</span>:
      withPyLock:
        pubTimeTs = pyget(art, <span class=hljs-string>"pubTime"</span>, <span class=hljs-number>0</span>)
      pubTime = fromUnix(pubTimeTs)
    <span class=hljs-keyword>except</span>:
      pubTime = default(<span class=hljs-type>Time</span>)
    <span class=hljs-keyword>if</span> pubTime == default(<span class=hljs-type>Time</span>):
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> (pagenum <span class=hljs-keyword>in</span> pagesToReset):
        debug <span class=hljs-string>"tasks: resetting pubTime for page {pagenum}"</span>
        pagesToReset.add pagenum
    <span class=hljs-comment># article is old enough</span>
    <span class=hljs-keyword>elif</span> inSeconds(now - pubTime) > cfg.<span class=hljs-type>CLEANUP_AGE</span>:
      <span class=hljs-keyword>let</span> hits = topic.getHits(capts.art)
      <span class=hljs-comment># article has low hit count</span>
      <span class=hljs-keyword>if</span> hits < cfg.<span class=hljs-type>CLEANUP_HITS</span>:
        await deleteArt(capts)
  <span class=hljs-keyword>for</span> n <span class=hljs-keyword>in</span> pagesToReset:
    withPyLock:
      <span class=hljs-keyword>discard</span> site[].update_pubtime(topic, n)</code></pre><h2 id=databases><a class=header-anchor href=#databases> Бази даних</a></h2><p>Ми використовуємо<code>libmdbx</code> через<a href=https://github.com/snej/nimdbx> ця бібліотека</a> . Ймовірно, це надмірно, і використання leveldb було б достатнім. У нас є тип<code>LRUTrans</code> де початкова ідея полягала в тому, щоб налаштувати базу даних як кеш LRU, але це було значно повільніше. Реалізацію можна знайти<a href=https://github.com/untoreh/lrudbx/blob/main/lrudbx.nim> тут</a><pre><code class="nim hljs"><span class=hljs-keyword>type</span>
    <span class=hljs-type>CollectionNotNil</span> = <span class=hljs-keyword>ptr</span> <span class=hljs-type>Collection</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
    <span class=hljs-type>LRUTransObj</span> = <span class=hljs-keyword>object</span>
        db: nimdbx.<span class=hljs-type>Database</span>.<span class=hljs-type>Database</span> <span class=hljs-keyword>not</span> <span class=hljs-keyword>nil</span>
        coll: <span class=hljs-type>CollectionNotNil</span>
        zstd_c: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_CCtx</span>
        zstd_d: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ZSTD_DCtx</span>
    <span class=hljs-type>LRUTrans</span>* = <span class=hljs-keyword>ptr</span> <span class=hljs-type>LRUTransObj</span>

<span class=hljs-keyword>proc</span> getImpl(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    withLock(tLock):
        <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
        t.coll.inSnapshot <span class=hljs-keyword>do</span> (cs: <span class=hljs-type>CollectionSnapshot</span>):
            <span class=hljs-comment># debug "nimdbx: looking for key {k}, {v}"</span>
            o.add cs[k.asData].asByteSeq
        <span class=hljs-keyword>if</span> len(o) > <span class=hljs-number>0</span>:
            <span class=hljs-built_in>result</span> = <span class=hljs-keyword>cast</span>[<span class=hljs-type>string</span>](decompress(t.zstd_d, o))
            <span class=hljs-comment># debug "nimdbx: got key {k}, with {o.len} bytes"</span>
        <span class=hljs-keyword>elif</span> throw:
            <span class=hljs-keyword>raise</span> newException(<span class=hljs-type>KeyError</span>, <span class=hljs-string>"nimdbx: key not found"</span>)

<span class=hljs-keyword>proc</span> getImpl[T: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: T, throw: <span class=hljs-keyword>static</span> <span class=hljs-type>bool</span>): <span class=hljs-type>string</span> =
    getImpl(t, hash(k).<span class=hljs-type>int64</span>, throw)


<span class=hljs-keyword>proc</span> `[]`*[T](t: <span class=hljs-type>LRUTrans</span>, k: T): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>false</span>)
<span class=hljs-keyword>proc</span> `get`*[K](t: <span class=hljs-type>LRUTrans</span>, k: K): <span class=hljs-type>auto</span> = t.getImpl(k, <span class=hljs-literal>true</span>)

<span class=hljs-keyword>proc</span> `[]=`*(t: <span class=hljs-type>LRUTrans</span>, k: <span class=hljs-type>int64</span>, v: <span class=hljs-type>string</span>) <span class=hljs-meta>{.gcsafe.}</span> =
    <span class=hljs-keyword>var</span> o: <span class=hljs-type>seq</span>[byte]
    <span class=hljs-keyword>if</span> likely(v.len != <span class=hljs-number>0</span>):
      o = compress(t.zstd_c, v, cfg.<span class=hljs-type>ZSTD_COMPRESSION_LEVEL</span>)
    withLock(tLock):
        logall <span class=hljs-string>"nimdbx: saving key {k}"</span>
        t.coll.inTransaction <span class=hljs-keyword>do</span> (ct: <span class=hljs-type>CollectionTransaction</span>):
            <span class=hljs-meta>{.cast(gcsafe).}</span>:
                ct[k] = o
            ct.commit()
        logall <span class=hljs-string>"nimdbx: commited key {k}"</span>

<span class=hljs-keyword>proc</span> `[]=`*[K: <span class=hljs-keyword>not</span> <span class=hljs-type>int64</span>](t: <span class=hljs-type>LRUTrans</span>, k: K, v: <span class=hljs-type>string</span>) = t[hash(k).<span class=hljs-type>int64</span>] = v</code></pre><p>Цей тип використовується для чотирьох окремих баз даних:<ul><li><p>переклади<li><p>кеш сторінок<li><p>кеш зображень<li><p>статистика</ul><p>Тип бази даних реалізовано за допомогою геттерів і сеттерів, а потім виконує автоматичне розпакування/стиснення під час читання/запису. З цієї причини його не слід використовувати для зображень... але, на жаль... Є також купа маленьких мікрокешів:<ul><li><p>vbtm: для аналізованого (дослівного) вмісту<li><p>пошук: для пошукових запитів<li><p>канали: для каналів тем VNodes<li><p>rxcache: для регулярних виразів, оскільки статичні регулярні вирази під час компіляції ще не стандартизовані (також тому, що в nim є кілька бібліотек регулярних виразів)</ul><p>Вони реалізовані як<a href=https://github.com/jackhftang/lrucache.nim> lru кеші</a><sup id=fnref:2><a class=fnref href=#fndef:2>[2]</a></sup> , точніше як «заблоковані» lru-кеші, де кожна операція отримання та встановлення обертається навколо блокування (потоку). Ці блокування не можуть викликати зупинки в асинхронному середовищі виконання, оскільки блокування отримується та звільняється без будь-якого оператора yield, тому вони є атомарними в цьому сенсі, однак вони все ще корисні, оскільки ми використовуємо потоки для різних завдань.<table class=fndef id=fndef:2><tbody><tr><td class=fndef-backref><a href=#fnref:2>[2]</a><td class=fndef-content>Проте<a href=https://github.com/status-im/nim-stew/blob/master/stew/keyed_queue.nim> нім рагу</a> має простішу реалізацію lru-кешу, яку я б використав, якби її знайшли раніше.</table><h1 id=background_jobs><a class=header-anchor href=#background_jobs> Фонові завдання</a></h1><p>Кілька завдань, які ми використовуємо, потребують процесора, тому ми використовуємо для них інший потік:<ul><li><p>lsh: хешування, чутливе до місцевості, виконує багато обчислень<li><p>зображення: зміна розміру зображення вимагає декодування/кодування зображень, тому це дорого</ul><p>Ще два потоки використовуються для оновлення списку файлів активів і реклами, хоча і не потребують процесора, потік потрібен, щоб уникнути зупинок, спричинених спостерігачем файлів.<p>У нас також є асинхронні довгострокові завдання для:<ul><li><p>переклади<li><p>http запити</ul><p>Завдання Lsh, зображень, перекладу та http-запитів обробляються за допомогою налаштування виробник/споживач. За винятком того, що ми не використовуємо канали, оскільки канали блокуються, і ми не маємо їх асинхронної реалізації, яка також є потокобезпечною. Ми використали асинхронну реалізацію<a href=https://github.com/mashingan/nim-etc/blob/master/sharedseq.nim> це</a><sup id=fnref:1><a class=fnref href=#fndef:1>[1]</a></sup> . І асинхронну таблицю, яка схожа на шину подій<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>AsyncTableObj</span>[K, V] = <span class=hljs-keyword>object</span>
    lock: <span class=hljs-type>ThreadLock</span>
    waiters: <span class=hljs-type>Table</span>[K, <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]]
    table: <span class=hljs-type>Table</span>[K, V]
  <span class=hljs-type>AsyncTable</span>*[K, V] = <span class=hljs-keyword>ptr</span> <span class=hljs-type>AsyncTableObj</span>[K, V]

<span class=hljs-keyword>proc</span> pop*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K): <span class=hljs-type>Future</span>[V] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> popped = <span class=hljs-literal>false</span>
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.table:
      popped = t.table.pop(k, <span class=hljs-built_in>result</span>)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> popped:
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>notin</span> t.waiters:
      t.waiters[k] = newSeq[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]()
    <span class=hljs-keyword>var</span> fut = newFuture[V](<span class=hljs-string>"AsyncTable.pop"</span>)
    t.waiters[k].add fut.<span class=hljs-keyword>addr</span>
    <span class=hljs-built_in>result</span> = await fut

<span class=hljs-keyword>proc</span> put*[K, V](t: <span class=hljs-type>AsyncTable</span>[K, V], k: K, v: V) <span class=hljs-meta>{.async.}</span> =
  withLock(t.lock):
    <span class=hljs-keyword>if</span> k <span class=hljs-keyword>in</span> t.waiters:
      <span class=hljs-keyword>var</span> ws: <span class=hljs-type>seq</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>Future</span>[V]]
      doassert t.waiters.pop(k, ws)
      <span class=hljs-keyword>while</span> ws.len > <span class=hljs-number>0</span>:
        <span class=hljs-keyword>let</span> w = ws.pop()
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> w.isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].isnil <span class=hljs-keyword>and</span> <span class=hljs-keyword>not</span> w[].finished:
          w[].complete(v)
    <span class=hljs-keyword>else</span>:
      t.table[k] = v</code></pre><p>Сервер nim також виконує три асинхронні завдання:<pre><code class="nim hljs"><span class=hljs-keyword>type</span>
  <span class=hljs-type>TaskKind</span> = <span class=hljs-keyword>enum</span> pub, cleanup, mem

<span class=hljs-keyword>proc</span> scheduleTasks(): <span class=hljs-type>TaskTable</span> =
  <span class=hljs-keyword>template</span> addTask(t) =
    <span class=hljs-keyword>let</span> fut = (selectTask t)()
    <span class=hljs-built_in>result</span>[t] = fut
  <span class=hljs-comment># Publishes new articles for one topic every x seconds</span>
  addTask pub
  <span class=hljs-comment># cleanup task for deleting low traffic articles</span>
  addTask cleanup
  <span class=hljs-comment># quit when max memory usage reached</span>
  addTask mem</code></pre><p>Завдання, яке відстежує використання mem, добре мати, щоб уникнути проблем OOM між контейнерним процесом і докером, оскільки докер (чи ядро) не вбиває процес негайно, і в цей період часу сервер може перестати відповідати, тому краще відразу перезапустити вручну.<table class=fndef id=fndef:1><tbody><tr><td class=fndef-backref><a href=#fnref:1>[1]</a><td class=fndef-content>хоча загортання звичайного каналу в асинхронні процедури, ймовірно, краще... на жаль</table><h1 id=images><a class=header-anchor href=#images> Зображення</a></h1><p>Ми використовуємо важелі<a href=https://github.com/imazen/imageflow/releases> потік зображень</a> щоб змінити розмір і локально кешувати зображення. Прив’язки прості, але процес дещо складний. с<code>getImg</code> ми отримуємо дані зображення з віддаленої URL-адреси:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> getImg*(src: <span class=hljs-type>string</span>, kind: <span class=hljs-type>Source</span>): <span class=hljs-type>Future</span>[<span class=hljs-type>string</span>] <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>return</span> <span class=hljs-keyword>case</span> kind:
    <span class=hljs-keyword>of</span> urlsrc:
      (await get(src.parseUri, decode = <span class=hljs-literal>false</span>, proxied = <span class=hljs-literal>false</span>)).body
    <span class=hljs-keyword>elif</span> fileExists(src):
      await readFileAsync(src)
    <span class=hljs-keyword>else</span>:
      <span class=hljs-string>""</span></code></pre><p>Потім ми повинні додати його до контексту Imageflow:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> addImg*(img: <span class=hljs-type>string</span>): <span class=hljs-type>bool</span> =
  <span class=hljs-comment>## a lock should be held here throughout the `processImg` call.</span>
  <span class=hljs-keyword>if</span> img == <span class=hljs-string>""</span>: <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>
  reset(ctx)
  doassert ctx.check
  <span class=hljs-keyword>let</span> a = imageflow_context_add_input_buffer(
    ctx.p,
    inputIoId,
    <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> The image is held in cache, but it might be collected</span>
    <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](img[<span class=hljs-number>0</span>].unsafeAddr),
    img.len.csize_t,
    imageflow_lifetime_lifetime_outlives_context)
  <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> a:
    doassert ctx.check
    cmdStr[<span class=hljs-string>"decode"</span>] = %inputIoId
  <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span></code></pre><p>Якщо зображення не можна додати, це означає, що imageflow не розпізнає дані як дійсне зображення. Після того, як ми надіслали дані, ми повинні надіслати запит до контексту, потім прочитати відповідь і отримати результат:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> doProcessImg(input: <span class=hljs-type>string</span>, mtd = execMethod): (<span class=hljs-type>string</span>, <span class=hljs-type>string</span>) =
  setCmd(input)
  <span class=hljs-keyword>let</span> c = $cmd
  <span class=hljs-comment># debug "{hash(c)} - {c}"</span>
  <span class=hljs-keyword>let</span> json_res = imageflow_context_send_json(
      ctx.p,
      mtd,
      <span class=hljs-keyword>cast</span>[<span class=hljs-keyword>ptr</span> <span class=hljs-type>uint8</span>](c[<span class=hljs-number>0</span>].unsafeAddr),
      c.len.csize_t
    )
  <span class=hljs-keyword>discard</span> imageflow_json_response_read(ctx.p, json_res,
                                       status.<span class=hljs-keyword>addr</span>,
                                       resPtr,
                                       resLen)
  defer: doassert imageflow_json_response_destroy(ctx.p, json_res)

  <span class=hljs-keyword>var</span> mime: <span class=hljs-type>string</span>
  <span class=hljs-keyword>if</span> status != <span class=hljs-number>200</span>:
    <span class=hljs-keyword>let</span> msg = resPtr[].toString(resLen[].<span class=hljs-type>int</span>)
    debug <span class=hljs-string>"imageflow: conversion failed {msg}"</span>
    doassert ctx.check
  <span class=hljs-keyword>else</span>:
    mime = getMime()
  <span class=hljs-keyword>discard</span> imageflow_context_get_output_buffer_by_id(
      ctx.p,
      outputIoId,
      outputBuffer,
      outputBufferLen)
  doassert ctx.check
  <span class=hljs-built_in>result</span> = (outputBuffer[].toString(outputBufferLen[].<span class=hljs-type>int</span>), mime)</code></pre><p>Ми отримуємо тип mime з відповіді, який буде передано у відповідь веб-сервера. Зі сторони сервера переклад URL-шляху до потоку зображень обробляється так:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> processImgData(q: <span class=hljs-keyword>ptr</span> <span class=hljs-type>ImgQuery</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-comment># push img to imageflow context</span>
  initImageFlow() <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> this initializes thread vars</span>
  <span class=hljs-keyword>var</span> acquired, submitted: <span class=hljs-type>bool</span>
  <span class=hljs-keyword>let</span> data = (await q.url.rawImg)
  defer:
    <span class=hljs-keyword>if</span> acquired: imgLock[].release
    <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> submitted:
      imgOut[q] = <span class=hljs-literal>true</span>
  <span class=hljs-keyword>if</span> data.len > <span class=hljs-number>0</span>:
    <span class=hljs-keyword>try</span>:
      await imgLock[].acquire
      acquired = <span class=hljs-literal>true</span>
      <span class=hljs-keyword>if</span> addImg(data):
        <span class=hljs-keyword>let</span> query = <span class=hljs-string>fmt"width={q.width}&height={q.height}&mode=max&format=webp"</span>
        logall <span class=hljs-string>"ifl server: serving image hash: {hash(await q.url.rawImg)}, size: {q.width}x{q.height}"</span>
        <span class=hljs-comment># process and send back</span>
        (q.processed.data, q.processed.mime) = processImg(query)
        imgOut[q] = <span class=hljs-literal>true</span>
        submitted = <span class=hljs-literal>true</span>
    <span class=hljs-keyword>except</span> <span class=hljs-type>Exception</span>:
      <span class=hljs-keyword>discard</span></code></pre><p>URL-адреса зображення надсилається як параметр у стиснутій формі zstd. Стиснення скорочує URL-адреси (у більшості випадків). Це також те, як я знайшов помилку в google chrome, через яку він не міг обробити URL-адреси, де запит мав URL-кодовані стиснені дані. Натомість Firefox був у порядку.<h2 id=ld-json><a class=header-anchor href=#ld-json> LD-JSON</a></h2><p>Ми додаємо до кожної веб-сторінки скрипти ldjson.<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> jwebpage(id, title, url, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>], name = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>,
            image = <span class=hljs-string>""</span>, entity = <span class=hljs-string>"Article"</span>, status = <span class=hljs-string>"Published"</span>, lang = <span class=hljs-string>"english"</span>, mentions: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = (@[]), access_mode = (@[<span class=hljs-string>"textual"</span>, <span class=hljs-string>"visual"</span>]), access_sufficient: <span class=hljs-type>seq</span>[
            <span class=hljs-type>string</span>] = @[], access_summary = <span class=hljs-string>""</span>, created = <span class=hljs-string>""</span>, published = <span class=hljs-string>""</span>,
            props = default(<span class=hljs-type>JsonNode</span>)): <span class=hljs-type>JsonNode</span> =
    <span class=hljs-keyword>let</span>
        d_mtime = coerce(mtime, <span class=hljs-string>""</span>)
        s_created = created.toIsoDate
        description = coerce(description, to = title)
        prd = (v: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>]) => v.len == <span class=hljs-number>0</span>

    <span class=hljs-keyword>let</span> data = %*{
        <span class=hljs-string>"@context"</span>: <span class=hljs-string>"https://schema.org"</span>,
        <span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/WebPage"</span>,
        <span class=hljs-string>"@id"</span>: id,
        <span class=hljs-string>"url"</span>: url,
        <span class=hljs-string>"lastReviewed"</span>: coerce(mtime, <span class=hljs-string>""</span>),
        <span class=hljs-string>"mainEntityOfPage"</span>: {
            <span class=hljs-string>"@type"</span>: entity,
            <span class=hljs-string>"@id"</span>: url
        },
        <span class=hljs-string>"mainContentOfPage"</span>:
        {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"WebPageElement"</span>, <span class=hljs-string>"cssSelector"</span>: selector},
        <span class=hljs-string>"accessMode"</span>: access_mode,
        <span class=hljs-string>"accessModeSufficient"</span>: {
            <span class=hljs-string>"@type"</span>: <span class=hljs-string>"itemList"</span>,
            <span class=hljs-string>"itemListElement"</span>: coercf(access_sufficient, prd, to = access_mode),
        },
        <span class=hljs-string>"creativeWorkStatus"</span>: status,
        <span class=hljs-comment># <span class=hljs-doctag>NOTE:</span> datePublished should always be provided</span>
        <span class=hljs-string>"datePublished"</span>: ensure_time(d_mtime.toIsoDate, s_created),
        <span class=hljs-string>"dateModified"</span>: d_mtime,
        <span class=hljs-string>"dateCreated"</span>: coerce(s_created, to = d_mtime),
        <span class=hljs-string>"name"</span>: coerce(name, to = title),
        <span class=hljs-string>"description"</span>: coerce(description, <span class=hljs-string>""</span>),
        <span class=hljs-string>"keywords"</span>: coerce(keywords, to = (@[]))
    }
    setArgs data, %*{<span class=hljs-string>"inLanguage"</span>: lang, <span class=hljs-string>"accessibilitySummary"</span>: access_summary,
                    <span class=hljs-string>"headline"</span>: coerce(headline, to = description), <span class=hljs-string>"image"</span>: image,
                    <span class=hljs-string>"mentions"</span>: mentions}
    setProps
    data</code></pre><p>І для перекладених сторінок:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> translation*(src_url, trg_url, lang, title, mtime, selector, description: <span class=hljs-type>auto</span>, keywords: <span class=hljs-type>seq</span>[<span class=hljs-type>string</span>],
                     image = <span class=hljs-string>""</span>, headline = <span class=hljs-string>""</span>, props = default(<span class=hljs-type>JsonNode</span>),
                     translator_name = <span class=hljs-string>"Google"</span>, translator_url = <span class=hljs-string>"https://translate.google.com/"</span>): <span class=hljs-type>auto</span> =
    <span class=hljs-comment>## file path must be relative to the project directory, assumes the published website is under '__site/'</span>
    <span class=hljs-comment># id, title, url, mtime, selector, description: auto, keywords: seq[string], name = "", headline = "",</span>
    <span class=hljs-keyword>let</span> data = jwebpage(id = trg_url, title, url = trg_url, mtime, selector, description,
                            keywords = keywords, image = image, headline = headline, lang = lang, props = props)
    data[<span class=hljs-string>"translator"</span>] = %*{<span class=hljs-string>"@type"</span>: <span class=hljs-string>"https://schema.org/Organization"</span>,
                             <span class=hljs-string>"name"</span>: translator_name,
                             <span class=hljs-string>"url"</span>: translator_url}
    data[<span class=hljs-string>"translationOfWork"</span>] = %*{<span class=hljs-string>"@id"</span>: src_url}
    data</code></pre><h2 id=opengraph><a class=header-anchor href=#opengraph> Opengraph</a></h2><p>Як і ldjson, ми також надаємо мета-теги opengraph:<pre><code class="nim hljs"><span class=hljs-keyword>proc</span> opgBasic(title, tp, url, image: <span class=hljs-type>string</span>, prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>if</span> prefix != <span class=hljs-string>""</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:title"</span>, title)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:type"</span>, tp)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:url"</span>, url)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>fmt"{prefix}:image"</span>, image)
  <span class=hljs-keyword>else</span>:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"title"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"type"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"url"</span>, image)
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"image"</span>, image)

<span class=hljs-keyword>proc</span> opgTags(title, tp, url,
             image: <span class=hljs-type>string</span>,
             description = <span class=hljs-string>""</span>,
             siteName = <span class=hljs-string>""</span>,
             locale = <span class=hljs-string>""</span>,
             audio = <span class=hljs-string>""</span>,
             video = <span class=hljs-string>""</span>,
             determiner = <span class=hljs-string>""</span>,
             prefix = <span class=hljs-string>""</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] <span class=hljs-meta>{.gcsafe.}</span> =
  <span class=hljs-comment>## Generates an HTML String containing opengraph meta result for one item.</span>
  <span class=hljs-keyword>var</span> <span class=hljs-built_in>result</span> = opgBasic(title, tp, url, image, prefix)
  <span class=hljs-built_in>result</span>.add opgOptional(description, siteName, locale, audio, video, determiner)
  <span class=hljs-keyword>return</span> <span class=hljs-built_in>result</span>

<span class=hljs-keyword>proc</span> opgPage*(a: <span class=hljs-type>Article</span>): <span class=hljs-type>seq</span>[<span class=hljs-type>XmlNode</span>] =
  <span class=hljs-keyword>let</span> locale = <span class=hljs-keyword>static</span>(<span class=hljs-type>DEFAULT_LOCALE</span>)
  <span class=hljs-keyword>let</span>
    tp = <span class=hljs-keyword>static</span>(<span class=hljs-string>"article"</span>)
    url = getArticleUrl(a)
    siteName = <span class=hljs-keyword>static</span>(<span class=hljs-type>WEBSITE_TITLE</span>)
  <span class=hljs-built_in>result</span> = opgTags(a.title, tp, url, a.imageUrl, a.desc, siteName, locale, prefix = <span class=hljs-string>"article"</span>)
  <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> a.tags:
    <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:tag"</span>, t)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:author"</span>, a.author)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:published_time"</span>, $a.pubTime)
  <span class=hljs-built_in>result</span>.add metaTag(<span class=hljs-string>"article:section"</span>, a.desc)
  <span class=hljs-comment># result.add metaTag("article:modified_time", a.pubTime)</span>
  <span class=hljs-comment># result.add metaTag("article:expiration_time", a.pubTime)</span>
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"card"</span>, <span class=hljs-string>"summary"</span>)
  <span class=hljs-built_in>result</span>.add twitterMeta(<span class=hljs-string>"creator"</span>, twitterUrl[])</code></pre><p>Макроси та шаблони Nim стають у пригоді, коли ви маєте справу з усім цим шаблонним важким кодом.<h2 id=server_side_http_requests><a class=header-anchor href=#server_side_http_requests> http-запити на стороні сервера</a></h2><p>Існує ще одне завдання, яке обробляє всі http-запити (для отримання зображень, сценаріїв тощо) з боку веб-сервера. Ми використовуємо httpclient chronos:<pre><code class="nim hljs"><span class=hljs-keyword>const</span> proxiedFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NewConnectionAlways</span>}
<span class=hljs-keyword>const</span> sessionFlags = {<span class=hljs-type>NoVerifyHost</span>, <span class=hljs-type>NoVerifyServerName</span>, <span class=hljs-type>NoInet6Resolution</span>}
<span class=hljs-keyword>proc</span> requestTask(q: sink <span class=hljs-keyword>ptr</span> <span class=hljs-type>Request</span>) <span class=hljs-meta>{.async.}</span> =
  <span class=hljs-keyword>var</span> trial = <span class=hljs-number>0</span>
  <span class=hljs-keyword>var</span>
    sess: <span class=hljs-type>HttpSessionRef</span>
    req: <span class=hljs-type>HttpClientRequestRef</span>
    resp: <span class=hljs-type>HttpClientResponseRef</span>
    cleanup: <span class=hljs-type>seq</span>[<span class=hljs-type>Future</span>[<span class=hljs-type>void</span>]]
  <span class=hljs-keyword>while</span> trial < q[].retries:
    <span class=hljs-keyword>try</span>:
      trial.inc
      sess = new(<span class=hljs-type>HttpSessionRef</span>,
                proxyTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>3</span>),
                headersTimeout = <span class=hljs-number>10</span>.seconds.<span class=hljs-keyword>div</span>(<span class=hljs-number>2</span>),
                connectTimeout = <span class=hljs-number>10</span>.seconds,
                proxy = <span class=hljs-keyword>if</span> q[].proxied: selectProxy(trial) <span class=hljs-keyword>else</span>: <span class=hljs-string>""</span>,
                flags = <span class=hljs-keyword>if</span> q[].proxied: proxiedFlags <span class=hljs-keyword>else</span>: sessionFlags
      )
      req = new(<span class=hljs-type>HttpClientRequestRef</span>,
                sess,
                sess.getAddress(q[].url).get,
                q[].meth,
                headers = q[].headers.toHeaderTuple,
                body = q[].body.tobytes,
        )
      resp = await req.fetch(followRedirects = q[].redir, raw = <span class=hljs-literal>true</span>)
      checkNil(resp):
        defer:
          cleanup.add resp.closeWait()
          resp = <span class=hljs-keyword>nil</span>
        q.response.code = httpcore.<span class=hljs-type>HttpCode</span>(resp.status)
        checkNil(resp.connection):
          q.response.body = bytesToString (await resp.getBodyBytes)
          q.response.headers = newHttpHeaders(<span class=hljs-keyword>cast</span>[<span class=hljs-type>seq</span>[(<span class=hljs-type>string</span>, <span class=hljs-type>string</span>)]](
              resp.headers.toList))
        <span class=hljs-keyword>break</span>
    <span class=hljs-keyword>except</span>:
      cdebug():
        logexc()
        debug <span class=hljs-string>"cronhttp: request failed"</span>
    <span class=hljs-keyword>finally</span>:
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> req.isnil:
        cleanup.add req.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> resp.isnil:
        cleanup.add resp.closeWait()
      <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> sess.isnil:
        cleanup.add sess.closeWait()
  httpOut[q] = <span class=hljs-literal>true</span>
  await allFutures(cleanup)</code></pre><p>Довелося додати<a href=https://github.com/untoreh/nim-chronos/tree/update> підтримка https і socks5 проксі</a> httpclient, щоб мати можливість ефективно використовувати переклади.<h1 id=config><a class=header-anchor href=#config> Конфігурація</a></h1><p>Можливо, ви помітили змінні з великої літери в коді. Усе це змінні конфігурації, визначені у файлі, який можна налаштувати для кожного веб-сайту.<pre><code class="nim hljs"><span class=hljs-keyword>const</span>
  <span class=hljs-type>BASE_URL</span>* = <span class=hljs-type>Uri</span>()
  <span class=hljs-type>SITE_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"site"</span>
  <span class=hljs-type>SITE_ASSETS_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>SITE_ASSETS_DIR</span>* = <span class=hljs-type>SITE_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"data"</span>
  <span class=hljs-type>DATA_ASSETS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>DATA_ADS_PATH</span>* = <span class=hljs-type>DATA_PATH</span> / <span class=hljs-string>"ads"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>ASSETS_PATH</span>* = <span class=hljs-type>PROJECT_PATH</span> / <span class=hljs-string>"src"</span> / <span class=hljs-string>"assets"</span>
  <span class=hljs-type>DEFAULT_IMAGE</span>* = <span class=hljs-type>ASSETS_PATH</span> / <span class=hljs-string>"empty.png"</span>
  <span class=hljs-type>DEFAULT_IMAGE_MIME</span>* = <span class=hljs-string>"image/png"</span>
  <span class=hljs-type>CSS_BUN_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.css"</span>)
  <span class=hljs-type>CSS_CRIT_PATH</span>* = <span class=hljs-type>SITE_ASSETS_DIR</span> / <span class=hljs-string>"bundle-crit.css"</span>
  <span class=hljs-type>JS_REL_URL</span>* = $(<span class=hljs-type>SITE_ASSETS_PATH</span> / <span class=hljs-string>"bundle.js"</span>)
  <span class=hljs-type>LOGO_PATH</span>* = <span class=hljs-type>BASE_URL</span> / <span class=hljs-string>"assets"</span> / <span class=hljs-string>"logo"</span> / <span class=hljs-type>WEBSITE_NAME</span>
  <span class=hljs-type>LOGO_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo.svg"</span>)
  <span class=hljs-type>LOGO_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small.svg"</span>)
  <span class=hljs-type>LOGO_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>LOGO_DARK_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_SMALL_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-small-dark.svg"</span>)
  <span class=hljs-type>LOGO_DARK_ICON_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon-dark.svg"</span>)
  <span class=hljs-type>FAVICON_PNG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.png"</span>)
  <span class=hljs-type>FAVICON_SVG_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"logo-icon.svg"</span>)
  <span class=hljs-type>APPLE_PNG180_URL</span>* = $(<span class=hljs-type>LOGO_PATH</span> / <span class=hljs-string>"apple-touch-icon.png"</span>)
  <span class=hljs-type>MAX_DIR_FILES</span>* = <span class=hljs-number>10</span>
<span class=hljs-comment># ...</span></code></pre><h1 id=conclusion><a class=header-anchor href=#conclusion> Висновок</a></h1><p>Є купа речей, про які я не згадав, оскільки диявол криється в деталях... однак це приблизний огляд усієї кодової бази, яка становить:<ul><li><p>~12 тис. рядків нім<li><p>~400 рядків js<li><p>~1000 рядків scss<li><p>~3500 рядків Python<li><p>74 lines of rust (for bindings :P)</ul><p>Що б я зробив інакше?<ul><li><p>Ймовірно, я перепишу все в rust, nim наразі погано справляється з безпекою пам’яті, і кількість часу, який я мав покладатися на gdb, щоб виправити збої, була надто великою, і мені навіть не вдалося виправити їх усі. Це велика проблема, коли половина екосистеми покладається на GC, а інша половина на ORC (або навіть не orc, а лише ARC). Змішування асинхронних і потоків також болісно, ​​а асинхронні трасування стеків — це кошмар (хоча я не знаю, чи краще в цьому відношенні rust).<li><p>Ціль а<a href=https://en.wikipedia.org/wiki/Progressive_web_app> PWA</a> з самого початку. Проект мав досить клопіткий початок. Спочатку це мали бути статичні сторінки, які обслуговує веб-сервер, потім це стало самим веб-сервером. Інтерактивність з’явилася позаду, тож стала просто сумішшю відтвореного html і js/css. Це зробило мене занадто слабким щодо API, який вийшов без будь-якої структури (повністю<a href=https://en.wikipedia.org/wiki/Representational_state_transfer> неспокійний</a> ). У переписуванні я б також використав структуру інтерфейсу користувача<a href=https://preactjs.com/> прект</a> який має повну підтримку AMP, або<a href=https://www.solidjs.com/> solidjs</a>.<li><p>Додайте більше спеціальних аналізаторів для популярних платформ. Звичайний синтаксичний аналіз статей не працює (або взагалі не працює), коли найпопулярніші платформи сьогодні пропонують дуже мало вмісту та багато відео та зображень, тому копіювання має бути більш націленим на мультимедіа, а не просто на текст, якщо це не так враховуючи під час планування архітектури скребка, вміст і інформація, які обслуговуватиме APP, будуть незбалансованими.</ul><div id=post-tags-list>Теги дописів: <span class=post-tag><a href=https://www.unto.re/tag/apps> додатків</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/programming> програмування</a>, </span><span class=post-tag><a href=https://www.unto.re/tag/software> програмне забезпечення</a></span></div><div class=page-foot><div class=copyright>11 грудня 2022 р</div><script async crossorigin=anonymous issue-term=pathname label=Comment repo=untoreh/untoreh.github.io src=https://utteranc.es/client.js></script></div></div><div class=page__footer><footer><div class=page__footer-copyright>© untoreh - Працює на<a href=https://github.com/tlienart/Franklin.jl> Франклін</a></div><div class=page__footer-links>- <ul><li><a href=/uk/sitemapxml> Карта сайту</a></li> | <li><a href=/uk/tag> Теги</a></li> | <li><a href=https://www.unto.re/tag/feed.xml> RSS</a></ul></div><ul class=author__wrap><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="Twitter link"href=https://twitter.com/untoreh><i class="fab fa-fw fa-twitter-square"aria-hidden=true></i></a><li class="author__urls social-icons"><a rel="nofollow noopener noreferrer" title="GitHub link"href=https://github.com/untoreh><i class="fab fa-fw fa-github"aria-hidden=true></i></a><li class="author__urls social-icons"><a href=mailto:contact@unto.re title=email><i class="fas fa-envelope"></i></a><li><script type=application/ld+json>{"potentialAction":{"query-input":"required maxlength=100 name=input","actionStatus":"https://schema.org/PotentialActionStatus","query":"required","@type":"SearchAction","target":{"uri":"","scheme":"https","userinfo":"","host":"www.unto.re","port":"","path":"/search","query":"q=%7Binput%7D","fragment":""}}}</script></ul></footer></div><script crossorigin=anonymous defer id=fa integrity=sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH src=https://use.fontawesome.com/releases/v5.8.2/js/all.js></script><script src=/libs/colors.js></script><script src=/libs/menu.js></script><script defer src=/libs/lunr/lunr.min.js></script>